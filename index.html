<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Bennett Hub - Smart Dashboard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <!-- PWA Manifest -->
  <link rel="manifest" href="/smart-dashboard/manifest.json">
  
  <!-- PWA Meta Tags -->
  <meta name="application-name" content="Bennett Hub">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Bennett Hub">
  <meta name="description" content="Smart Dashboard for Todo Lists, Grocery Lists, Meal Planning, and Calendar Management">
  <meta name="format-detection" content="telephone=no">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="msapplication-config" content="browserconfig.xml">
  <meta name="msapplication-TileColor" content="#1976d2">
  <meta name="msapplication-tap-highlight" content="no">
  <meta name="theme-color" content="#8c5ec4">
  
  <!-- Apple Touch Icons -->
  <link rel="apple-touch-icon" href="/smart-dashboard/icon-152.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/smart-dashboard/icon-152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/smart-dashboard/icon-180.png">
  <link rel="apple-touch-icon" sizes="167x167" href="/smart-dashboard/icon-167.png">
  
  <!-- Standard Favicon -->
  <link rel="icon" type="image/png" sizes="32x32" href="/smart-dashboard/icon-32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/smart-dashboard/icon-16.png">
  <link rel="shortcut icon" href="/smart-dashboard/favicon.ico">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
    
    /* Landing Page Styles */
    .landing-page {
      min-height: 100vh;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2rem;
    }

    .landing-container {
      text-align: center;
      max-width: 800px;
      width: 100%;
    }

    .landing-title {
      font-size: 3rem;
      font-weight: 700;
      color: white;
      margin: 0 0 0.5rem 0;
      text-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }

    .landing-subtitle {
      font-size: 1.2rem;
      color: rgba(255, 255, 255, 0.9);
      margin: 0 0 3rem 0;
      font-weight: 300;
    }

    .navigation-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1.5rem;
      max-width: 600px;
      margin: 0 auto;
    }

    .nav-button {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 20px;
      padding: 2rem;
      color: white;
      text-decoration: none;
      transition: all 0.3s ease;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
    }

    .nav-button:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: translateY(-4px);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
    }

    .nav-icon {
      font-size: 2.5rem;
    }
    
    /* Calendar icon: Ensure inline styles take precedence */
    .nav-button:nth-child(2) .nav-icon img {
      width: 3.5rem !important;
      height: 3.5rem !important;
      margin: -0.5rem 0 !important;
      transform: translateY(0.4rem) !important;
      object-fit: contain !important;
    }
    
    /* Grocery icon: Apple and baguette in basket */
    .nav-button:nth-child(6) .nav-icon {
      position: relative;
      display: inline-block;
      width: 50px;
      height: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 auto;
      font-size: 2rem;
      background: transparent;
    }

    .nav-button:nth-child(6) .nav-icon .emoji-basket {
      position: absolute !important;
      font-size: 2.5rem !important;
      bottom: -3px !important;
      left: 50% !important;
      transform: translateX(-50%) !important;
      z-index: 0 !important;
    }
    
    .nav-button:nth-child(6) .nav-icon .emoji-base {
      position: absolute !important;
      right: 7px !important;
      top: 25% !important;
      transform: translateY(-50%) !important;
      z-index: 1 !important;
      font-size: 1.3rem !important;
    }
    
    .nav-button:nth-child(6) .nav-icon .emoji-overlay {
      position: absolute !important;
      left: 11px !important;
      top: 28% !important;
      transform: translateY(-50%) !important;
      z-index: 2 !important;
      font-size: 1.15rem !important;
      filter: drop-shadow(1px 1px 2px rgba(0, 0, 0, 0.3)) !important;
    }

    .nav-label {
      font-size: 1.1rem;
      font-weight: 500;
    }

    .dashboard {
      min-height: 100vh;
    }

    @media (max-width: 768px) {
      .landing-title {
        font-size: 2rem;
      }
      
      .navigation-grid {
        grid-template-columns: repeat(2, 1fr);
        gap: 1rem;
      }
      
      .nav-button {
        padding: 1.5rem;
      }
      
      .nav-icon {
        font-size: 2rem;
      }
    }
    
    :root {
      --primary-color: #667eea;
      --primary-dark: #5a6fd8;
      --secondary-color: #764ba2;
      --accent-color: #f093fb;
      --success-color: #4ade80;
      --danger-color: #f87171;
      --warning-color: #fbbf24;
      --background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      --card-background: rgba(255, 255, 255, 0.95);
      --text-primary: #1f2937;
      --text-secondary: #6b7280;
      --border-color: #e5e7eb;
      --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
      --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
    }

    * {
      box-sizing: border-box;
    }

    html {
      background: var(--background) !important;
      margin: 0 !important;
      padding: 0 !important;
      min-height: 100vh !important;
    }

    body {
      margin: 0;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--background) !important;
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow-x: hidden;
      /* Ensure background extends to safe areas on iOS */
      padding-top: env(safe-area-inset-top);
      padding-bottom: env(safe-area-inset-bottom);
      margin-top: calc(-1 * env(safe-area-inset-top));
      margin-bottom: calc(-1 * env(safe-area-inset-bottom));
    }
    
    /* iOS PWA Status Bar Fix - Applied immediately */
    @media (display-mode: standalone) {
      html, body {
        background: linear-gradient(135deg, #8c5ec4 0%, #764ba2 100%) !important;
        background-attachment: fixed !important;
        margin: 0 !important;
        padding: 0 !important;
      }
      
      body::before {
        content: '';
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        height: 100px;
        background: linear-gradient(135deg, #8c5ec4 0%, #764ba2 100%);
        z-index: -1;
      }
    }

    header {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid rgba(255, 255, 255, 0.2);
      color: white;
      text-align: center;
      padding: 1.5rem;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      position: relative;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    header::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(45deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%);
      pointer-events: none;
    }

    .header-title {
      font-size: 2rem;
      font-weight: 600;
      margin: 0;
      z-index: 1;
      position: relative;
    }

    .home-button {
      position: absolute;
      left: 2rem;
      top: 50%;
      transform: translateY(-50%);
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: white;
      border-radius: 12px;
      padding: 0.8rem 1rem;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 1.2rem;
      z-index: 2;
    }

    .home-button:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: translateY(-50%) scale(1.05);
    }

    .header-info {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 2rem;
      font-size: 1rem;
      font-weight: 400;
      opacity: 0.9;
      z-index: 1;
      position: relative;
    }

    .info-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      background: rgba(255, 255, 255, 0.1);
      padding: 0.5rem 1rem;
      border-radius: 20px;
      backdrop-filter: blur(5px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      transition: all 0.3s ease;
    }

    .info-item:hover {
      background: rgba(255, 255, 255, 0.15);
      transform: translateY(-1px);
    }

    .info-icon {
      font-size: 1.1rem;
    }

    .weather-temp {
      font-weight: 500;
    }

    .loading {
      opacity: 0.6;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 0.6; }
      50% { opacity: 1; }
    }

    main {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      grid-template-rows: minmax(400px, 1fr) minmax(200px, 1fr);
      flex: 1;
      gap: 1.5rem;
      padding: 2rem;
      box-sizing: border-box;
      animation: fadeIn 0.6s ease-out;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .widget {
      background: var(--card-background);
      backdrop-filter: blur(10px);
      border-radius: 20px;
      box-shadow: var(--shadow-xl);
      padding: 2rem;
      overflow: hidden;
      position: relative;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .widget:hover {
      transform: translateY(-2px);
      box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.15);
    }

    .widget::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: linear-gradient(90deg, var(--primary-color), var(--accent-color));
      border-radius: 20px 20px 0 0;
    }

    .calendar-widget {
      grid-column: 1 / 4;
      grid-row: 1;
      /* Force stable dimensions to prevent layout shifts */
      min-height: 400px;
      max-height: 600px;
      overflow: hidden;
      /* Complete isolation from other widgets */
      contain: layout style size;
      transform: translateZ(0); /* Force hardware acceleration and isolation */
      will-change: auto;
    }
    
    .calendar-widget iframe {
      /* Ensure iframe doesn't cause layout changes */
      width: 100% !important;
      height: 100% !important;
      min-height: 350px;
      max-height: 550px;
      /* Force iframe isolation and stability */
      contain: strict;
      transform: translateZ(0);
      backface-visibility: hidden;
      pointer-events: auto;
      position: relative;
      z-index: 1;
    }

    .todo-widget {
      grid-column: 1;
      grid-row: 2;
      /* Force stable dimensions to prevent layout shifts */
      min-height: 400px;
      max-height: 400px;
      display: flex;
      flex-direction: column;
      /* Complete isolation from other widgets */
      contain: layout style size;
      transform: translateZ(0);
      will-change: auto;
    }

    .todo-widget .task-list {
      max-height: 250px;
      overflow-y: auto;
      overflow-x: hidden;
      flex: 1;
      min-height: 0;
    }

    .todo-widget #todo-add-container {
      /* Fixed height for add container to prevent size changes */
      min-height: 60px;
      max-height: 80px;
      flex-shrink: 0;
      display: flex;
      flex-direction: row;
      justify-content: flex-start;
      align-items: flex-start;
    }

    .grocery-widget {
      grid-column: 2;
      grid-row: 2;
      /* Force stable dimensions to prevent layout shifts */
      min-height: 400px;
      max-height: 400px;
      display: flex;
      flex-direction: column;
      /* Complete isolation from other widgets */
      contain: layout style size;
      transform: translateZ(0);
      will-change: auto;
    }

    .grocery-widget .task-list {
      max-height: 250px;
      overflow-y: auto;
      overflow-x: hidden;
      flex: 1;
      min-height: 0;
    }

    .meals-widget {
      grid-column: 3;
      grid-row: 2;
      /* Force stable dimensions to prevent layout shifts */
      min-height: 400px;
      max-height: 400px;
      display: flex;
      flex-direction: column;
      /* Complete isolation to prevent affecting other widgets */
      contain: layout style size;
      isolation: isolate;
      transform: translateZ(0);
      /* Prevent any cascading effects */
      will-change: auto;
    }

    .meals-widget .task-list {
      max-height: 250px;
      overflow-y: auto;
      overflow-x: hidden;
      flex: 1;
      min-height: 0;
    }

    iframe {
      border: 0;
      width: 100%;
      height: 100%;
      border-radius: 10px;
      /* Prevent any external interference with iframe content */
      isolation: isolate;
      contain: layout style;
      transform: translateZ(0);
      /* Ensure iframe renders independently */
      display: block;
      box-sizing: border-box;
    }

    h2 {
      margin: 0 0 1.5rem 0;
      text-align: center;
      color: var(--text-primary);
      font-size: 1.5rem;
      font-weight: 600;
      position: relative;
      padding-bottom: 0.5rem;
      cursor: pointer;
      transition: all 0.3s ease;
      user-select: none;
      flex-shrink: 0;
    }

    h2:hover {
      color: var(--primary-color);
      transform: translateY(-1px);
    }

    h2::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 40px;
      height: 3px;
      background: linear-gradient(90deg, var(--primary-color), var(--accent-color));
      border-radius: 2px;
      transition: width 0.3s ease;
    }

    h2:hover::after {
      width: 60px;
    }

    /* Full-screen mode styles */
    .fullscreen-mode {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 1000;
      background: var(--background);
      display: flex;
      flex-direction: column;
      animation: slideInFullscreen 0.3s ease-out;
    }

    @keyframes slideInFullscreen {
      from { opacity: 0; transform: scale(0.95); }
      to { opacity: 1; transform: scale(1); }
    }

    .fullscreen-header {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid rgba(255, 255, 255, 0.2);
      color: white;
      padding: 1rem 2rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .fullscreen-title {
      font-size: 1.5rem;
      font-weight: 600;
      margin: 0;
    }

    .back-button {
      background: rgba(255, 255, 255, 0.2);
      border: 1px solid rgba(255, 255, 255, 0.3);
      color: white;
      padding: 0.5rem 1rem;
      border-radius: 20px;
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 500;
      transition: all 0.3s ease;
      backdrop-filter: blur(5px);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .back-button:hover {
      background: rgba(255, 255, 255, 0.3);
      transform: translateY(-1px);
    }

    .auto-return-indicator {
      font-size: 0.8rem;
      opacity: 0.7;
      color: rgba(255, 255, 255, 0.8);
      margin-left: 1rem;
      display: flex;
      align-items: center;
      gap: 0.3rem;
    }

    .auto-return-dot {
      width: 6px;
      height: 6px;
      background: rgba(255, 255, 255, 0.6);
      border-radius: 50%;
      animation: pulse 2s infinite;
    }

    .fullscreen-content {
      flex: 1;
      padding: 1rem 2rem;
      overflow: hidden;
      background: var(--card-background);
      margin: 0.5rem;
      border-radius: 20px;
      box-shadow: var(--shadow-xl);
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .hidden {
      display: none !important;
    }

    /* Meals-specific styles */
    .meal-item {
      display: flex;
      align-items: center;
      padding: 16px 0;
      border-bottom: 1px solid rgba(0, 0, 0, 0.05);
      gap: 12px;
      transition: all 0.2s ease;
      animation: slideIn 0.3s ease-out;
    }

    .meal-item:hover {
      background: rgba(102, 126, 234, 0.03);
      border-radius: 8px;
      margin: 0;
      padding-left: 8px;
      padding-right: 0;
    }

    .meal-text {
      flex: 1;
      font-size: 15px;
      line-height: 1.5;
      word-wrap: break-word;
      color: var(--text-primary);
      transition: all 0.3s ease;
    }

    .meal-text.completed {
      text-decoration: line-through;
      color: var(--text-secondary);
      opacity: 0.7;
    }

    .meal-link {
      color: var(--primary-color);
      text-decoration: none;
      font-weight: 500;
    }

    .meal-link:hover {
      text-decoration: underline;
    }

    .history-button {
      background: linear-gradient(135deg, var(--secondary-color), var(--accent-color));
      color: white;
      border: none;
      border-radius: 8px;
      padding: 6px 12px;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.3s ease;
      position: absolute;
      right: 0;
      top: 50%;
      transform: translateY(-50%);
      min-width: 60px;
      text-align: center;
    }

    .history-button:hover {
      transform: translateY(-50%) translateY(-1px);
      box-shadow: var(--shadow-md);
    }

    /* Drag and Drop Styles */
    .task-item {
      cursor: move;
      transition: all 0.2s ease;
      position: relative;
    }

    .task-item:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .task-item.dragging {
      opacity: 0.6;
      transform: scale(1.02);
      z-index: 1000;
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
      border: 2px solid var(--primary-color);
      background: rgba(255, 255, 255, 0.1);
    }

    /* Insertion indicator - shows where item will be dropped */
    .task-item.drop-target-above::before {
      content: '';
      position: absolute;
      top: -2px;
      left: 0;
      right: 0;
      height: 4px;
      background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
      border-radius: 2px;
      box-shadow: 0 0 8px var(--primary-color);
      z-index: 1001;
      animation: dropIndicator 0.6s ease-in-out infinite alternate;
    }

    .task-item.drop-target-below::after {
      content: '';
      position: absolute;
      bottom: -2px;
      left: 0;
      right: 0;
      height: 4px;
      background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
      border-radius: 2px;
      box-shadow: 0 0 8px var(--primary-color);
      z-index: 1001;
      animation: dropIndicator 0.6s ease-in-out infinite alternate;
    }

    @keyframes dropIndicator {
      0% { opacity: 0.7; transform: scaleX(0.8); }
      100% { opacity: 1; transform: scaleX(1); }
    }

    .drag-handle {
      position: absolute;
      left: 8px;
      top: 50%;
      transform: translateY(-50%);
      color: var(--text-secondary);
      font-size: 16px;
      opacity: 0.6;
      transition: all 0.2s ease;
      cursor: grab;
      padding: 4px;
      border-radius: 4px;
      user-select: none;
    }

    .drag-handle:hover {
      opacity: 1;
      background: rgba(255, 255, 255, 0.1);
      color: var(--primary-color);
    }

    .drag-handle:active {
      cursor: grabbing;
      background: rgba(255, 255, 255, 0.2);
    }

    /* Drag handle positioning - padding is set in main .task-item rule */

    .task-list {
      position: relative;
    }

    /* Fullscreen History Button Styles */
    .fullscreen-history-button {
      background: linear-gradient(135deg, var(--secondary-color), var(--accent-color));
      color: white;
      border: none;
      border-radius: 8px;
      padding: 8px 16px;
      font-size: 1.2rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.3s ease;
      position: absolute;
      right: 0;
      top: 50%;
      transform: translateY(-50%);
      min-width: 80px;
      text-align: center;
    }

    .fullscreen-history-button:hover {
      transform: translateY(-50%) translateY(-1px);
      box-shadow: var(--shadow-md);
    }

    .meal-url-input {
      width: 100%;
      padding: 8px 12px;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      font-size: 13px;
      margin-top: 8px;
      transition: all 0.3s ease;
    }

    .meal-url-input:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1);
    }

    .add-from-history-btn {
      background: var(--success-color);
      color: white;
      border: none;
      border-radius: 6px;
      padding: 4px 8px;
      font-size: 11px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .add-from-history-btn:hover {
      background: #22c55e;
      transform: scale(1.05);
    }

    #clear-search-btn {
      background: var(--danger-color);
      color: white;
      border: none;
      border-radius: 8px;
      padding: 12px 16px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      transition: all 0.2s ease;
      min-width: auto;
    }

    #clear-search-btn:hover {
      background: #dc2626;
      transform: scale(1.05);
    }

    .add-item-container {
      display: flex;
      gap: 12px;
      margin-bottom: 1.5rem;
      position: relative;
      flex-shrink: 0;
      min-height: 60px;
      align-items: flex-start;
    }

    .add-item-container input {
      flex: 1;
      padding: 12px 16px;
      border: 2px solid var(--border-color);
      border-radius: 12px;
      font-size: 14px;
      font-family: inherit;
      background: rgba(255, 255, 255, 0.8);
      transition: all 0.3s ease;
      color: var(--text-primary);
    }

    .add-item-container input:focus {
      outline: none;
      border-color: var(--primary-color);
      background: white;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
      transform: translateY(-1px);
    }

    .add-item-container input::placeholder {
      color: var(--text-secondary);
    }

    .add-item-container button {
      padding: 12px 20px;
      background: linear-gradient(135deg, var(--primary-color), var(--primary-dark));
      color: white;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      font-family: inherit;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: var(--shadow-md);
      position: relative;
      overflow: hidden;
    }

    .add-item-container button:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }

    .add-item-container button:active {
      transform: translateY(0);
    }

    .add-item-container button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: left 0.5s;
    }

    .add-item-container button:hover::before {
      left: 100%;
    }

    .task-list {
      list-style: none;
      padding: 0;
      margin: 0;
      max-height: 350px;
      overflow-y: auto;
      scrollbar-width: thin;
      scrollbar-color: var(--primary-color) transparent;
    }

    .task-list::-webkit-scrollbar {
      width: 6px;
    }

    .task-list::-webkit-scrollbar-track {
      background: transparent;
    }

    .task-list::-webkit-scrollbar-thumb {
      background: var(--primary-color);
      border-radius: 3px;
    }

    .task-item {
      display: flex;
      align-items: center;
      padding: 16px 0;
      padding-left: 56px;
      border-bottom: 1px solid rgba(0, 0, 0, 0.05);
      gap: 12px;
      transition: all 0.2s ease;
      animation: slideIn 0.3s ease-out;
      position: relative;
    }
    
    /* Ensure drag handle spacing in all contexts */
    .task-list .task-item,
    .fullscreen-mode .task-item {
      padding-left: 56px;
    }
    
    /* Fullscreen task list optimization */
    .fullscreen-mode .task-list {
      flex: 1;
      overflow-y: auto;
      margin: 0;
      padding: 0;
      min-height: 0;
      max-height: none;
      /* Ensure drag events work properly */
      touch-action: manipulation;
      -webkit-overflow-scrolling: touch;
    }
    
    /* Ensure drag handles work in fullscreen */
    .fullscreen-mode .drag-handle {
      position: absolute;
      left: 8px;
      top: 50%;
      transform: translateY(-50%);
      z-index: 10;
      pointer-events: auto;
      cursor: grab;
      user-select: none;
    }
    
    .fullscreen-mode .drag-handle:active {
      cursor: grabbing;
    }
    
    /* Ensure task items are properly positioned for dragging in fullscreen */
    .fullscreen-mode .task-item {
      position: relative;
      z-index: 1;
    }
    
    .fullscreen-mode .task-item.dragging {
      z-index: 1000;
    }
    
    .fullscreen-mode .add-item-container {
      flex-shrink: 0;
      margin-bottom: 1rem;
    }
    
    /* Fullscreen header containers should not grow */
    .fullscreen-content > div:first-child {
      flex-shrink: 0;
    }

    @keyframes slideIn {
      from { opacity: 0; transform: translateX(-20px); }
      to { opacity: 1; transform: translateX(0); }
    }

    .task-item:last-child {
      border-bottom: none;
    }

    .task-item:hover {
      background: rgba(102, 126, 234, 0.03);
      border-radius: 8px;
      margin: 0;
      padding-left: 56px;
      padding-right: 0;
    }

    .task-checkbox {
      width: 20px;
      height: 20px;
      margin-left: 0px;
      margin-right: 12px;
      accent-color: var(--primary-color);
      cursor: pointer;
      transition: transform 0.2s ease;
    }

    .task-checkbox:hover {
      transform: scale(1.1);
    }

    .task-text {
      flex: 1;
      font-size: 15px;
      line-height: 1.5;
      word-wrap: break-word;
      color: var(--text-primary);
      transition: all 0.3s ease;
    }

    .task-text.completed {
      text-decoration: line-through;
      color: var(--text-secondary);
      opacity: 0.7;
    }

    .task-due-date {
      font-size: 12px;
      color: var(--text-secondary);
      background: rgba(102, 126, 234, 0.1);
      padding: 2px 6px;
      border-radius: 10px;
      margin-left: 8px;
      white-space: nowrap;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .task-due-date:hover {
      background: rgba(102, 126, 234, 0.2);
      transform: translateY(-1px);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .task-due-date.overdue {
      background: rgba(239, 68, 68, 0.1);
      color: #dc2626;
      border: 1px solid rgba(239, 68, 68, 0.2);
    }

    .task-due-date.overdue:hover {
      background: rgba(239, 68, 68, 0.2);
      transform: translateY(-1px);
      box-shadow: 0 2px 4px rgba(239, 68, 68, 0.2);
    }

    .task-due-date.due-today {
      background: rgba(251, 146, 60, 0.1);
      color: #ea580c;
      border: 1px solid rgba(251, 146, 60, 0.2);
    }

    .task-due-date.due-today:hover {
      background: rgba(251, 146, 60, 0.2);
      transform: translateY(-1px);
      box-shadow: 0 2px 4px rgba(251, 146, 60, 0.2);
    }

    .task-due-date.due-tomorrow {
      background: rgba(250, 204, 21, 0.1);
      color: #d97706;
      border: 1px solid rgba(250, 204, 21, 0.2);
    }

    .task-due-date.due-tomorrow:hover {
      background: rgba(250, 204, 21, 0.2);
      transform: translateY(-1px);
      box-shadow: 0 2px 4px rgba(250, 204, 21, 0.2);
    }

    .task-item.overdue {
      border-left: 3px solid #dc2626;
      background: rgba(239, 68, 68, 0.02);
    }

    .task-item.due-today {
      border-left: 3px solid #ea580c;
      background: rgba(251, 146, 60, 0.02);
    }

    .task-item.due-tomorrow {
      border-left: 3px solid #d97706;
      background: rgba(250, 204, 21, 0.02);
    }

    .person-avatar {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      font-size: 11px;
      font-weight: bold;
      color: white;
      margin-right: 8px;
      flex-shrink: 0;
    }

    .person-avatar.emley {
      background: #d946ef; /* Softer magenta-pink that complements the gradient */
    }

    .person-avatar.nate {
      background: #60a5fa; /* Lighter blue for maximum contrast with purple */
    }

    .person-avatar.family {
      background: #9333ea; /* Deeper purple for better contrast with blue */
    }

    .avatar-filter, .fullscreen-avatar-filter {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      font-size: 14px;
      font-weight: bold;
      color: white;
      cursor: pointer;
      border: 2px solid transparent;
      transition: all 0.2s ease;
      margin: 0 4px;
    }

    .avatar-filter:hover, .fullscreen-avatar-filter:hover {
      transform: scale(1.1);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    }

    .avatar-filter.active, .fullscreen-avatar-filter.active {
      border-color: #fff;
      box-shadow: 0 0 0 2px var(--primary-color);
      transform: scale(1.05);
    }

    .avatar-filter.emley, .fullscreen-avatar-filter.emley {
      background: #d946ef;
    }

    .avatar-filter.nate, .fullscreen-avatar-filter.nate {
      background: #60a5fa;
    }

    .avatar-filter.family, .fullscreen-avatar-filter.family {
      background: #9333ea;
    }

    .avatar-filters-container {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      margin: 0.5rem 0;
    }

    .add-item-container input[type="date"] {
      padding: 8px 12px;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      background: var(--bg-secondary);
      color: var(--text-primary);
      font-size: 14px;
      min-width: 140px;
    }

    .add-item-container input[type="date"]:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }

    .add-item-container select {
      padding: 8px 12px;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      background: var(--bg-secondary);
      color: var(--text-primary);
      font-size: 14px;
      min-width: 100px;
    }

    .add-item-container select:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }

    .task-actions {
      display: flex;
      gap: 4px;
      opacity: 1; /* Always visible for better accessibility */
      transition: opacity 0.2s ease;
    }

    .task-item:hover .task-actions {
      opacity: 1;
    }

    .delete-btn, .edit-btn {
      background: none;
      border: none;
      cursor: pointer;
      padding: 8px;
      border-radius: 8px;
      font-size: 16px;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 32px;
      height: 32px;
    }

    .delete-btn {
      color: var(--danger-color);
    }

    .delete-btn:hover {
      background-color: rgba(248, 113, 113, 0.1);
      transform: scale(1.1);
    }

    .edit-btn {
      color: var(--primary-color);
    }

    .edit-btn:hover {
      background-color: rgba(102, 126, 234, 0.1);
      transform: scale(1.1);
    }

    .empty-state {
      text-align: center;
      color: var(--text-secondary);
      font-style: italic;
      padding: 3rem 1rem;
      font-size: 15px;
      background: rgba(102, 126, 234, 0.02);
      border-radius: 12px;
      border: 2px dashed rgba(102, 126, 234, 0.2);
    }

    .date-header {
      background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
      color: white;
      padding: 0.8rem 1rem;
      margin: 1rem 0 0.5rem 0;
      border-radius: 12px;
      font-weight: 600;
      font-size: 0.95rem;
      text-align: center;
      box-shadow: 0 2px 8px rgba(102, 126, 234, 0.2);
    }

    .history-item {
      background: rgba(102, 126, 234, 0.05);
      border-left: 3px solid var(--primary-color);
      margin-left: 1rem;
    }

    .history-item .task-text {
      color: var(--text-secondary);
      /* Removed strikethrough - history items should appear normal */
    }

    .history-item:hover {
      background: rgba(102, 126, 234, 0.08);
      border-radius: 8px;
      margin-left: 1rem;
      margin-right: 0;
    }

    /* Tablet responsiveness */
    @media (min-width: 769px) and (max-width: 1024px) {
      /* Compact header for tablets */
      header {
        padding: 1rem; /* Reduce from 1.5rem to 1rem */
      }
      
      .header-title {
        font-size: 1.6rem; /* Reduce from 2rem to 1.6rem */
        margin-bottom: 0.5rem; /* Add small margin */
      }
      
      .header-info {
        gap: 1.5rem; /* Reduce from 2rem to 1.5rem */
        font-size: 0.9rem; /* Slightly smaller text */
      }
      
      .info-item {
        padding: 0.4rem 0.8rem; /* More compact info items */
      }
      
      /* Calendar optimizations */
      .calendar-widget {
        padding: 1rem;
        min-height: 300px !important; /* Much smaller for tablets */
        max-height: 300px !important; /* Force stable height */
        overflow: hidden;
        /* Enhanced isolation for tablets */
        contain: layout style size !important;
        transform: translateZ(0) !important;
        isolation: isolate;
      }
      
      .calendar-widget iframe {
        height: 250px !important; /* Much smaller calendar height for tablets */
        min-height: 250px !important;
        max-height: 250px !important;
        /* Force iframe isolation on tablets */
        contain: strict !important;
        transform: translateZ(0) !important;
        backface-visibility: hidden !important;
        position: relative !important;
        z-index: 1 !important;
      }
      
      .calendar-widget h2 {
        margin-bottom: 1rem; /* Reduce header margin */
      }
      
      .widget {
        padding: 1.5rem; /* Slightly reduce widget padding on tablets */
      }
      
      /* Make other widgets more compact on tablets */
      .todo-widget, .grocery-widget, .meals-widget {
        padding: 1.2rem;
      }
      
      /* Optimize main grid for better space usage */
      main {
        gap: 1rem; /* Reduce gap between widgets */
        padding: 1rem; /* Reduce main padding */
      }
    }

    /* Mobile responsiveness */
    @media (max-width: 768px) {
      main {
        grid-template-columns: 1fr;
        grid-template-rows: auto auto auto auto;
        padding: 1rem;
        gap: 1rem;
      }

      .calendar-widget {
        grid-column: 1;
        grid-row: 1;
      }

      .todo-widget {
        grid-column: 1;
        grid-row: 2;
      }

      .grocery-widget {
        grid-column: 1;
        grid-row: 3;
      }

      .meals-widget {
        grid-column: 1;
        grid-row: 4;
      }

      .widget {
        padding: 1.5rem;
      }

      header {
        padding: 1rem;
      }

      .header-title {
        font-size: 1.5rem;
      }

      .header-info {
        flex-direction: column;
        gap: 0.5rem;
      }

      .info-item {
        font-size: 0.9rem;
        padding: 0.4rem 0.8rem;
      }

      #precipitation-info {
        font-size: 0.8rem;
        padding: 0.3rem 0.6rem;
      }
      
      .add-item-container {
        flex-direction: column;
        gap: 8px;
      }
      
      .add-item-container button {
        padding: 14px;
        font-size: 16px;
      }
      
      .task-item {
        padding: 14px 0;
      }
      
      .task-text {
        font-size: 16px;
      }

      .task-actions {
        opacity: 1; /* Always show on mobile */
      }

      h2 {
        font-size: 1.25rem;
      }

      .fullscreen-header {
        padding: 1rem;
        flex-direction: column;
        gap: 1rem;
        text-align: center;
      }

      .fullscreen-title {
        font-size: 1.25rem;
      }

      .fullscreen-content {
        margin: 0.25rem;
        padding: 0.75rem 1rem;
      }

      .auto-return-indicator {
        display: none; /* Hide on mobile to save space */
      }
    }

    @media (max-width: 480px) {
      main {
        padding: 0.5rem;
      }

      .widget {
        padding: 1rem;
        border-radius: 16px;
      }

      header {
        font-size: 1.25rem;
      }
    }

    /* Dark mode support */
    @media (prefers-color-scheme: dark) {
      :root {
        --card-background: rgba(30, 41, 59, 0.95);
        --text-primary: #f1f5f9;
        --text-secondary: #94a3b8;
        --border-color: #334155;
      }

      .widget {
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .add-item-container input {
        background: rgba(30, 41, 59, 0.8);
        color: var(--text-primary);
        border-color: var(--border-color);
      }

      .add-item-container input:focus {
        background: rgba(30, 41, 59, 0.95);
      }
    }

    /* Reduced motion support */
    @media (prefers-reduced-motion: reduce) {
      * {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
    }
  </style>
</head>
<body>
  <!-- Landing Page -->
  <div id="landing-page" class="landing-page">
    <div class="landing-container">
      <h1 class="landing-title">Bennett Hub</h1>
      <p class="landing-subtitle">Your Smart Dashboard</p>
      
      <div class="navigation-grid">
        <button class="nav-button" onclick="showDashboard()">
          <span class="nav-icon">🏠</span>
          <span class="nav-label">Dashboard</span>
        </button>
        
        <button class="nav-button" onclick="showFullscreenCalendar()">
          <span class="nav-icon">
            <img src="google_icon_with_white_outline.png?v=72-force" alt="Calendar" style="width: 3.5rem; height: 3.5rem; margin: -0.5rem 0; transform: translateY(0.4rem); object-fit: contain;">
          </span>
          <span class="nav-label">Calendar</span>
        </button>
        
        <button class="nav-button" onclick="showFullscreenTodo()">
          <span class="nav-icon">✅</span>
          <span class="nav-label">To-Do</span>
        </button>
        
        <button class="nav-button" onclick="showFullscreenTodoHistory()">
          <span class="nav-icon">📋</span>
          <span class="nav-label">To-Do History</span>
        </button>
        
        <button class="nav-button" onclick="showFullscreenTodoCalendar()">
          <span class="nav-icon">📅</span>
          <span class="nav-label">To-Do Calendar</span>
        </button>
        
        <button class="nav-button" onclick="showFullscreenGrocery()">
          <span class="nav-icon">
            <span class="emoji-basket">🧺</span>
            <span class="emoji-base">🥖</span>
            <span class="emoji-overlay">🍎</span>
          </span>
          <span class="nav-label">Grocery</span>
        </button>
        
        <button class="nav-button" onclick="showFullscreenMeals()">
          <span class="nav-icon">🍽️</span>
          <span class="nav-label">Meals</span>
        </button>
        
        <button class="nav-button" onclick="showFullscreenMealsHistory()">
          <span class="nav-icon">📚</span>
          <span class="nav-label">Meal History</span>
        </button>
      </div>
      
      <!-- Desktop Version Indicator -->
      <div id="desktop-version-indicator" style="
        position: fixed;
        bottom: 10px;
        left: 10px;
        font-size: 11px;
        color: rgba(255, 255, 255, 0.6);
        background: rgba(0, 0, 0, 0.3);
        padding: 4px 8px;
        border-radius: 4px;
        font-family: monospace;
        z-index: 1000;
        pointer-events: none;
      ">
        Desktop v7.2
      </div>
    </div>
  </div>

  <!-- Dashboard -->
  <div id="dashboard" class="dashboard" style="display: none;">
  <header>
    <button class="home-button" onclick="showLandingPage()" title="Home">🏠</button>
    <h1 class="header-title">Bennett Hub</h1>
    <div class="header-info">
      <div class="info-item">
        <span class="info-icon">📅</span>
        <span id="current-date">Loading...</span>
      </div>
      <div class="info-item">
        <span class="info-icon">🕐</span>
        <span id="current-time">Loading...</span>
      </div>
      <div class="info-item">
        <span id="weather-icon" class="info-icon">🌡️</span>
        <span id="current-temp" class="weather-temp loading">Loading...</span>
      </div>
          <div class="info-item" id="precipitation-info" style="display: none;">
            <span id="precip-icon" class="info-icon">💧</span>
            <span id="precip-details" class="weather-temp">--</span>
          </div>
          <div class="info-item" id="sync-status" onclick="manualSync()" style="cursor: pointer;" title="Click to force sync">
            <span id="sync-icon" class="info-icon">☁️</span>
            <span id="sync-text" class="weather-temp">Synced</span>
          </div>
          <div class="info-item" onclick="setupGithubAuth()" style="cursor: pointer;" title="Setup GitHub sync">
            <span class="info-icon">🔐</span>
            <span class="weather-temp">GitHub</span>
          </div>
          <div class="info-item" onclick="showDebugInfo()" style="cursor: pointer;" title="Show debug info">
            <span class="info-icon">🔍</span>
            <span class="weather-temp">Debug</span>
          </div>
        </div>
      </header>
  <main>
    <!-- Google Calendar -->
    <div class="widget calendar-widget" id="calendar-widget">
      <h2 onclick="openFullscreen('calendar')">Calendar</h2>
      <iframe src="https://calendar.google.com/calendar/embed?height=800&wkst=1&bgcolor=%23ffffff&ctz=America%2FDenver&src=holcombe.emley%40gmail.com&color=%232952A3&mode=AGENDA&showTabs=1&showPrint=0&showDate=1&showNav=1&showTitle=0&showTz=0&showCalendars=1" style="border: 0" width="100%" height="100%" frameborder="0"></iframe>

    </div>

    <!-- To-Do List -->
    <div class="widget todo-widget" id="todo-widget">
      <div style="position: relative; text-align: center; margin-bottom: 1.5rem;">
        <button onclick="showFullscreenTodoCalendar()" class="calendar-button" style="position: absolute; left: 0; top: 50%; transform: translateY(-50%); padding: 4px 8px; background: var(--primary-color); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; z-index: 10;">📅 Calendar</button>
        <h2 onclick="openFullscreen('todo')" style="margin: 0; cursor: pointer; display: inline-block; padding: 0 80px;">To-Do List</h2>
        <button onclick="showTodoHistory()" class="history-button">History</button>
      </div>
      <div class="add-item-container" id="todo-add-container">
        <input type="text" id="todo-input" placeholder="Add new task..." maxlength="100">
        <button onclick="addTodoItem()" id="add-todo-btn">Add</button>
      </div>
      <div class="add-item-container" id="todo-secondary-container" style="margin-top: 0.5rem;">
        <input type="date" id="todo-due-date" title="Due date (optional)">
        <div class="avatar-filters-container">
          <span class="avatar-filter emley" data-avatar="emley" onclick="toggleAvatarFilter('emley')" title="Filter by Emley">E</span>
          <span class="avatar-filter nate" data-avatar="nate" onclick="toggleAvatarFilter('nate')" title="Filter by Nate">N</span>
          <span class="avatar-filter family" data-avatar="family" onclick="toggleAvatarFilter('family')" title="Filter by Family">F</span>
        </div>
      </div>
      <ul id="todo-list" class="task-list">
        <!-- Dynamic content will be loaded here -->
      </ul>
    </div>

    <!-- Grocery List -->
    <div class="widget grocery-widget" id="grocery-widget">
      <h2 onclick="openFullscreen('grocery')">Grocery List</h2>
      <div class="add-item-container">
        <input type="text" id="grocery-input" placeholder="Add grocery item..." maxlength="100">
        <button onclick="addGroceryItem()" id="add-grocery-btn">Add</button>
      </div>
      <ul id="grocery-list" class="task-list">
        <!-- Dynamic content will be loaded here -->
      </ul>
    </div>

    <!-- Meals List -->
    <div class="widget meals-widget" id="meals-widget">
      <div style="position: relative; text-align: center; margin-bottom: 1.5rem;">
        <h2 onclick="openFullscreen('meals')" style="margin: 0; cursor: pointer;">Meals</h2>
        <button onclick="showMealsHistory()" class="history-button">History</button>
      </div>
      <div class="add-item-container" id="meals-add-container">
        <input type="text" id="meals-input" placeholder="Add meal..." maxlength="100">
        <button onclick="addMealItem()" id="add-meals-btn">Add</button>
      </div>
      <ul id="meals-list" class="task-list">
        <!-- Dynamic content will be loaded here -->
      </ul>
    </div>
  </main>

  <script>
    // GitHub Sync Configuration
    const GITHUB_USERNAME = 'emleyholcombe'; // Your GitHub username
    let GIST_ID = localStorage.getItem('dashboardGistId') || null;
    const GIST_FILENAME = 'smart-dashboard-data.json';
    let GITHUB_TOKEN = localStorage.getItem('githubToken') || null; // Personal Access Token
    
    // GitHub API endpoints
    const GITHUB_API_BASE = 'https://api.github.com';
    const GISTS_API = `${GITHUB_API_BASE}/gists`;
    
    // Legacy JSONBin.io support (deprecated but kept for migration)
    let JSONBIN_ID = localStorage.getItem('dashboardJsonBinId') || null;
    const JSONBIN_API = 'https://api.jsonbin.io/v3/b';
    
    // Data storage
    let todoItems = [];
    let todoHistory = [];
    let groceryItems = [];
    let mealItems = [];
    let mealHistory = [];
    
    // Data sync status
    let isOnline = navigator.onLine;
    let syncInProgress = false;
    
    // JSONBin.io API functions (free, no auth required)
    async function createJsonBin(data) {
      try {
        console.log('🔄 Creating JSONBin with data:', data);
        console.log('📡 Sending to:', JSONBIN_API);
        
        const payload = {
          dashboardData: data,
          created: new Date().toISOString(),
          version: '1.0'
        };
        
        const response = await fetch(`${JSONBIN_API}`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-Bin-Private': 'false'
          },
          body: JSON.stringify(payload)
        });
        
        console.log('📡 Response status:', response.status, response.statusText);
        
        if (response.ok) {
          const result = await response.json();
          console.log('📦 Full response:', result);
          
          if (result.metadata && result.metadata.id) {
            JSONBIN_ID = result.metadata.id;
            localStorage.setItem('dashboardJsonBinId', JSONBIN_ID);
            console.log('✅ Created new JSONBin:', JSONBIN_ID);
            return true;
          } else {
            console.error('❌ Invalid response structure:', result);
            return false;
          }
        }
        
        const errorText = await response.text();
        console.error('❌ JSONBin creation failed:', response.status, errorText);
        
        // Try alternative approach with a simpler request
        if (response.status === 401 || response.status === 403) {
          console.log('🔄 Trying alternative approach...');
          return await createSimpleStorage(data);
        }
        
        return false;
      } catch (error) {
        console.error('💥 Exception creating JSONBin:', error);
        console.log('🔄 Trying alternative approach...');
        return await createSimpleStorage(data);
      }
    }
    
    // Fallback storage using a simpler service
    async function createSimpleStorage(data) {
      try {
        // Use dpaste.org as fallback
        const formData = new FormData();
        formData.append('content', JSON.stringify(data, null, 2));
        formData.append('syntax', 'json');
        formData.append('expiry_days', '365');
        
        const response = await fetch('https://dpaste.org/api/', {
          method: 'POST',
          body: formData
        });
        
        if (response.ok) {
          const pasteUrl = await response.text();
          JSONBIN_ID = pasteUrl.trim().split('/').pop();
          localStorage.setItem('dashboardJsonBinId', JSONBIN_ID);
          localStorage.setItem('dashboardSyncType', 'dpaste');
          console.log('✅ Created dpaste backup:', JSONBIN_ID);
          return true;
        }
        
        console.error('❌ Fallback storage also failed');
        return false;
      } catch (error) {
        console.error('💥 Fallback storage failed:', error);
        return false;
      }
    }
    
    async function updateJsonBin(data) {
      if (!JSONBIN_ID) return false;
      
      try {
        const response = await fetch(`${JSONBIN_API}/${JSONBIN_ID}`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            dashboardData: data,
            updated: new Date().toISOString(),
            version: '1.0'
          })
        });
        
        if (response.ok) {
          console.log('✅ Updated JSONBin successfully:', JSONBIN_ID);
          return true;
        }
        const errorText = await response.text();
        console.error('❌ JSONBin update failed:', response.status, errorText);
        throw new Error(`HTTP ${response.status}: ${errorText}`);
      } catch (error) {
        console.error('Failed to update JSONBin:', error);
        return false;
      }
    }
    
    async function loadFromJsonBin() {
      if (!JSONBIN_ID) {
        console.log('❌ No JSONBIN_ID found');
        return null;
      }
      
      try {
        const url = `${JSONBIN_API}/${JSONBIN_ID}/latest`;
        console.log('🌐 Fetching from:', url);
        
        const response = await fetch(url);
        console.log('📡 Response status:', response.status, response.statusText);
        
        if (response.ok) {
          const result = await response.json();
          console.log('📦 Raw response:', result);
          
          if (result.record && result.record.dashboardData) {
            console.log('✅ Successfully parsed JSONBin data');
            return result.record.dashboardData;
          } else {
            console.log('❌ Invalid data structure in JSONBin response');
            console.log('Expected: result.record.dashboardData');
            console.log('Got:', Object.keys(result));
          }
        } else {
          const errorText = await response.text();
          console.error('❌ JSONBin fetch failed:', response.status, errorText);
        }
        throw new Error(`HTTP ${response.status}`);
      } catch (error) {
        console.error('💥 Exception loading from JSONBin:', error);
        return null;
      }
    }
    
    // GitHub Gist API functions for master data storage
    async function createGithubGist(data) {
      if (!GITHUB_TOKEN) {
        console.log('❌ No GitHub token found. Please set up authentication first.');
        return false;
      }
      
      try {
        console.log('🔄 Creating GitHub Gist with data:', data);
        
        const gistPayload = {
          description: "Smart Dashboard - Master Data Storage",
          public: false, // Private gist for security
          files: {
            [GIST_FILENAME]: {
              content: JSON.stringify({
                dashboardData: data,
                created: new Date().toISOString(),
                version: '2.0',
                device: navigator.userAgent.includes('Mobile') ? 'Mobile' : 'Desktop'
              }, null, 2)
            }
          }
        };
        
        const response = await fetch(GISTS_API, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${GITHUB_TOKEN}`,
            'Content-Type': 'application/json',
            'Accept': 'application/vnd.github.v3+json'
          },
          body: JSON.stringify(gistPayload)
        });
        
        console.log('📡 Response status:', response.status, response.statusText);
        
        if (response.ok) {
          const result = await response.json();
          console.log('📦 Gist created:', result.id);
          
          GIST_ID = result.id;
          localStorage.setItem('dashboardGistId', GIST_ID);
          console.log('✅ Created new GitHub Gist:', GIST_ID);
          return true;
        } else {
          const errorText = await response.text();
          console.error('❌ GitHub Gist creation failed:', response.status, errorText);
          return false;
        }
      } catch (error) {
        console.error('💥 Exception creating GitHub Gist:', error);
        return false;
      }
    }

    async function updateGithubGist(data) {
      if (!GIST_ID) return await createGithubGist(data);
      if (!GITHUB_TOKEN) {
        console.log('❌ No GitHub token found. Please set up authentication first.');
        return false;
      }
      
      try {
        console.log('🔄 Updating GitHub Gist:', GIST_ID);
        
        const gistPayload = {
          description: "Smart Dashboard - Master Data Storage",
          files: {
            [GIST_FILENAME]: {
              content: JSON.stringify({
                dashboardData: data,
                updated: new Date().toISOString(),
                version: '2.0',
                device: navigator.userAgent.includes('Mobile') ? 'Mobile' : 'Desktop'
              }, null, 2)
            }
          }
        };
        
        const response = await fetch(`${GISTS_API}/${GIST_ID}`, {
          method: 'PATCH',
          headers: {
            'Authorization': `Bearer ${GITHUB_TOKEN}`,
            'Content-Type': 'application/json',
            'Accept': 'application/vnd.github.v3+json'
          },
          body: JSON.stringify(gistPayload)
        });
        
        if (response.ok) {
          console.log('✅ Updated GitHub Gist successfully');
          return true;
        } else {
          const errorText = await response.text();
          console.error('❌ GitHub Gist update failed:', response.status, errorText);
          return false;
        }
      } catch (error) {
        console.error('💥 Exception updating GitHub Gist:', error);
        return false;
      }
    }
    
    async function loadFromGithubGist() {
      if (!GIST_ID) {
        console.log('❌ No GIST_ID found');
        return null;
      }
      
      try {
        const url = `${GISTS_API}/${GIST_ID}`;
        console.log('🌐 Fetching from GitHub Gist:', url);
        
        const headers = {
          'Accept': 'application/vnd.github.v3+json'
        };
        
        // Add auth header if we have a token (for private gists)
        if (GITHUB_TOKEN) {
          headers['Authorization'] = `Bearer ${GITHUB_TOKEN}`;
        }
        
        const response = await fetch(url, { headers });
        console.log('📡 Response status:', response.status, response.statusText);
        
        if (response.ok) {
          const result = await response.json();
          console.log('📦 Gist response received');
          
          if (result.files && result.files[GIST_FILENAME]) {
            const fileContent = result.files[GIST_FILENAME].content;
            const parsedData = JSON.parse(fileContent);
            
            if (parsedData.dashboardData) {
              console.log('✅ Successfully parsed GitHub Gist data');
              console.log('📊 Last updated:', parsedData.updated || parsedData.created);
              return parsedData.dashboardData;
            } else {
              console.log('❌ Invalid data structure in Gist');
            }
          } else {
            console.log('❌ Gist file not found:', GIST_FILENAME);
          }
        } else {
          const errorText = await response.text();
          console.error('❌ GitHub Gist fetch failed:', response.status, errorText);
        }
        
        return null;
      } catch (error) {
        console.error('💥 Exception loading from GitHub Gist:', error);
        return null;
      }
    }
    
    // GitHub token setup function
    async function setupGithubAuth() {
      // Check if token already exists
      if (GITHUB_TOKEN) {
        const response = confirm(`
🔐 GitHub Authentication

You already have a GitHub token configured.

Current status: 
🐙 GitHub Gist ID: ${GIST_ID || 'Not created yet'}
🔑 Token: ${GITHUB_TOKEN.substring(0, 8)}...

Do you want to:
• OK = Exit without changes
• Cancel = Update token`);
        
        if (response) {
          // User clicked OK - exit without changes
          return false;
        }
        // User clicked Cancel - continue to update token
      }
      
      // Show instructions and collect token
      const instructions = `
🔐 GitHub Authentication Setup

To enable GitHub sync, you need a Personal Access Token.

STEP-BY-STEP INSTRUCTIONS:
1. Click OK to open GitHub settings
2. Click "Generate new token" → "Tokens (classic)"
3. Add note: "Smart Dashboard Sync"
4. Set expiration: 1 year (or your preference)
5. Check ONLY the "gist" scope ✅
6. Click "Generate token"
7. Copy the token (starts with ghp_...)
8. Come back here and paste it

Ready to continue?`;
      
      if (!confirm(instructions)) {
        return false;
      }
      
      // Open GitHub token page
      window.open('https://github.com/settings/tokens/new?scopes=gist&description=Smart%20Dashboard%20Sync', '_blank');
      
      // Wait a moment then ask for token
      setTimeout(() => {
        const token = prompt(`
🔑 Paste your GitHub Personal Access Token:

The token should start with "ghp_" and be about 40 characters long.

Token:`);
        
        if (token && token.trim() && token.startsWith('ghp_')) {
          localStorage.setItem('githubToken', token.trim());
          GITHUB_TOKEN = token.trim();
          console.log('✅ GitHub token saved!');
          updateSyncStatus();
          alert('✅ GitHub authentication setup complete!\n\n🐙 Your data will now sync to your private GitHub gist.\n📱 All your devices will stay in sync!');
          
          // Try to migrate existing data if available
          if (todoItems.length || groceryItems.length || mealItems.length) {
            saveAllData();
          }
          
          return true;
        } else if (token) {
          alert('❌ Invalid token format. GitHub tokens start with "ghp_".\n\nClick the GitHub button again to retry.');
          return false;
        } else {
          alert('❌ No token provided. GitHub sync will not work.');
          return false;
        }
      }, 2000);
    }
    
    // Unified data management
    function getCurrentData() {
      return {
        todoItems,
        todoHistory,
        groceryItems,
        mealItems,
        mealHistory,
        lastUpdated: new Date().toISOString()
      };
    }
    
    function setCurrentData(data) {
      if (data.todoItems) {
        todoItems = data.todoItems;
        updateItemOrders(todoItems); // Ensure all items have order property
      }
      if (data.todoHistory) {
        todoHistory = data.todoHistory;
        updateItemOrders(todoHistory); // Ensure all items have order property
      }
      if (data.groceryItems) {
        groceryItems = data.groceryItems;
        updateItemOrders(groceryItems); // Ensure all items have order property
      }
      if (data.mealItems) {
        mealItems = data.mealItems;
        updateItemOrders(mealItems); // Ensure all items have order property
      }
      if (data.mealHistory) {
        mealHistory = data.mealHistory;
        updateItemOrders(mealHistory); // Ensure all items have order property
      }
    }
    
    // Save to both localStorage and GitHub Gist (master storage)
    async function saveAllData() {
      if (syncInProgress) return;
      syncInProgress = true;
      updateSyncStatus();
      
      const data = getCurrentData();
      
      // Always save to localStorage as backup
      localStorage.setItem('todoItems', JSON.stringify(todoItems));
      localStorage.setItem('todoHistory', JSON.stringify(todoHistory));
      localStorage.setItem('groceryItems', JSON.stringify(groceryItems));
      localStorage.setItem('mealItems', JSON.stringify(mealItems));
      localStorage.setItem('mealHistory', JSON.stringify(mealHistory));
      
      // Try to sync to GitHub Gist (master storage) if online
      if (isOnline) {
        let success = false;
        
        // If no GitHub token, ask user to set it up
        if (!GITHUB_TOKEN) {
          console.log('🔐 No GitHub token found - prompting user setup');
          const setupSuccess = await setupGithubAuth();
          if (!setupSuccess) {
            console.log('❌ GitHub auth setup cancelled, data saved locally only');
            syncInProgress = false;
            updateSyncStatus();
            return;
          }
        }
        
        // Try GitHub Gist sync
        if (GIST_ID) {
          success = await updateGithubGist(data);
        } else {
          success = await createGithubGist(data);
        }
        
        if (success) {
          console.log('✅ Data synced to GitHub master storage');
        } else {
          console.log('❌ GitHub sync failed, falling back to JSONBin...');
          
          // Fallback to JSONBin for backward compatibility
          if (JSONBIN_ID) {
            success = await updateJsonBin(data);
          } else {
            success = await createJsonBin(data);
          }
          
          if (success) {
            console.log('✅ Data synced to JSONBin fallback');
          } else {
            console.log('❌ All cloud sync failed, data saved locally only');
          }
        }
      }
      
      syncInProgress = false;
      updateSyncStatus();
    }
    
    // Manual sync function for debugging
    async function manualSync() {
      console.log('🔄 Manual sync triggered...');
      console.log('Current data:', getCurrentData());
      console.log('JSONBIN_ID:', JSONBIN_ID);
      console.log('isOnline:', isOnline);
      
      if (!isOnline) {
        alert('❌ Cannot sync: You are offline');
        return;
      }
      
      const data = getCurrentData();
      const totalItems = data.todoItems.length + data.groceryItems.length + data.mealItems.length + data.todoHistory.length + data.mealHistory.length;
      
      if (totalItems === 0) {
        alert('⚠️ No data to sync! Add some items first, then try syncing.');
        return;
      }
      
      console.log(`🔄 Syncing ${totalItems} items...`);
      
      try {
        syncInProgress = true;
        updateSyncStatus();
        
        await saveAllData();
        
        let syncStatus;
        if (GIST_ID && GITHUB_TOKEN) {
          syncStatus = `✅ Synced to GitHub master storage!\nGist ID: ${GIST_ID}`;
        } else if (JSONBIN_ID) {
          syncStatus = `✅ Synced to fallback storage!\nSync ID: ${JSONBIN_ID}`;
        } else {
          syncStatus = '❌ Sync failed - no cloud storage created';
        }
        
        const debugInfo = `
${syncStatus}

📊 Synced data:
📝 ${data.todoItems.length} current todos
📋 ${data.todoHistory.length} todo history
🛒 ${data.groceryItems.length} grocery items  
🍽️ ${data.mealItems.length} current meals
📚 ${data.mealHistory.length} meal history
⏰ Last Updated: ${data.lastUpdated}

${(GIST_ID && GITHUB_TOKEN) || JSONBIN_ID ? '✅ Your data is now available on all devices!' : ''}
        `;
        
        alert(debugInfo);
        
      } catch (error) {
        console.error('Sync failed:', error);
        alert(`❌ Sync failed: ${error.message}`);
      } finally {
        syncInProgress = false;
        updateSyncStatus();
      }
    }
    
    // Debug function to show current state
    async function showDebugInfo() {
      const data = getCurrentData();
      
      // GitHub Status
      const githubStatus = (GIST_ID && GITHUB_TOKEN) ? 
        `✅ GitHub Gist: ${GIST_ID}` : 
        `❌ GitHub: ${!GITHUB_TOKEN ? 'No token' : 'No gist ID'}`;
      
      // JSONBin Status  
      const jsonbinStatus = JSONBIN_ID ? `✅ JSONBin ID: ${JSONBIN_ID}` : '❌ No JSONBin';
      
      // Try to fetch cloud data for comparison
      let cloudStatus = 'Not checked';
      if (GIST_ID && GITHUB_TOKEN) {
        try {
          const cloudData = await loadFromGithubGist();
          if (cloudData) {
            cloudStatus = `✅ GitHub has ${cloudData.todoItems?.length || 0} todos, ${cloudData.groceryItems?.length || 0} groceries, ${cloudData.mealItems?.length || 0} meals`;
          } else {
            cloudStatus = '❌ Failed to load GitHub data';
          }
        } catch (error) {
          cloudStatus = `❌ GitHub Error: ${error.message}`;
        }
      } else if (JSONBIN_ID) {
        try {
          const cloudData = await loadFromJsonBin();
          if (cloudData) {
            cloudStatus = `✅ JSONBin has ${cloudData.todoItems?.length || 0} todos, ${cloudData.groceryItems?.length || 0} groceries, ${cloudData.mealItems?.length || 0} meals`;
          } else {
            cloudStatus = '❌ Failed to load JSONBin data';
          }
        } catch (error) {
          cloudStatus = `❌ JSONBin Error: ${error.message}`;
        }
      }
      
      const debugInfo = `
📊 Dashboard Debug Info:

🔐 Authentication:
🐙 GitHub Token: ${GITHUB_TOKEN ? `${GITHUB_TOKEN.substring(0, 8)}...` : 'Not set'}
🐙 ${githubStatus}
☁️ ${jsonbinStatus}

🌐 Status:
Online: ${isOnline}
Sync: ${syncInProgress ? 'In Progress' : 'Idle'}
Cloud Status: ${cloudStatus}

📱 Local Data:
📝 Todo Items: ${data.todoItems.length}
📋 Todo History: ${data.todoHistory.length}
🛒 Grocery Items: ${data.groceryItems.length}
🍽️ Meal Items: ${data.mealItems.length}
🍽️ Meal History: ${data.mealHistory.length}
⏰ Last Updated: ${data.lastUpdated}

🔧 localStorage Check:
GitHub Token: ${localStorage.getItem('githubToken') ? 'Saved' : 'Missing'}
Gist ID: ${localStorage.getItem('dashboardGistId') ? 'Saved' : 'Missing'}
JSONBin ID: ${localStorage.getItem('dashboardJsonBinId') ? 'Saved' : 'Missing'}

📋 Current Sync Method: ${(GIST_ID && GITHUB_TOKEN) ? 'GitHub (Master)' : JSONBIN_ID ? 'JSONBin (Fallback)' : 'Local Only'}
      `;
      
      alert(debugInfo);
      
      // No more confusing options - just show the info
      return;
      
      // Remove old debug options code
      if (false) {
        // Prompt for sync ID
        const newSyncId = prompt('Enter sync ID from your other device:');
        if (newSyncId && newSyncId.trim()) {
          JSONBIN_ID = newSyncId.trim();
          localStorage.setItem('dashboardJsonBinId', JSONBIN_ID);
          console.log('🔧 Setting new sync ID:', JSONBIN_ID);
          
          try {
            alert('✅ Sync ID saved! Loading data from cloud...\n\nCheck console for details.');
            console.log('🔄 Starting loadAllData...');
            await loadAllData();
            console.log('✅ loadAllData completed');
            
            // Force re-render all lists
            renderTodoList();
            renderGroceryList();
            renderMealsList();
            console.log('✅ All lists re-rendered');
            
            // Show final status
            const finalData = getCurrentData();
            const totalItems = finalData.todoItems.length + finalData.groceryItems.length + finalData.mealItems.length + finalData.todoHistory.length + finalData.mealHistory.length;
            
            if (totalItems > 0) {
              alert(`🎉 Success! Loaded ${totalItems} items:\n📝 ${finalData.todoItems.length} todos\n📋 ${finalData.todoHistory.length} todo history\n🛒 ${finalData.groceryItems.length} groceries\n🍽️ ${finalData.mealItems.length} meals\n📚 ${finalData.mealHistory.length} meal history`);
            } else {
              alert('⚠️ No items loaded. Check console for errors or verify the sync ID is correct.');
            }
            
          } catch (error) {
            console.error('❌ Error loading data:', error);
            alert(`❌ Error loading data: ${error.message}\n\nCheck console for details.`);
          }
        }
      }
      
      console.log('Debug Info:', data);
    }
    
    // Update sync status indicator
    function updateSyncStatus() {
      const syncIcon = document.getElementById('sync-icon');
      const syncText = document.getElementById('sync-text');
      
      if (!syncIcon || !syncText) return;
      
      if (syncInProgress) {
        syncIcon.textContent = '🔄';
        syncText.textContent = 'Syncing...';
      } else if (!isOnline) {
        syncIcon.textContent = '📱';
        syncText.textContent = 'Offline';
      } else if (GIST_ID && GITHUB_TOKEN) {
        syncIcon.textContent = '🐙';
        syncText.textContent = 'GitHub';
      } else if (JSONBIN_ID) {
        syncIcon.textContent = '☁️';
        syncText.textContent = 'Cloud';
      } else {
        syncIcon.textContent = '💾';
        syncText.textContent = 'Local';
      }
    }
    
    // Load data from GitHub Gist (master) -> JSONBin (fallback) -> localStorage
    async function loadAllData() {
      console.log('🔄 Loading dashboard data...');
      console.log('📊 Initial state:', {
        isOnline,
        hasGistId: !!GIST_ID,
        hasJsonBinId: !!JSONBIN_ID,
        hasGithubToken: !!GITHUB_TOKEN,
        userAgent: navigator.userAgent.includes('Mobile') ? 'Mobile' : 'Desktop'
      });
      
      // First load from localStorage as baseline
      const localTodoItems = JSON.parse(localStorage.getItem('todoItems') || '[]');
      const localTodoHistory = JSON.parse(localStorage.getItem('todoHistory') || '[]');
      const localGroceryItems = JSON.parse(localStorage.getItem('groceryItems') || '[]');
      const localMealItems = JSON.parse(localStorage.getItem('mealItems') || '[]');
      const localMealHistory = JSON.parse(localStorage.getItem('mealHistory') || '[]');
      
      console.log('📱 Local storage data:', {
        todoItems: localTodoItems.length,
        todoHistory: localTodoHistory.length,
        groceryItems: localGroceryItems.length,
        mealItems: localMealItems.length,
        mealHistory: localMealHistory.length
      });
      
      // If online, try to load from master storage (GitHub Gist)
      if (isOnline) {
        let cloudData = null;
        
        // Priority 1: GitHub Gist (master storage)
        if (GIST_ID && GITHUB_TOKEN) {
          console.log('🐙 Attempting to load from GitHub Gist (master):', GIST_ID);
          cloudData = await loadFromGithubGist();
          if (cloudData) {
            setCurrentData(cloudData);
            
            // Update localStorage to match cloud data (prevents future conflicts)
            localStorage.setItem('todoItems', JSON.stringify(cloudData.todoItems || []));
            localStorage.setItem('todoHistory', JSON.stringify(cloudData.todoHistory || []));
            localStorage.setItem('groceryItems', JSON.stringify(cloudData.groceryItems || []));
            localStorage.setItem('mealItems', JSON.stringify(cloudData.mealItems || []));
            localStorage.setItem('mealHistory', JSON.stringify(cloudData.mealHistory || []));
            
            console.log('✅ Successfully loaded data from GitHub master storage:', {
              todoItems: todoItems.length,
              todoHistory: todoHistory.length,
              groceryItems: groceryItems.length,
              mealItems: mealItems.length,
              mealHistory: mealHistory.length
            });
            return;
          } else {
            console.log('❌ Failed to load from GitHub, trying fallback...');
          }
        }
        
        // Priority 2: JSONBin (fallback for migration)
        if (JSONBIN_ID) {
          console.log('🌐 Attempting to load from JSONBin (fallback):', JSONBIN_ID);
          cloudData = await loadFromJsonBin();
          if (cloudData) {
            setCurrentData(cloudData);
            
            // Update localStorage to match cloud data (prevents future conflicts)
            localStorage.setItem('todoItems', JSON.stringify(cloudData.todoItems || []));
            localStorage.setItem('todoHistory', JSON.stringify(cloudData.todoHistory || []));
            localStorage.setItem('groceryItems', JSON.stringify(cloudData.groceryItems || []));
            localStorage.setItem('mealItems', JSON.stringify(cloudData.mealItems || []));
            localStorage.setItem('mealHistory', JSON.stringify(cloudData.mealHistory || []));
            
            console.log('✅ Successfully loaded data from JSONBin fallback');
            
            // Migrate to GitHub if we have the token
            if (GITHUB_TOKEN) {
              console.log('🔄 Migrating JSONBin data to GitHub master storage...');
              await saveAllData(); // This will create GitHub Gist
            }
            return;
          } else {
            console.log('❌ Failed to load from JSONBin fallback');
          }
        }
        
        console.log('⚠️ No cloud storage available or failed to load');
      } else {
        console.log('📱 Offline mode - using local storage only');
      }
      
      // Fallback to localStorage
      todoItems = localTodoItems;
      todoHistory = localTodoHistory;
      groceryItems = localGroceryItems;
      mealItems = localMealItems;
      mealHistory = localMealHistory;
      
      console.log('📱 Using local storage data:', {
        todoItems: todoItems.length,
        todoHistory: todoHistory.length,
        groceryItems: groceryItems.length,
        mealItems: mealItems.length,
        mealHistory: mealHistory.length
      });
      
      // If we have local data but no cloud storage, offer to create master storage
      if (isOnline && !GIST_ID && (todoItems.length || groceryItems.length || mealItems.length)) {
        console.log('🚀 Local data found but no master storage - will create on next save');
        // saveAllData() will be called when user adds/modifies data
      }
    }
    let showingMealHistory = false;
    let showingTodoHistory = false;
    let selectedAvatarFilters = []; // Array to track selected avatar filters ('emley', 'nate', 'family')

    // Initialize lists on page load
    document.addEventListener('DOMContentLoaded', async function() {
      console.log('DOMContentLoaded fired, initializing dashboard...');
      
      // PWA-specific initialization
      if (window.matchMedia && window.matchMedia('(display-mode: standalone)').matches) {
        console.log('🚀 PWA Mode detected - ensuring proper data sync');
        
        // Add a small delay to ensure PWA context is fully loaded
        await new Promise(resolve => setTimeout(resolve, 200));
        
        // Debug PWA data loading
        console.log('🔍 PWA Debug Info Before Loading:');
        console.log('- GIST_ID from localStorage:', localStorage.getItem('dashboardGistId'));
        console.log('- GITHUB_TOKEN exists:', !!localStorage.getItem('githubToken'));
        console.log('- JSONBIN_ID from localStorage:', localStorage.getItem('dashboardJsonBinId'));
        console.log('- Navigator online:', navigator.onLine);
      }
      
      // Load data from cloud or localStorage
      await loadAllData();
      
      // One-time migration to fix legacy history items
      let needsSave = false;
      todoHistory.forEach(item => {
        if (item.completedAt && item.completed === undefined) {
          item.completed = true;
          needsSave = true;
        }
      });
      
      if (needsSave) {
        saveTodoHistory();
        console.log('Migrated legacy history items to include completed flag');
      }
      
      // Clean up old completed items first
      cleanupCompletedItems();
      
      console.log('About to render lists...');
      renderTodoList();
      renderGroceryList();
      renderMealsList();
      console.log('Lists rendered.');
      
      // Handle URL parameters AFTER data is loaded and lists are rendered
      console.log('🔗 Handling URL parameters...');
      console.log('Current URL:', window.location.href);
      console.log('URL search params:', window.location.search);
      const urlParams = new URLSearchParams(window.location.search);
      console.log('View parameter:', urlParams.get('view'));
      
      // TEMPORARILY DISABLE URL parameter handling for debugging
      // handleURLParameters();
      console.log('✅ URL parameters handling DISABLED for debugging');
      
      // Monitor online status
      window.addEventListener('online', () => {
        isOnline = true;
        console.log('Back online - syncing data...');
        updateSyncStatus();
        saveAllData();
      });
      
      window.addEventListener('offline', () => {
        isOnline = false;
        console.log('Offline - data will sync when reconnected');
        updateSyncStatus();
      });
      
      // Initial sync status update
      updateSyncStatus();
      
      // Initialize header info
      updateDateTime();
      updateWeather();
      
      // Update time every second
      setInterval(updateDateTime, 1000);
      
      // Update weather every 10 minutes
      setInterval(updateWeather, 10 * 60 * 1000);
      
      // Add Enter key support for inputs
      document.getElementById('todo-input').addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
          addTodoItem();
        }
      });
      
      document.getElementById('grocery-input').addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
          addGroceryItem();
        }
      });
      
      document.getElementById('meals-input').addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
          addMealItem();
        }
      });

      // Set up automatic cleanup at midnight
      scheduleNextCleanup();
    });

    // Todo List Functions
    function addTodoItem() {
      const input = document.getElementById('todo-input');
      const dueDateInput = document.getElementById('todo-due-date');
      const text = input.value.trim();
      const dueDate = dueDateInput.value;
      
      if (text) {
        const item = {
          id: Date.now(),
          text: text,
          completed: false,
          createdAt: new Date().toISOString(),
          order: Date.now(), // Add order property for sorting
          dueDate: dueDate || null, // Add due date if provided
          assignedTo: 'family' // Auto-assign to family by default
        };
        
        todoItems.unshift(item); // Add to beginning of array
        updateItemOrders(todoItems); // Update all orders
        saveTodoItems();
        renderTodoList();
        input.value = '';
        dueDateInput.value = '';
      }
    }

    function toggleTodoItem(id) {
      const item = todoItems.find(item => item.id === id);
      if (item) {
        if (!item.completed) {
          // Item is being checked off - move to history immediately
          item.completedAt = new Date().toISOString();
          
          // If this was re-added from history, remove the old history entry
          if (item.originalHistoryId) {
            todoHistory = todoHistory.filter(h => h.id !== item.originalHistoryId);
          }
          
          // Add to history immediately when completed
          const historyItem = {
            id: Date.now() + Math.random(),
            text: item.text,
            completed: true, // Mark as completed in history
            completedAt: item.completedAt,
            originalId: item.id,
            order: Date.now(), // Add order property for sorting
            dueDate: item.dueDate // Preserve due date in history
          };
          todoHistory.unshift(historyItem);
          updateItemOrders(todoHistory); // Update all orders
          saveTodoHistory();
          
          // Remove from current list immediately
          todoItems = todoItems.filter(t => t.id !== id);
          
        } else {
          // This shouldn't happen with the new workflow, but keeping for safety
          item.completed = false;
          delete item.completedAt;
        }
        
        saveTodoItems();
        renderTodoList();
      }
    }

    function deleteTodoItem(id) {
      todoItems = todoItems.filter(item => item.id !== id);
      saveTodoItems();
      renderTodoList();
    }

    function editTodoItem(id) {
      const item = todoItems.find(item => item.id === id);
      if (item) {
        // Create a modal dialog for editing
        const modal = document.createElement('div');
        modal.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0, 0, 0, 0.5);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 10000;
        `;
        
        const dialog = document.createElement('div');
        dialog.style.cssText = `
          background: var(--bg-primary);
          padding: 24px;
          border-radius: 12px;
          box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
          max-width: 400px;
          width: 90%;
          border: 1px solid var(--border-color);
        `;
        
        dialog.innerHTML = `
          <h3 style="margin: 0 0 16px 0; color: var(--text-primary);">Edit Task</h3>
          <input type="text" id="edit-task-text" value="${escapeHtml(item.text)}" 
                 style="width: 100%; padding: 8px 12px; border: 1px solid var(--border-color); 
                        border-radius: 8px; background: var(--bg-secondary); color: var(--text-primary); 
                        font-size: 14px; margin-bottom: 12px; box-sizing: border-box;">
          <select id="edit-task-assigned-to" 
                  style="width: 100%; padding: 8px 12px; border: 1px solid var(--border-color); 
                         border-radius: 8px; background: var(--bg-secondary); color: var(--text-primary); 
                         font-size: 14px; margin-bottom: 12px; box-sizing: border-box;">
            <option value="emley" ${item.assignedTo === 'emley' ? 'selected' : ''}>Emley</option>
            <option value="nate" ${item.assignedTo === 'nate' ? 'selected' : ''}>Nate</option>
            <option value="family" ${item.assignedTo === 'family' ? 'selected' : ''}>Family</option>
          </select>
          <input type="date" id="edit-task-due-date" value="${item.dueDate || ''}" 
                 style="width: 100%; padding: 8px 12px; border: 1px solid var(--border-color); 
                        border-radius: 8px; background: var(--bg-secondary); color: var(--text-primary); 
                        font-size: 14px; margin-bottom: 16px; box-sizing: border-box;">
          <div style="display: flex; gap: 8px; justify-content: flex-end;">
            <button id="edit-cancel-btn" style="padding: 8px 16px; border: 1px solid var(--border-color); 
                    border-radius: 6px; background: var(--bg-secondary); color: var(--text-primary); 
                    cursor: pointer;">Cancel</button>
            <button id="edit-save-btn" style="padding: 8px 16px; border: none; border-radius: 6px; 
                    background: var(--primary-color); color: white; cursor: pointer;">Save</button>
          </div>
        `;
        
        modal.appendChild(dialog);
        document.body.appendChild(modal);
        
        // Focus on text input
        const textInput = document.getElementById('edit-task-text');
        textInput.focus();
        textInput.select();
        
        // Handle save
        const saveBtn = document.getElementById('edit-save-btn');
        const cancelBtn = document.getElementById('edit-cancel-btn');
        const dueDateInput = document.getElementById('edit-task-due-date');
        const assignedToInput = document.getElementById('edit-task-assigned-to');
        
        const handleSave = () => {
          const newText = textInput.value.trim();
          const newDueDate = dueDateInput.value;
          const newAssignedTo = assignedToInput.value;
          
          if (newText) {
            item.text = newText;
            item.dueDate = newDueDate || null;
            item.assignedTo = newAssignedTo || null;
          saveTodoItems();
            
            // Render the appropriate view (widget or fullscreen)
            if (document.getElementById('fullscreen-container')) {
              renderTodoListFullscreen();
            } else {
          renderTodoList();
        }
      }
          document.body.removeChild(modal);
        };
        
        const handleCancel = () => {
          document.body.removeChild(modal);
        };
        
        saveBtn.addEventListener('click', handleSave);
        cancelBtn.addEventListener('click', handleCancel);
        
        // Handle Enter key in text input
        textInput.addEventListener('keypress', (e) => {
          if (e.key === 'Enter') {
            handleSave();
          }
        });
        
        // Handle Enter key in date input
        dueDateInput.addEventListener('keypress', (e) => {
          if (e.key === 'Enter') {
            handleSave();
          }
        });
        
        // Handle Escape key
        modal.addEventListener('keydown', (e) => {
          if (e.key === 'Escape') {
            handleCancel();
          }
        });
        
        // Handle click outside dialog
        modal.addEventListener('click', (e) => {
          if (e.target === modal) {
            handleCancel();
          }
        });
      }
    }

    function renderTodoList() {
      const list = document.getElementById('todo-list');
      
      if (showingTodoHistory) {
        let filteredHistory = [...todoHistory];
        
        // Apply search filters
        if (currentTodoSearchTerm) {
          filteredHistory = fuzzySearchTodos(filteredHistory, currentTodoSearchTerm);
        }
        
        if (currentDateFrom || currentDateTo) {
          filteredHistory = filterTodosByDateRange(filteredHistory, currentDateFrom, currentDateTo);
        }
        
        // Apply avatar filters
        filteredHistory = filterTodosByAvatar(filteredHistory);
        
        if (filteredHistory.length === 0) {
          const emptyMessage = (currentTodoSearchTerm || currentDateFrom || currentDateTo || selectedAvatarFilters.length > 0) ? 
            'No tasks found matching your search criteria.' : 
            'No completed tasks yet.';
          list.innerHTML = `<li class="empty-state">${emptyMessage}</li>`;
          list.style.setProperty('margin-top', '3rem', 'important'); // Add spacing even for empty state
          return;
        }
        
        const groups = groupTodosByDate(filteredHistory);
        list.innerHTML = renderTodoHistoryGrouped(groups);
        
        // Add extra top margin when showing history to prevent overlap with avatar filters
        list.style.setProperty('margin-top', '3rem', 'important');
        
        // Set up drag and drop for history items (within date groups only)
        setTimeout(() => setupTodoHistoryDragAndDrop(list, groups), 0);
      } else {
        // Reset margin when not showing history
        list.style.removeProperty('margin-top');
        
        // Only show uncompleted items (completed items are immediately moved to history)
        let activeItems = todoItems.filter(item => !item.completed);
        
        // Apply avatar filters
        activeItems = filterTodosByAvatar(activeItems);
        
        if (activeItems.length === 0) {
          const emptyMessage = selectedAvatarFilters.length > 0 ? 
            'No tasks found for selected filters.' : 
            'No tasks yet. Add one above!';
          list.innerHTML = `<li class="empty-state">${emptyMessage}</li>`;
          return;
        }
        
        // Sort by order and ensure all items have order property
        updateItemOrders(activeItems);
        activeItems = sortItemsByOrder(activeItems);
        
        list.innerHTML = activeItems.map(item => {
          const dueDateDisplay = item.dueDate ? formatDueDate(item.dueDate) : '';
          const isOverdue = item.dueDate && isTaskOverdue(item.dueDate);
          const isDueToday = item.dueDate && isTaskDueToday(item.dueDate);
          const isDueTomorrow = item.dueDate && isTaskDueTomorrow(item.dueDate);
          
          let dueDateClass = '';
          let taskItemClass = '';
          
          if (isOverdue) {
            dueDateClass = 'overdue';
            taskItemClass = 'overdue';
          } else if (isDueToday) {
            dueDateClass = 'due-today';
            taskItemClass = 'due-today';
          } else if (isDueTomorrow) {
            dueDateClass = 'due-tomorrow';
            taskItemClass = 'due-tomorrow';
          }
          
          const assignedTo = item.assignedTo || 'family'; // Default to family if not assigned
          const avatarHtml = `<span class="person-avatar ${assignedTo}" onclick="editTodoAssignment(${item.id})" title="Click to change assignment - Currently: ${assignedTo === 'emley' ? 'Emley' : assignedTo === 'nate' ? 'Nate' : 'Family'}" style="cursor: pointer;">${assignedTo === 'emley' ? 'E' : assignedTo === 'nate' ? 'N' : 'F'}</span>`;
          
          return `
            <li class="task-item ${taskItemClass}">
            <span class="drag-handle">☰</span>
            <input type="checkbox" class="task-checkbox" 
                   onchange="toggleTodoItem(${item.id})">
            ${avatarHtml}
            <span class="task-text">${escapeHtml(item.text)}</span>
            ${dueDateDisplay ? `<span class="task-due-date ${dueDateClass}" onclick="editTodoDueDate(${item.id})" title="Click to edit due date">${dueDateDisplay}</span>` : ''}
            <div class="task-actions">
              <button class="edit-btn" onclick="editTodoItem(${item.id})" title="Edit">✏️</button>
              <button class="delete-btn" onclick="deleteTodoItem(${item.id})" title="Delete">🗑️</button>
            </div>
          </li>
          `;
        }).join('');
        
        // Set up drag and drop
        setTimeout(() => setupDragAndDrop(list, activeItems, 'todo'), 0);
      }
    }

    function saveTodoItems() {
      saveAllData();
    }

    function formatDueDate(dateString) {
      // Parse date as local date to avoid timezone issues
      const dateParts = dateString.split('-');
      const date = new Date(dateParts[0], dateParts[1] - 1, dateParts[2]); // Year, Month (0-indexed), Day
      
      const today = new Date();
      const tomorrow = new Date(today);
      tomorrow.setDate(today.getDate() + 1);
      
      // Reset time to compare dates only
      today.setHours(0, 0, 0, 0);
      tomorrow.setHours(0, 0, 0, 0);
      date.setHours(0, 0, 0, 0);
      
      if (date.getTime() === today.getTime()) {
        return 'Today';
      } else if (date.getTime() === tomorrow.getTime()) {
        return 'Tomorrow';
      } else {
        return date.toLocaleDateString('en-US', { 
          month: 'short', 
          day: 'numeric',
          year: date.getFullYear() !== today.getFullYear() ? 'numeric' : undefined
        });
      }
    }

    function isTaskOverdue(dateString) {
      // Parse date as local date to avoid timezone issues
      const dateParts = dateString.split('-');
      const dueDate = new Date(dateParts[0], dateParts[1] - 1, dateParts[2]); // Year, Month (0-indexed), Day
      
      const today = new Date();
      
      // Reset time to compare dates only
      today.setHours(0, 0, 0, 0);
      dueDate.setHours(0, 0, 0, 0);
      
      return dueDate.getTime() < today.getTime();
    }

    function isTaskDueToday(dateString) {
      // Parse date as local date to avoid timezone issues
      const dateParts = dateString.split('-');
      const dueDate = new Date(dateParts[0], dateParts[1] - 1, dateParts[2]); // Year, Month (0-indexed), Day
      
      const today = new Date();
      
      // Reset time to compare dates only
      today.setHours(0, 0, 0, 0);
      dueDate.setHours(0, 0, 0, 0);
      
      return dueDate.getTime() === today.getTime();
    }

    function isTaskDueTomorrow(dateString) {
      // Parse date as local date to avoid timezone issues
      const dateParts = dateString.split('-');
      const dueDate = new Date(dateParts[0], dateParts[1] - 1, dateParts[2]); // Year, Month (0-indexed), Day
      
      const today = new Date();
      const tomorrow = new Date(today);
      tomorrow.setDate(today.getDate() + 1);
      
      // Reset time to compare dates only
      tomorrow.setHours(0, 0, 0, 0);
      dueDate.setHours(0, 0, 0, 0);
      
      return dueDate.getTime() === tomorrow.getTime();
    }

    function editTodoAssignment(id) {
      const item = todoItems.find(item => item.id === id);
      if (!item) return;
      
      // Create a simple modal for assignment selection
      const modal = document.createElement('div');
      modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
      `;
      
      const dialog = document.createElement('div');
      dialog.style.cssText = `
        background: var(--bg-primary);
        padding: 24px;
        border-radius: 12px;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
        max-width: 300px;
        width: 90%;
        border: 1px solid var(--border-color);
      `;
      
      dialog.innerHTML = `
        <h3 style="margin: 0 0 16px 0; color: var(--text-primary);">Change Assignment</h3>
        <div style="display: flex; flex-direction: column; gap: 8px; margin-bottom: 16px;">
          <button onclick="updateAssignment(${id}, 'emley')" style="padding: 12px; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-secondary); color: var(--text-primary); cursor: pointer; text-align: left; display: flex; align-items: center; gap: 8px;">
            <span class="person-avatar emley" style="width: 16px; height: 16px; font-size: 10px;">E</span>
            Emley
          </button>
          <button onclick="updateAssignment(${id}, 'nate')" style="padding: 12px; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-secondary); color: var(--text-primary); cursor: pointer; text-align: left; display: flex; align-items: center; gap: 8px;">
            <span class="person-avatar nate" style="width: 16px; height: 16px; font-size: 10px;">N</span>
            Nate
          </button>
          <button onclick="updateAssignment(${id}, 'family')" style="padding: 12px; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-secondary); color: var(--text-primary); cursor: pointer; text-align: left; display: flex; align-items: center; gap: 8px;">
            <span class="person-avatar family" style="width: 16px; height: 16px; font-size: 10px;">F</span>
            Family
          </button>
        </div>
        <div style="display: flex; justify-content: flex-end;">
          <button onclick="closeAssignmentModal()" style="padding: 8px 16px; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-secondary); color: var(--text-primary); cursor: pointer;">Cancel</button>
        </div>
      `;
      
      modal.appendChild(dialog);
      document.body.appendChild(modal);
      
      // Store modal reference for closing
      window.currentAssignmentModal = modal;
      
      // Close on background click
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          closeAssignmentModal();
        }
      });
    }
    
    function updateAssignment(id, newAssignment) {
      const item = todoItems.find(item => item.id === id);
      if (item) {
        item.assignedTo = newAssignment || 'family'; // Default to family if somehow empty
        saveTodoItems();
        
        // Render the appropriate view
        if (document.getElementById('fullscreen-container')) {
          renderTodoListFullscreen();
        } else {
          renderTodoList();
        }
      }
      closeAssignmentModal();
    }
    
    function closeAssignmentModal() {
      if (window.currentAssignmentModal) {
        document.body.removeChild(window.currentAssignmentModal);
        window.currentAssignmentModal = null;
      }
    }

    function toggleAvatarFilter(avatar) {
      const index = selectedAvatarFilters.indexOf(avatar);
      if (index > -1) {
        // Remove filter if already selected
        selectedAvatarFilters.splice(index, 1);
      } else {
        // Add filter if not selected
        selectedAvatarFilters.push(avatar);
      }
      
      // Update filter button appearance
      updateAvatarFilterButtons();
      
      // Re-render the todo list with filters applied
      if (document.getElementById('fullscreen-container')) {
        renderTodoListFullscreen();
      } else {
        renderTodoList();
      }
    }

    function updateAvatarFilterButtons() {
      // Update widget filter buttons
      const widgetFilters = document.querySelectorAll('.avatar-filter');
      widgetFilters.forEach(button => {
        const avatar = button.dataset.avatar;
        if (selectedAvatarFilters.includes(avatar)) {
          button.classList.add('active');
        } else {
          button.classList.remove('active');
        }
      });
      
      // Update fullscreen filter buttons
      const fullscreenFilters = document.querySelectorAll('.fullscreen-avatar-filter');
      fullscreenFilters.forEach(button => {
        const avatar = button.dataset.avatar;
        if (selectedAvatarFilters.includes(avatar)) {
          button.classList.add('active');
        } else {
          button.classList.remove('active');
        }
      });
    }

    function filterTodosByAvatar(items) {
      // If no filters selected, show all items
      if (selectedAvatarFilters.length === 0) {
        return items;
      }
      
      // Filter items based on selected avatars
      return items.filter(item => {
        const assignedTo = item.assignedTo || 'family'; // Default to family if not assigned
        return selectedAvatarFilters.includes(assignedTo);
      });
    }

    function editTodoHistoryAssignment(id) {
      const item = todoHistory.find(item => item.id === id);
      if (!item) return;
      
      // Create a simple modal for assignment selection
      const modal = document.createElement('div');
      modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
      `;
      
      const dialog = document.createElement('div');
      dialog.style.cssText = `
        background: var(--bg-primary);
        padding: 24px;
        border-radius: 12px;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
        max-width: 300px;
        width: 90%;
        border: 1px solid var(--border-color);
      `;
      
      dialog.innerHTML = `
        <h3 style="margin: 0 0 16px 0; color: var(--text-primary);">Change Assignment</h3>
        <div style="display: flex; flex-direction: column; gap: 8px; margin-bottom: 16px;">
          <button onclick="updateHistoryAssignment(${id}, 'emley')" style="padding: 12px; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-secondary); color: var(--text-primary); cursor: pointer; text-align: left; display: flex; align-items: center; gap: 8px;">
            <span class="person-avatar emley" style="width: 16px; height: 16px; font-size: 10px;">E</span>
            Emley
          </button>
          <button onclick="updateHistoryAssignment(${id}, 'nate')" style="padding: 12px; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-secondary); color: var(--text-primary); cursor: pointer; text-align: left; display: flex; align-items: center; gap: 8px;">
            <span class="person-avatar nate" style="width: 16px; height: 16px; font-size: 10px;">N</span>
            Nate
          </button>
          <button onclick="updateHistoryAssignment(${id}, 'family')" style="padding: 12px; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-secondary); color: var(--text-primary); cursor: pointer; text-align: left; display: flex; align-items: center; gap: 8px;">
            <span class="person-avatar family" style="width: 16px; height: 16px; font-size: 10px;">F</span>
            Family
          </button>
        </div>
        <div style="display: flex; justify-content: flex-end;">
          <button onclick="closeAssignmentModal()" style="padding: 8px 16px; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-secondary); color: var(--text-primary); cursor: pointer;">Cancel</button>
        </div>
      `;
      
      modal.appendChild(dialog);
      document.body.appendChild(modal);
      
      // Store modal reference for closing
      window.currentAssignmentModal = modal;
      
      // Close on background click
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          closeAssignmentModal();
        }
      });
    }
    
    function updateHistoryAssignment(id, newAssignment) {
      const item = todoHistory.find(item => item.id === id);
      if (item) {
        item.assignedTo = newAssignment || 'family'; // Default to family if somehow empty
        saveTodoHistory();
        
        // Render the appropriate view
        if (document.getElementById('fullscreen-container')) {
          renderTodoListFullscreen();
        } else {
          renderTodoList();
        }
      }
      closeAssignmentModal();
    }

    function sortTodosByDueDate() {
      // Sort todos: overdue (most overdue first) → today → tomorrow → future (closest first) → no dates (A-Z)
      todoItems.sort((a, b) => {
        const aHasDueDate = a.dueDate && a.dueDate.trim() !== '';
        const bHasDueDate = b.dueDate && b.dueDate.trim() !== '';
        
        // If both have due dates, sort by priority: overdue → today → tomorrow → future
        if (aHasDueDate && bHasDueDate) {
          const aDate = new Date(a.dueDate);
          const bDate = new Date(b.dueDate);
          const today = new Date();
          today.setHours(0, 0, 0, 0);
          
          const aIsOverdue = isTaskOverdue(a.dueDate);
          const bIsOverdue = isTaskOverdue(b.dueDate);
          const aIsToday = isTaskDueToday(a.dueDate);
          const bIsToday = isTaskDueToday(b.dueDate);
          const aIsTomorrow = isTaskDueTomorrow(a.dueDate);
          const bIsTomorrow = isTaskDueTomorrow(b.dueDate);
          
          // Both overdue - most overdue first (earliest date first)
          if (aIsOverdue && bIsOverdue) {
            return aDate - bDate;
          }
          
          // One overdue, one not - overdue comes first
          if (aIsOverdue && !bIsOverdue) return -1;
          if (!aIsOverdue && bIsOverdue) return 1;
          
          // Both due today - sort by date (shouldn't matter much, but consistent)
          if (aIsToday && bIsToday) {
            return aDate - bDate;
          }
          
          // One today, one not overdue - today comes first
          if (aIsToday && !bIsOverdue) return -1;
          if (bIsToday && !aIsOverdue) return 1;
          
          // Both due tomorrow - sort by date
          if (aIsTomorrow && bIsTomorrow) {
            return aDate - bDate;
          }
          
          // One tomorrow, one future - tomorrow comes first
          if (aIsTomorrow && !bIsOverdue && !bIsToday) return -1;
          if (bIsTomorrow && !aIsOverdue && !aIsToday) return 1;
          
          // Both future dates - closest first
          return aDate - bDate;
        }
        
        // If only one has a due date, prioritize the one with due date
        if (aHasDueDate && !bHasDueDate) return -1;
        if (!aHasDueDate && bHasDueDate) return 1;
        
        // If neither has a due date, sort alphabetically A-Z
        return a.text.toLowerCase().localeCompare(b.text.toLowerCase());
      });
      
      // Update order properties to reflect new sorting
      // Higher order values appear first in the list
      todoItems.forEach((item, index) => {
        item.order = Date.now() + (todoItems.length - index);
      });
      
      saveTodoItems();
      
      // Render the appropriate view (widget or fullscreen)
      if (document.getElementById('fullscreen-container')) {
        renderTodoListFullscreen();
      } else {
        renderTodoList();
      }
    }

    function editTodoDueDate(id) {
      const item = todoItems.find(item => item.id === id);
      if (item) {
        // Create a simple inline date picker
        const currentDate = item.dueDate || '';
        const newDate = prompt('Edit due date (YYYY-MM-DD format, or leave empty to remove):', currentDate);
        
        if (newDate !== null) {
          // Validate date format if not empty
          if (newDate === '' || /^\d{4}-\d{2}-\d{2}$/.test(newDate)) {
            item.dueDate = newDate || null;
            saveTodoItems();
            
            // Render the appropriate view (widget or fullscreen)
            if (document.getElementById('fullscreen-container')) {
              renderTodoListFullscreen();
            } else {
              renderTodoList();
            }
          } else {
            alert('Please enter a valid date in YYYY-MM-DD format (e.g., 2025-10-14) or leave empty to remove the due date.');
          }
        }
      }
    }

    function saveTodoHistory() {
      saveAllData();
    }

    function showTodoHistory() {
      showingTodoHistory = !showingTodoHistory;
      const historyButton = document.querySelector('.todo-widget .history-button');
      const headerTitle = document.querySelector('.todo-widget h2');
      const calendarButton = document.querySelector('.todo-widget .calendar-button');
      
      if (showingTodoHistory) {
        historyButton.textContent = 'Current';
        headerTitle.textContent = 'To-Do History';
        if (calendarButton) {
          calendarButton.onclick = () => showFullscreenTodoCalendar(); // fullscreen view always
        }
        
        // Update header onclick to open fullscreen history
        headerTitle.onclick = () => {
          showingTodoHistory = true;
          openFullscreen('todo');
        };
        
        // Replace add container with search interface
        const addContainer = document.getElementById('todo-add-container');
        const secondContainer = document.getElementById('todo-secondary-container');
        if (secondContainer) {
          secondContainer.style.display = 'none';
        }
        addContainer.innerHTML = `
          <div style="display: flex; flex-direction: column; gap: 0.8rem; margin-bottom: 2rem;">
            <div style="display: flex; gap: 0.5rem; align-items: center;">
              <input type="text" id="todo-search-input" placeholder="Search tasks..." maxlength="100" style="flex: 1;">
              <button onclick="clearTodoSearch()" title="Clear search" style="padding: 0.5rem; font-size: 0.9rem;">✕</button>
            </div>
            <div style="display: flex; gap: 0.5rem; font-size: 0.9rem;">
              <label style="font-weight: 500; color: var(--text-secondary); white-space: nowrap;">Date range:</label>
              <input type="date" id="todo-date-from" style="flex: 1; font-size: 0.85rem;" title="From date">
              <span style="color: var(--text-secondary); align-self: center;">to</span>
              <input type="date" id="todo-date-to" style="flex: 1; font-size: 0.85rem;" title="To date">
            </div>
            <div style="display: flex; justify-content: center; align-items: center; gap: 8px; margin-top: 0.5rem; margin-bottom: 1rem;">
              <span class="avatar-filter emley" data-avatar="emley" onclick="toggleAvatarFilter('emley')" title="Filter by Emley">E</span>
              <span class="avatar-filter nate" data-avatar="nate" onclick="toggleAvatarFilter('nate')" title="Filter by Nate">N</span>
              <span class="avatar-filter family" data-avatar="family" onclick="toggleAvatarFilter('family')" title="Filter by Family">F</span>
            </div>
          </div>
        `;
        
        // Add search functionality
        setTimeout(() => {
          const searchInput = document.getElementById('todo-search-input');
          const dateFromInput = document.getElementById('todo-date-from');
          const dateToInput = document.getElementById('todo-date-to');
          
          if (searchInput) {
            searchInput.addEventListener('input', filterTodoHistory);
          }
          if (dateFromInput) {
            dateFromInput.addEventListener('change', filterTodoHistory);
          }
          if (dateToInput) {
            dateToInput.addEventListener('change', filterTodoHistory);
          }
        }, 100);
      } else {
        historyButton.textContent = 'History';
        headerTitle.textContent = 'To-Do List';
        if (calendarButton) {
          calendarButton.onclick = () => showFullscreenTodoCalendar(); // fullscreen view always
        }
        
        // Restore original header onclick behavior
        headerTitle.onclick = () => openFullscreen('todo');
        
        // Restore original add container
        const addContainer = document.getElementById('todo-add-container');
        addContainer.innerHTML = `
          <input type="text" id="todo-input" placeholder="Add new task..." maxlength="100">
          <button onclick="addTodoItem()" id="add-todo-btn">Add</button>
        `;
        
        // Restore the second container for assignment and date
        const secondContainer = document.getElementById('todo-secondary-container');
        if (secondContainer) {
          secondContainer.innerHTML = `
            <input type="date" id="todo-due-date" title="Due date (optional)">
            <div class="avatar-filters-container">
              <span class="avatar-filter emley" data-avatar="emley" onclick="toggleAvatarFilter('emley')" title="Filter by Emley">E</span>
              <span class="avatar-filter nate" data-avatar="nate" onclick="toggleAvatarFilter('nate')" title="Filter by Nate">N</span>
              <span class="avatar-filter family" data-avatar="family" onclick="toggleAvatarFilter('family')" title="Filter by Family">F</span>
            </div>
          `;
          secondContainer.style.display = 'flex';
        }
        addContainer.style.display = 'flex';
        
        // Re-add Enter key support
        document.getElementById('todo-input').addEventListener('keypress', function(e) {
          if (e.key === 'Enter') {
            addTodoItem();
          }
        });
      }
      
      renderTodoList();
    }

    function groupTodosByDate(todos) {
      const groups = {};
      
      todos.forEach(item => {
        const date = new Date(item.completedAt);
        const dateKey = date.toLocaleDateString('en-US', { 
          weekday: 'long', 
          year: 'numeric', 
          month: 'long', 
          day: 'numeric' 
        });
        
        if (!groups[dateKey]) {
          groups[dateKey] = [];
        }
        groups[dateKey].push(item);
      });
      
      return groups;
    }

    function renderTodoHistoryGrouped(groups) {
      let html = '';
      
      // Sort dates (most recent first)
      const sortedDates = Object.keys(groups).sort((a, b) => {
        const dateA = new Date(groups[a][0].completedAt);
        const dateB = new Date(groups[b][0].completedAt);
        return dateB - dateA;
      });
      
      sortedDates.forEach(dateKey => {
        html += `<li class="date-header">${dateKey}</li>`;
        
        // Sort items within each date group by order
        const sortedItems = sortItemsByOrder([...groups[dateKey]]);
        
        sortedItems.forEach(item => {
          const assignedTo = item.assignedTo || 'family'; // Default to family if not assigned
          const avatarHtml = `<span class="person-avatar ${assignedTo}" onclick="editTodoHistoryAssignment(${item.id})" title="Click to change assignment - Currently: ${assignedTo === 'emley' ? 'Emley' : assignedTo === 'nate' ? 'Nate' : 'Family'}" style="cursor: pointer;">${assignedTo === 'emley' ? 'E' : assignedTo === 'nate' ? 'N' : 'F'}</span>`;
          
          html += `
            <li class="task-item history-item" data-date-group="${dateKey}" data-item-id="${item.id}">
              <span class="drag-handle">☰</span>
              ${avatarHtml}
              <span class="task-text">${escapeHtml(item.text)}</span>
              <div class="task-actions">
                <button class="edit-btn" onclick="reAddTodoFromHistory(${item.id})" title="Add back to current list">↩️</button>
                <button class="delete-btn" onclick="deleteTodoHistoryItem(${item.id})" title="Delete">🗑️</button>
              </div>
            </li>
          `;
        });
      });
      
      return html;
    }

    function deleteTodoHistoryItem(id) {
      todoHistory = todoHistory.filter(item => item.id !== id);
      saveTodoHistory();
      
      // Render the appropriate view (widget or fullscreen)
      if (document.getElementById('fullscreen-container')) {
        renderTodoListFullscreen();
      } else {
      renderTodoList();
      }
    }

    function reAddTodoFromHistory(historyId) {
      // Find the item in history
      const historyItem = todoHistory.find(item => item.id === historyId);
      if (!historyItem) return;
      
      // Create new todo item with a new ID and the original text
      const newTodoId = Date.now();
      const newTodoItem = {
        id: newTodoId,
        text: historyItem.text,
        completed: false,
        originalHistoryId: historyId, // Track which history item this came from
        dueDate: historyItem.dueDate // Restore due date from history
      };
      
      // Add to current todo list
      todoItems.unshift(newTodoItem);
      
      // Remove from history immediately
      todoHistory = todoHistory.filter(item => item.id !== historyId);
      
      saveTodoItems();
      saveTodoHistory();
      
      // Render the appropriate view (widget or fullscreen)
      if (document.getElementById('fullscreen-container')) {
        renderTodoListFullscreen();
      } else {
      renderTodoList();
      }
      
      console.log(`Re-added "${historyItem.text}" to current todo list and removed from history`);
    }

    // Todo search functionality
    let currentTodoSearchTerm = '';
    let currentDateFrom = '';
    let currentDateTo = '';

    function filterTodoHistory() {
      const searchInput = document.getElementById('todo-search-input');
      const dateFromInput = document.getElementById('todo-date-from');
      const dateToInput = document.getElementById('todo-date-to');
      
      currentTodoSearchTerm = searchInput ? searchInput.value.toLowerCase().trim() : '';
      currentDateFrom = dateFromInput ? dateFromInput.value : '';
      currentDateTo = dateToInput ? dateToInput.value : '';
      
      renderTodoList();
    }

    function clearTodoSearch() {
      const searchInput = document.getElementById('todo-search-input');
      const dateFromInput = document.getElementById('todo-date-from');
      const dateToInput = document.getElementById('todo-date-to');
      
      if (searchInput) searchInput.value = '';
      if (dateFromInput) dateFromInput.value = '';
      if (dateToInput) dateToInput.value = '';
      
      currentTodoSearchTerm = '';
      currentDateFrom = '';
      currentDateTo = '';
      
      // Clear avatar filters
      selectedAvatarFilters = [];
      updateAvatarFilterButtons();
      
      renderTodoList();
    }

    function fuzzySearchTodos(items, searchTerm) {
      if (!searchTerm) return items;
      
      return items.filter(item => {
        const text = item.text.toLowerCase();
        
        // Exact match gets highest priority
        if (text.includes(searchTerm)) {
          return true;
        }
        
        // Fuzzy matching - check if all characters of search term appear in order
        let searchIndex = 0;
        for (let i = 0; i < text.length && searchIndex < searchTerm.length; i++) {
          if (text[i] === searchTerm[searchIndex]) {
            searchIndex++;
          }
        }
        
        return searchIndex === searchTerm.length;
      });
    }

    function filterTodosByDateRange(items, fromDate, toDate) {
      if (!fromDate && !toDate) return items;
      
      return items.filter(item => {
        const itemDate = new Date(item.completedAt);
        const itemDateString = itemDate.toISOString().split('T')[0];
        
        if (fromDate && itemDateString < fromDate) return false;
        if (toDate && itemDateString > toDate) return false;
        
        return true;
      });
    }

    // Grocery categorization system
    const groceryCategories = {
      'Produce': {
        keywords: ['apple', 'banana', 'orange', 'lemon', 'lime', 'grape', 'berry', 'strawberry', 'blueberry', 'raspberry', 'blackberry', 'cherry', 'peach', 'pear', 'plum', 'mango', 'pineapple', 'kiwi', 'avocado', 'tomato', 'cucumber', 'lettuce', 'spinach', 'kale', 'arugula', 'cabbage', 'broccoli', 'cauliflower', 'carrot', 'celery', 'onion', 'garlic', 'ginger', 'potato', 'sweet potato', 'bell pepper', 'jalapeño', 'mushroom', 'zucchini', 'squash', 'eggplant', 'corn', 'peas', 'green beans', 'asparagus', 'herbs', 'basil', 'cilantro', 'parsley', 'thyme', 'rosemary', 'oregano', 'dill', 'mint', 'salad', 'greens', 'radish', 'turnip', 'beet', 'leek', 'scallion', 'green onion', 'chives']
      },
      'Bakery': {
        keywords: ['bread', 'baguette', 'roll', 'bagel', 'croissant', 'muffin', 'donut', 'cake', 'cookie', 'pastry', 'pie', 'tart', 'danish', 'scone', 'biscuit', 'pretzel', 'loaf', 'sourdough', 'whole wheat', 'rye bread', 'pita', 'naan', 'tortilla', 'wrap']
      },
      'Deli': {
        keywords: ['deli meat', 'ham', 'turkey', 'salami', 'prosciutto', 'pastrami', 'roast beef', 'bologna', 'pepperoni', 'deli cheese', 'sliced cheese', 'sandwich', 'prepared salad', 'potato salad', 'coleslaw', 'hummus', 'olives', 'pickles']
      },
      'Meat & Seafood': {
        keywords: ['chicken', 'beef', 'pork', 'lamb', 'turkey', 'duck', 'steak', 'ground beef', 'ground turkey', 'chicken breast', 'chicken thigh', 'pork chop', 'bacon', 'sausage', 'fish', 'salmon', 'tuna', 'cod', 'tilapia', 'shrimp', 'crab', 'lobster', 'scallops', 'mussels', 'clams', 'oysters', 'meat', 'poultry', 'seafood']
      },
      'Dairy': {
        keywords: ['milk', 'yogurt', 'cheese', 'butter', 'eggs', 'cream', 'sour cream', 'cottage cheese', 'cream cheese', 'mozzarella', 'cheddar', 'swiss', 'parmesan', 'feta', 'goat cheese', 'ricotta', 'half and half', 'heavy cream', 'whipping cream', 'buttermilk', 'kefir']
      },
      'Canned & Packaged Goods': {
        keywords: ['canned', 'can of', 'soup', 'broth', 'stock', 'beans', 'chickpeas', 'lentils', 'tomatoes', 'tomato sauce', 'pasta sauce', 'marinara', 'salsa', 'diced tomatoes', 'tomato paste', 'coconut milk', 'canned fruit', 'canned vegetables', 'corn', 'green beans', 'peas', 'carrots', 'jar', 'bottle', 'packaged', 'boxed']
      },
      'Spices': {
        keywords: ['spices', 'seasoning', 'dried herbs', 'cinnamon', 'paprika', 'cumin', 'chili powder', 'garlic powder', 'onion powder', 'turmeric', 'garam masala', 'coriander', 'cardamom', 'black pepper', 'white pepper', 'cayenne', 'nutmeg', 'cloves', 'allspice', 'bay leaves', 'curry powder', 'italian seasoning', 'mustard seed', 'celery seed', 'fennel', 'star anise', 'saffron', 'vanilla bean', 'ground', 'dried']
      },
      'Dry Goods & Baking': {
        keywords: ['flour', 'sugar', 'brown sugar', 'powdered sugar', 'baking powder', 'baking soda', 'vanilla', 'extract', 'oil', 'olive oil', 'vegetable oil', 'coconut oil', 'vinegar', 'salt', 'baking mix', 'pancake mix', 'cake mix', 'cornstarch', 'cocoa powder', 'chocolate chips', 'nuts', 'almonds', 'walnuts', 'pecans', 'peanuts']
      },
      'Snacks & Candy': {
        keywords: ['chips', 'crackers', 'pretzels', 'popcorn', 'nuts', 'trail mix', 'granola bar', 'energy bar', 'protein bar', 'candy', 'chocolate', 'gum', 'mints', 'cookies', 'snacks', 'goldfish', 'cheez-its', 'oreos', 'graham crackers']
      },
      'Cereal & Breakfast': {
        keywords: ['cereal', 'oatmeal', 'granola', 'muesli', 'pancake mix', 'waffle mix', 'syrup', 'maple syrup', 'honey', 'jam', 'jelly', 'peanut butter', 'almond butter', 'nutella', 'breakfast', 'oats', 'quinoa flakes']
      },
      'Pasta, Rice & International Foods': {
        keywords: ['pasta', 'spaghetti', 'penne', 'fusilli', 'linguine', 'fettuccine', 'macaroni', 'lasagna', 'ravioli', 'rice', 'brown rice', 'white rice', 'jasmine rice', 'basmati rice', 'wild rice', 'quinoa', 'couscous', 'noodles', 'ramen', 'udon', 'soba', 'rice noodles', 'pad thai', 'curry', 'soy sauce', 'teriyaki', 'sriracha', 'hot sauce', 'salsa', 'tahini', 'miso', 'kimchi', 'international', 'ethnic']
      },
      'Frozen Foods': {
        keywords: ['frozen', 'ice cream', 'frozen yogurt', 'sorbet', 'frozen fruit', 'frozen vegetables', 'frozen dinner', 'frozen pizza', 'frozen burrito', 'frozen meal', 'frozen chicken', 'frozen fish', 'frozen shrimp', 'frozen berries', 'frozen peas', 'frozen corn', 'frozen broccoli', 'frozen spinach', 'popsicle', 'ice', 'frozen bread', 'frozen pastry']
      },
      'Beverages': {
        keywords: ['water', 'sparkling water', 'juice', 'orange juice', 'apple juice', 'cranberry juice', 'soda', 'cola', 'pepsi', 'coke', 'sprite', 'coffee', 'green tea', 'black tea', 'herbal tea', 'energy drink', 'sports drink', 'beer', 'wine', 'alcohol', 'vodka', 'whiskey', 'rum', 'gin', 'champagne', 'kombucha', 'smoothie', 'protein shake', 'almond milk', 'oat milk', 'soy milk', 'coconut milk', 'rice milk']
      },
      'Health & Beauty': {
        keywords: ['shampoo', 'conditioner', 'soap', 'body wash', 'lotion', 'moisturizer', 'sunscreen', 'toothpaste', 'toothbrush', 'mouthwash', 'deodorant', 'perfume', 'cologne', 'makeup', 'lipstick', 'mascara', 'foundation', 'vitamins', 'supplements', 'medicine', 'advil', 'tylenol', 'aspirin', 'bandaids', 'first aid', 'contact solution', 'razor', 'shaving cream']
      },
      'Cleaning & Household': {
        keywords: ['laundry detergent', 'fabric softener', 'bleach', 'dish soap', 'dishwasher detergent', 'all-purpose cleaner', 'glass cleaner', 'bathroom cleaner', 'toilet paper', 'paper towels', 'napkins', 'tissues', 'trash bags', 'garbage bags', 'aluminum foil', 'plastic wrap', 'parchment paper', 'wax paper', 'sponges', 'scrubber', 'cleaning supplies', 'vacuum bags', 'air freshener', 'candles', 'light bulbs', 'batteries']
      },
      'Pet Supplies': {
        keywords: ['dog food', 'cat food', 'pet food', 'dog treats', 'cat treats', 'pet treats', 'cat litter', 'dog toys', 'cat toys', 'pet toys', 'leash', 'collar', 'pet supplies', 'bird food', 'fish food', 'hamster food', 'guinea pig food']
      },
      'Floral Department': {
        keywords: ['flowers', 'bouquet', 'roses', 'tulips', 'daisies', 'carnations', 'lilies', 'plants', 'potted plant', 'succulent', 'orchid', 'floral', 'gift card', 'balloon', 'greeting card']
      },
      'Pharmacy': {
        keywords: ['prescription', 'medication', 'pharmacy', 'pills', 'capsules', 'tablets', 'insulin', 'inhaler', 'antibiotic', 'pain reliever', 'allergy medicine', 'cold medicine', 'cough syrup', 'eye drops', 'ear drops']
      }
    };

    function categorizeGroceryItem(itemText, manualCategory = null) {
      // If manual category is set, use it
      if (manualCategory) {
        return manualCategory;
      }
      
      const text = itemText.toLowerCase();
      
      // Priority rules - check these first before general keyword matching
      
      // 1. Canned/Packaged indicators override everything
      const canPackageIndicators = ['can of', 'canned', 'jar of', 'bottle of', 'packaged', 'boxed', '15-ounce can', '14-ounce can', 'oz can', 'fl oz'];
      if (canPackageIndicators.some(indicator => text.includes(indicator))) {
        return 'Canned & Packaged Goods';
      }
      
      // 2. Jarred/bottled garlic goes to Canned & Packaged Goods
      const jarredGarlicIndicators = [
        'garlic, from a jar', 'ready-minced garlic', 'bottled minced garlic', 
        'prepared garlic', 'jarred garlic', 'minced garlic in jar'
      ];
      const measurementPattern = /\b\d*\s*(teaspoon|tsp|tablespoon|tbsp)\s+minced garlic\b/;
      
      if (jarredGarlicIndicators.some(indicator => text.includes(indicator)) ||
          (text.includes('minced garlic') && 
           (text.includes('teaspoon') || text.includes('tsp') || text.includes('tablespoon') || text.includes('tbsp')) &&
           !text.includes('powder') && !text.includes('clove'))) {
        return 'Canned & Packaged Goods';
      }
      
      // 3. Fresh garlic cloves go to Produce (garlic cloves, fresh garlic, minced garlic cloves, etc.)
      const garlicCloveIndicators = [
        'garlic clove', 'garlic cloves', 'fresh garlic', 'minced garlic cloves', 
        'chopped garlic', 'crushed garlic', 'smashed garlic', 'whole clove garlic', 
        'whole cloves garlic', 'peeled garlic', 'clove garlic', 'cloves garlic'
      ];
      const clovePattern = /\b\d+\s+clove[s]?\b/; // Matches "1 clove", "2 cloves", "3 cloves", etc.
      
      if (garlicCloveIndicators.some(indicator => text.includes(indicator)) || 
          (text.includes('garlic') && clovePattern.test(text))) {
        return 'Produce';
      }
      
      // 4. Fresh herbs and spices go to Produce (fresh parsley, fresh ginger, etc.)
      const freshHerbKeywords = ['parsley', 'cilantro', 'basil', 'thyme', 'rosemary', 'oregano', 'dill', 'mint', 'sage', 'chives', 'ginger', 'garlic', 'onion'];
      if (text.includes('fresh') && freshHerbKeywords.some(herb => text.includes(herb))) {
        return 'Produce';
      }
      
      // 5. Spice measurements indicate Spices (but not fresh ones)
      const spiceMeasurements = ['teaspoon', 'tsp', 'tablespoon', 'tbsp', 'pinch of', 'dash of', 'ground ', 'dried '];
      const spiceKeywords = ['turmeric', 'garam masala', 'cumin', 'coriander', 'cardamom', 'cinnamon', 'paprika', 'chili powder', 'curry powder', 'oregano', 'basil', 'thyme', 'rosemary', 'sage', 'parsley', 'cilantro', 'dill', 'mint', 'garlic powder', 'onion powder', 'black pepper', 'white pepper', 'cayenne', 'nutmeg', 'cloves', 'allspice', 'bay leaves'];
      
      if ((spiceMeasurements.some(measurement => text.includes(measurement)) || 
          (spiceKeywords.some(spice => text.includes(spice)) && 
           (text.includes('ground') || text.includes('dried') || text.includes('powder') || text.includes('teaspoon') || text.includes('tablespoon')))) &&
          !text.includes('fresh')) {
        return 'Spices';
      }
      
      // 6. Frozen indicators
      if (text.includes('frozen')) {
        return 'Frozen Foods';
      }
      
      // 7. Fresh meat indicators
      const meatPreparations = ['boneless', 'skinless', 'ground', 'chopped', 'diced', 'sliced', 'whole', 'fresh'];
      const meatTypes = ['chicken', 'beef', 'pork', 'lamb', 'turkey', 'duck', 'fish', 'salmon', 'tuna'];
      if (meatTypes.some(meat => text.includes(meat)) && 
          (meatPreparations.some(prep => text.includes(prep)) || text.includes('lb') || text.includes('pound'))) {
        return 'Meat & Seafood';
      }
      
      // 8. Dairy with measurements
      if ((text.includes('cup') || text.includes('oz') || text.includes('pint') || text.includes('quart') || text.includes('gallon')) &&
          (text.includes('milk') || text.includes('cream') || text.includes('yogurt') || text.includes('butter'))) {
        return 'Dairy';
      }
      
      // 9. Baking measurements
      const bakingMeasurements = ['cup', 'cups', 'lb', 'pound', 'ounce', 'oz'];
      const bakingIngredients = ['flour', 'sugar', 'brown sugar', 'powdered sugar', 'baking powder', 'baking soda', 'vanilla extract', 'oil'];
      if (bakingMeasurements.some(measurement => text.includes(measurement)) &&
          bakingIngredients.some(ingredient => text.includes(ingredient))) {
        return 'Dry Goods & Baking';
      }
      
      // Now do general keyword matching for remaining items
      for (const [category, data] of Object.entries(groceryCategories)) {
        for (const keyword of data.keywords) {
          if (text.includes(keyword)) {
            return category;
          }
        }
      }
      
      return 'Other'; // Default category for items that don't match
    }

    function groupGroceriesByCategory(items) {
      const grouped = {};
      
      items.forEach(item => {
        const category = categorizeGroceryItem(item.text, item.manualCategory);
        if (!grouped[category]) {
          grouped[category] = [];
        }
        grouped[category].push(item);
      });
      
      return grouped;
    }

    // Function to handle dropping grocery items into different categories
    function handleGroceryCategoryDrop(draggedItemId, targetCategory) {
      const item = groceryItems.find(item => item.id === draggedItemId);
      if (item && targetCategory) {
        item.manualCategory = targetCategory;
        saveGroceryItems();
        renderGroceryList();
        
        // Also update fullscreen view if it's open
        if (document.getElementById('fullscreen-grocery-list')) {
          renderGroceryListFullscreen();
        }
      }
    }

    // Enhanced drag-and-drop for categorized grocery lists
    let groceryDraggedItem = null;
    let groceryDraggedCategory = null;
    let groceryDraggedIndex = null;

    function setupGroceryDragAndDrop(listElement) {
      const listItems = listElement.querySelectorAll('.task-item');
      const categoryHeaders = listElement.querySelectorAll('.category-header');
      
      // Set up drag handles for grocery items
      listItems.forEach((item, globalIndex) => {
        const dragHandle = item.querySelector('.drag-handle');
        if (dragHandle) {
          dragHandle.title = 'Drag to reorder or move to different category';
          dragHandle.draggable = true;
          
          // Clear any existing event listeners by cloning the element
          const newDragHandle = dragHandle.cloneNode(true);
          dragHandle.parentNode.replaceChild(newDragHandle, dragHandle);
          const handle = newDragHandle;
          
          handle.addEventListener('dragstart', (e) => {
            const itemId = parseFloat(item.getAttribute('data-item-id'));
            
            if (itemId) {
              groceryDraggedItem = groceryItems.find(item => item.id === itemId);
              groceryDraggedCategory = categorizeGroceryItem(groceryDraggedItem.text, groceryDraggedItem.manualCategory);
              
              // Find index within the category
              const categoryItems = groceryItems.filter(item => 
                categorizeGroceryItem(item.text, item.manualCategory) === groceryDraggedCategory
              );
              groceryDraggedIndex = categoryItems.findIndex(item => item.id === itemId);
              
              item.classList.add('dragging');
              item.style.opacity = '0.5';
              e.dataTransfer.effectAllowed = 'move';
              e.dataTransfer.setData('text/plain', itemId.toString());
            }
          });
          
          handle.addEventListener('dragend', (e) => {
            item.classList.remove('dragging');
            item.style.opacity = '1';
            groceryDraggedItem = null;
            groceryDraggedCategory = null;
            groceryDraggedIndex = null;
            
            // Remove all drop indicators
            clearGroceryDropIndicators(listElement);
          });
        }
        
        // Make sure only drag handle is draggable
        item.draggable = false;
        
        // Set up drop zones for reordering within categories
        item.addEventListener('dragenter', (e) => {
          e.preventDefault();
          if (groceryDraggedItem && groceryDraggedItem.id !== parseFloat(item.getAttribute('data-item-id'))) {
            updateGroceryDropIndicator(e, item, listElement);
          }
        });
        
        item.addEventListener('dragover', (e) => {
          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';
          if (groceryDraggedItem && groceryDraggedItem.id !== parseFloat(item.getAttribute('data-item-id'))) {
            updateGroceryDropIndicator(e, item, listElement);
          }
        });
        
        item.addEventListener('dragleave', (e) => {
          if (!item.contains(e.relatedTarget)) {
            clearGroceryDropIndicators(listElement);
          }
        });
        
        item.addEventListener('drop', (e) => {
          e.preventDefault();
          clearGroceryDropIndicators(listElement);
          
          if (groceryDraggedItem) {
            const targetItemId = parseFloat(item.getAttribute('data-item-id'));
            const targetItem = groceryItems.find(item => item.id === targetItemId);
            
            if (targetItem && targetItem.id !== groceryDraggedItem.id) {
              const targetCategory = categorizeGroceryItem(targetItem.text, targetItem.manualCategory);
              
              // Check if we're dropping within the same category (reorder) or different category (move)
              if (targetCategory === groceryDraggedCategory) {
                // Reorder within same category
                reorderGroceryItemsWithinCategory(groceryDraggedItem, targetItem, targetCategory);
              } else {
                // Move to different category - set manual category and place at end
                groceryDraggedItem.manualCategory = targetCategory;
              }
              
              saveGroceryItems();
              
              // Re-render appropriate view
              if (document.getElementById('fullscreen-grocery-list')) {
                renderGroceryListFullscreen();
              } else {
                renderGroceryList();
              }
            }
          }
        });
      });
      
      // Set up category headers as drop zones (remove inline events, use proper listeners)
      categoryHeaders.forEach(header => {
        header.addEventListener('dragover', (e) => {
          e.preventDefault();
          header.style.background = '#e3f2fd';
        });
        
        header.addEventListener('dragleave', (e) => {
          header.style.background = '#f8f9fa';
        });
        
        header.addEventListener('drop', (e) => {
          e.preventDefault();
          header.style.background = '#f8f9fa';
          
          if (groceryDraggedItem) {
            const targetCategory = header.getAttribute('data-category');
            if (targetCategory && targetCategory !== groceryDraggedCategory) {
              groceryDraggedItem.manualCategory = targetCategory;
              saveGroceryItems();
              
              // Re-render appropriate view
              if (document.getElementById('fullscreen-grocery-list')) {
                renderGroceryListFullscreen();
              } else {
                renderGroceryList();
              }
            }
          }
        });
      });
    }

    function updateGroceryDropIndicator(event, targetItem, listElement) {
      clearGroceryDropIndicators(listElement);
      
      if (!groceryDraggedItem) return;
      
      const rect = targetItem.getBoundingClientRect();
      const mouseY = event.clientY;
      const itemMiddle = rect.top + rect.height / 2;
      
      if (mouseY < itemMiddle) {
        targetItem.classList.add('drop-target-above');
      } else {
        targetItem.classList.add('drop-target-below');
      }
    }

    function clearGroceryDropIndicators(listElement) {
      const listItems = listElement.querySelectorAll('.task-item');
      listItems.forEach(item => {
        item.classList.remove('drop-target-above', 'drop-target-below');
      });
    }

    function reorderGroceryItemsWithinCategory(draggedItem, targetItem, category) {
      // Get all items in this category (references to actual items, not copies)
      const categoryItems = groceryItems.filter(item => 
        categorizeGroceryItem(item.text, item.manualCategory) === category
      );
      
      // Find current positions
      const draggedIndex = categoryItems.findIndex(item => item.id === draggedItem.id);
      const targetIndex = categoryItems.findIndex(item => item.id === targetItem.id);
      
      if (draggedIndex !== -1 && targetIndex !== -1 && draggedIndex !== targetIndex) {
        // Determine if we're moving up or down
        const isMovingDown = draggedIndex < targetIndex;
        
        // Calculate new order value based on target position
        let newOrder;
        if (targetIndex === 0) {
          // Moving to first position
          newOrder = (categoryItems[0].order || 0) + 1;
        } else if (targetIndex === categoryItems.length - 1) {
          // Moving to last position
          newOrder = (categoryItems[categoryItems.length - 1].order || 0) - 1;
        } else {
          // Moving to middle position - place between target and next item
          const targetOrder = categoryItems[targetIndex].order || 0;
          const nextIndex = isMovingDown ? targetIndex + 1 : targetIndex - 1;
          const nextOrder = categoryItems[nextIndex].order || 0;
          newOrder = (targetOrder + nextOrder) / 2;
        }
        
        // Update the dragged item's order
        draggedItem.order = newOrder;
        
        // If orders get too close together, renumber the entire category
        const minOrderDiff = 0.001;
        const needsRenumbering = categoryItems.some((item, index) => {
          if (index === 0) return false;
          const prevOrder = categoryItems[index - 1].order || 0;
          const currOrder = item.order || 0;
          return Math.abs(prevOrder - currOrder) < minOrderDiff;
        });
        
        if (needsRenumbering) {
          // Sort items by order and renumber
          categoryItems.sort((a, b) => (b.order || 0) - (a.order || 0));
          const baseOrder = Date.now();
          categoryItems.forEach((item, index) => {
            item.order = baseOrder - index;
          });
        }
      }
    }

    // Grocery List Functions
    function addGroceryItem() {
      const input = document.getElementById('grocery-input');
      const text = input.value.trim();
      
      if (text) {
        const item = {
          id: Date.now(),
          text: text,
          completed: false,
          createdAt: new Date().toISOString(),
          order: Date.now() // Add order property for sorting
        };
        
        groceryItems.unshift(item); // Add to beginning of array
        updateItemOrders(groceryItems); // Update all orders
        saveGroceryItems();
        renderGroceryList();
        input.value = '';
      }
    }

    function toggleGroceryItem(id) {
      const item = groceryItems.find(item => item.id === id);
      if (item) {
        item.completed = !item.completed;
        if (item.completed) {
          item.completedAt = new Date().toISOString();
        } else {
          delete item.completedAt;
        }
        saveGroceryItems();
        renderGroceryList();
      }
    }

    function deleteGroceryItem(id) {
      groceryItems = groceryItems.filter(item => item.id !== id);
      saveGroceryItems();
      renderGroceryList();
    }

    function editGroceryItem(id) {
      const item = groceryItems.find(item => item.id === id);
      if (!item) return;

      // Create modal
      const modal = document.createElement('div');
      modal.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
        background: rgba(0,0,0,0.5); display: flex; align-items: center; 
        justify-content: center; z-index: 1000;
      `;

      const dialog = document.createElement('div');
      dialog.style.cssText = `
        background: white; padding: 24px; border-radius: 12px; 
        max-width: 400px; width: 90%; 
        box-shadow: 0 10px 25px rgba(0,0,0,0.2);
      `;

      dialog.innerHTML = `
        <h3 style="margin: 0 0 20px 0; color: #333;">Edit Grocery Item</h3>
        
        <div style="margin-bottom: 16px;">
          <label style="display: block; margin-bottom: 8px; font-weight: 500; color: #555;">Item:</label>
          <input type="text" id="edit-grocery-text" value="${escapeHtml(item.text)}" 
                 style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 6px; 
                        font-size: 14px; box-sizing: border-box;">
        </div>

        <div style="margin-bottom: 16px;">
          <label style="display: block; margin-bottom: 8px; font-weight: 500; color: #555;">Recipe Source:</label>
          <input type="text" id="edit-grocery-source" value="${escapeHtml(item.recipeSource || '')}" 
                 placeholder="e.g., Butter Chicken, Pasta Recipe..." 
                 style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 6px; 
                        font-size: 14px; box-sizing: border-box;">
        </div>

        <div style="margin-bottom: 16px;">
          <label style="display: block; margin-bottom: 8px; font-weight: 500; color: #555;">Category:</label>
          <select id="edit-grocery-category" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 6px; 
                         font-size: 14px; box-sizing: border-box; background: white;">
            <option value="">Auto-categorize</option>
            <option value="Produce" ${item.manualCategory === 'Produce' ? 'selected' : ''}>Produce</option>
            <option value="Bakery" ${item.manualCategory === 'Bakery' ? 'selected' : ''}>Bakery</option>
            <option value="Deli" ${item.manualCategory === 'Deli' ? 'selected' : ''}>Deli</option>
            <option value="Meat & Seafood" ${item.manualCategory === 'Meat & Seafood' ? 'selected' : ''}>Meat & Seafood</option>
            <option value="Dairy" ${item.manualCategory === 'Dairy' ? 'selected' : ''}>Dairy</option>
            <option value="Canned & Packaged Goods" ${item.manualCategory === 'Canned & Packaged Goods' ? 'selected' : ''}>Canned & Packaged Goods</option>
            <option value="Spices" ${item.manualCategory === 'Spices' ? 'selected' : ''}>Spices</option>
            <option value="Dry Goods & Baking" ${item.manualCategory === 'Dry Goods & Baking' ? 'selected' : ''}>Dry Goods & Baking</option>
            <option value="Snacks & Candy" ${item.manualCategory === 'Snacks & Candy' ? 'selected' : ''}>Snacks & Candy</option>
            <option value="Cereal & Breakfast" ${item.manualCategory === 'Cereal & Breakfast' ? 'selected' : ''}>Cereal & Breakfast</option>
            <option value="Pasta, Rice & International Foods" ${item.manualCategory === 'Pasta, Rice & International Foods' ? 'selected' : ''}>Pasta, Rice & International Foods</option>
            <option value="Frozen Foods" ${item.manualCategory === 'Frozen Foods' ? 'selected' : ''}>Frozen Foods</option>
            <option value="Beverages" ${item.manualCategory === 'Beverages' ? 'selected' : ''}>Beverages</option>
            <option value="Health & Beauty" ${item.manualCategory === 'Health & Beauty' ? 'selected' : ''}>Health & Beauty</option>
            <option value="Cleaning & Household" ${item.manualCategory === 'Cleaning & Household' ? 'selected' : ''}>Cleaning & Household</option>
            <option value="Pet Supplies" ${item.manualCategory === 'Pet Supplies' ? 'selected' : ''}>Pet Supplies</option>
            <option value="Floral Department" ${item.manualCategory === 'Floral Department' ? 'selected' : ''}>Floral Department</option>
            <option value="Pharmacy" ${item.manualCategory === 'Pharmacy' ? 'selected' : ''}>Pharmacy</option>
            <option value="Other" ${item.manualCategory === 'Other' ? 'selected' : ''}>Other</option>
          </select>
        </div>

        <div style="margin-bottom: 20px;">
          <label style="display: flex; align-items: center; gap: 8px; font-weight: 500; color: #555; cursor: pointer;">
            <input type="checkbox" id="edit-grocery-optional" ${item.isOptional ? 'checked' : ''} 
                   style="margin: 0;">
            Mark as optional ingredient
          </label>
        </div>

        <div style="display: flex; gap: 12px; justify-content: flex-end;">
          <button id="grocery-edit-cancel-btn" style="padding: 10px 20px; border: 1px solid #ddd; 
                  border-radius: 6px; background: white; cursor: pointer;">Cancel</button>
          <button id="grocery-edit-save-btn" style="padding: 10px 20px; border: none; border-radius: 6px; 
                  background: var(--primary-color); color: white; cursor: pointer;">Save</button>
        </div>
      `;

      modal.appendChild(dialog);
      document.body.appendChild(modal);

      // Get input elements
      const textInput = document.getElementById('edit-grocery-text');
      const sourceInput = document.getElementById('edit-grocery-source');
      const categorySelect = document.getElementById('edit-grocery-category');
      const optionalCheckbox = document.getElementById('edit-grocery-optional');
      const saveBtn = document.getElementById('grocery-edit-save-btn');
      const cancelBtn = document.getElementById('grocery-edit-cancel-btn');

      // Focus on text input
      textInput.focus();
      textInput.select();

      const handleSave = () => {
        const newText = textInput.value.trim();
        if (!newText) {
          textInput.focus();
          return;
        }

        const newSource = sourceInput.value.trim();
        const newCategory = categorySelect.value || null;
        const isOptional = optionalCheckbox.checked;
        
        // Update item
        item.text = newText;
        item.recipeSource = newSource || null;
        item.manualCategory = newCategory;
        item.isOptional = isOptional;
        
          saveGroceryItems();
          renderGroceryList();
        
        // Also update fullscreen view if it's open
        if (document.getElementById('fullscreen-grocery-list')) {
          renderGroceryListFullscreen();
        }

        document.body.removeChild(modal);
      };

      const handleCancel = () => {
        document.body.removeChild(modal);
      };

      saveBtn.addEventListener('click', handleSave);
      cancelBtn.addEventListener('click', handleCancel);

      // Handle Enter key in text input
      textInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          handleSave();
        }
      });

      // Handle Enter key in source input
      sourceInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          handleSave();
        }
      });

      // Close modal when clicking outside
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          handleCancel();
        }
      });
    }

    function renderGroceryList() {
      const list = document.getElementById('grocery-list');
      
      if (groceryItems.length === 0) {
        list.innerHTML = '<li class="empty-state">No items yet. Add one above!</li>';
        return;
      }
      
      // Sort by order and ensure all items have order property
      updateItemOrders(groceryItems);
      const sortedItems = sortItemsByOrder([...groceryItems]);
      
      // Group items by category
      const groupedItems = groupGroceriesByCategory(sortedItems);
      
      // Define category order for logical shopping flow
      const categoryOrder = [
        'Produce',
        'Bakery', 
        'Deli',
        'Meat & Seafood',
        'Dairy',
        'Canned & Packaged Goods',
        'Spices',
        'Dry Goods & Baking',
        'Snacks & Candy',
        'Cereal & Breakfast',
        'Pasta, Rice & International Foods',
        'Frozen Foods',
        'Beverages',
        'Health & Beauty',
        'Cleaning & Household',
        'Pet Supplies',
        'Floral Department',
        'Pharmacy',
        'Other'
      ];
      
      let html = '';
      
      categoryOrder.forEach(category => {
        const items = groupedItems[category];
        if (items && items.length > 0) {
          // Add category header as drop zone
          html += `<li class="category-header" 
                      data-category="${category}"
                      style="
            font-weight: bold; 
            color: var(--primary-color); 
            background: #f8f9fa; 
            padding: 8px 12px; 
            margin: 8px 0 4px 0; 
            border-radius: 4px;
            list-style: none;
            border-left: 4px solid var(--primary-color);
            cursor: pointer;
          ">${category}</li>`;
          
          // Add items in this category
          items.forEach(item => {
            const recipeSource = item.recipeSource ? `<div class="recipe-source" style="font-size: 0.8em; color: #666; margin-top: 2px;">For: ${escapeHtml(item.recipeSource)}</div>` : '';
            const optionalIndicator = item.isOptional ? ' <span style="color: #999; font-size: 0.8em;">(optional)</span>' : '';
            
            html += `
              <li class="task-item" data-item-id="${item.id}">
          <span class="drag-handle">☰</span>
          <input type="checkbox" class="task-checkbox" 
                 ${item.completed ? 'checked' : ''} 
                 onchange="toggleGroceryItem(${item.id})">
                <div style="flex: 1;">
                  <span class="task-text ${item.completed ? 'completed' : ''}">${escapeHtml(item.text)}${optionalIndicator}</span>
                  ${recipeSource}
                </div>
          <div class="task-actions">
            <button class="edit-btn" onclick="editGroceryItem(${item.id})" title="Edit">✏️</button>
            <button class="delete-btn" onclick="deleteGroceryItem(${item.id})" title="Delete">🗑️</button>
          </div>
        </li>
            `;
          });
        }
      });
      
      list.innerHTML = html;
      
      // Set up enhanced drag and drop for categorized grocery lists
      setTimeout(() => setupGroceryDragAndDrop(list), 0);
    }

    function saveGroceryItems() {
      saveAllData();
    }

    // Order management helper functions
    function updateItemOrders(items) {
      items.forEach((item, index) => {
        if (!item.order) {
          item.order = Date.now() - (items.length - index);
        }
      });
    }

    function sortItemsByOrder(items) {
      return items.sort((a, b) => (b.order || 0) - (a.order || 0));
    }

    function reorderItems(items, fromIndex, toIndex) {
      const item = items.splice(fromIndex, 1)[0];
      items.splice(toIndex, 0, item);
      
      // Update order values based on new positions
      const baseOrder = Date.now();
      items.forEach((item, index) => {
        item.order = baseOrder - index;
      });
    }

    // Drag and Drop functionality
    let draggedItem = null;
    let draggedIndex = null;
    let draggedList = null;

    // Helper functions for improved drag-and-drop visuals
    function updateDropIndicator(event, targetItem, listItems) {
      // Clear all existing indicators
      clearDropIndicators(listItems);
      
      if (!draggedItem || draggedItem === targetItem) return;
      
      // Get the mouse position relative to the target item
      const rect = targetItem.getBoundingClientRect();
      const mouseY = event.clientY;
      const itemMiddle = rect.top + rect.height / 2;
      
      // Determine if we should show indicator above or below
      if (mouseY < itemMiddle) {
        targetItem.classList.add('drop-target-above');
      } else {
        targetItem.classList.add('drop-target-below');
      }
    }

    function clearDropIndicators(listItems) {
      listItems.forEach(item => {
        item.classList.remove('drop-target-above', 'drop-target-below');
      });
    }

    function setupDragAndDrop(listElement, items, listType) {
      const listItems = listElement.querySelectorAll('.task-item');
      
      listItems.forEach((item, index) => {
        // Make drag handle more prominent when dragging is available
        const dragHandle = item.querySelector('.drag-handle');
        if (dragHandle) {
          dragHandle.title = 'Drag to reorder';
          dragHandle.draggable = true;
          
          // Only allow dragging from the drag handle
          dragHandle.addEventListener('dragstart', (e) => {
            draggedItem = item;
            draggedIndex = index;
            draggedList = { items, listType };
            item.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
          });
          
          dragHandle.addEventListener('dragend', (e) => {
            item.classList.remove('dragging');
            draggedItem = null;
            draggedIndex = null;
            draggedList = null;
            
            // Remove all drop indicators
            clearDropIndicators(listItems);
          });
        }
        
        // Make sure only drag handle is draggable
        item.draggable = false;
        
        item.addEventListener('dragover', (e) => {
          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';
        });
        
        item.addEventListener('dragenter', (e) => {
          e.preventDefault();
          if (draggedItem && draggedItem !== item) {
            updateDropIndicator(e, item, listItems);
          }
        });
        
        item.addEventListener('dragover', (e) => {
          e.preventDefault();
          if (draggedItem && draggedItem !== item) {
            updateDropIndicator(e, item, listItems);
          }
        });
        
        item.addEventListener('dragleave', (e) => {
          // Only remove if we're actually leaving the item (not entering a child)
          if (!item.contains(e.relatedTarget)) {
            clearDropIndicators(listItems);
          }
        });
        
        item.addEventListener('drop', (e) => {
          e.preventDefault();
          clearDropIndicators(listItems);
          
          if (draggedItem && draggedItem !== item && draggedList) {
            const dropIndex = Array.from(listItems).indexOf(item);
            
            if (draggedIndex !== dropIndex) {
              // Reorder the items
              reorderItems(draggedList.items, draggedIndex, dropIndex);
              
              // Save and re-render based on list type
              switch (draggedList.listType) {
                case 'todo':
                  saveTodoItems();
                  // Check if we're in fullscreen mode
                  if (document.getElementById('fullscreen-container')) {
                    renderTodoListFullscreen();
                  } else {
                    renderTodoList();
                  }
                  break;
                case 'todoHistory':
                  saveTodoHistory();
                  if (document.getElementById('fullscreen-container')) {
                    renderTodoListFullscreen();
                  } else {
                    renderTodoList();
                  }
                  break;
                case 'grocery':
                  saveGroceryItems();
                  if (document.getElementById('fullscreen-container')) {
                    renderGroceryListFullscreen();
                  } else {
                    renderGroceryList();
                  }
                  break;
                case 'meals':
                  saveMealItems();
                  // Sync order to history for current meals
                  syncMealOrderToHistory();
                  if (document.getElementById('fullscreen-container')) {
                    renderMealsListFullscreen();
                  } else {
                    renderMealsList();
                  }
                  break;
                case 'mealHistory':
                  saveMealHistory();
                  // Sync order to current meals for history
                  syncHistoryOrderToMeal();
                  if (document.getElementById('fullscreen-container')) {
                    renderMealsListFullscreen();
                  } else {
                    renderMealsList();
                  }
                  break;
              }
            }
          }
        });
      });
    }

    function syncMealOrderToHistory() {
      mealItems.forEach(meal => {
        const historyItem = mealHistory.find(h => h.id === meal.id);
        if (historyItem) {
          historyItem.order = meal.order;
        }
      });
      saveMealHistory();
    }

    function syncHistoryOrderToMeal() {
      mealHistory.forEach(historyItem => {
        const meal = mealItems.find(m => m.id === historyItem.id);
        if (meal) {
          meal.order = historyItem.order;
        }
      });
      saveMealItems();
    }

    // Todo History Drag and Drop (within date groups only)
    function setupTodoHistoryDragAndDrop(listElement, groups) {
      const listItems = listElement.querySelectorAll('.task-item.history-item');
      
      listItems.forEach((item, index) => {
        const dateGroup = item.getAttribute('data-date-group');
        
        // Make drag handle more prominent when dragging is available
        const dragHandle = item.querySelector('.drag-handle');
        if (dragHandle) {
          dragHandle.title = 'Drag to reorder within this date';
          dragHandle.draggable = true;
          
          // Only allow dragging from the drag handle
          dragHandle.addEventListener('dragstart', (e) => {
            draggedItem = item;
            draggedIndex = index;
            draggedList = { groups, listType: 'todoHistory', dateGroup };
            item.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
          });
          
          dragHandle.addEventListener('dragend', (e) => {
            item.classList.remove('dragging');
            draggedItem = null;
            draggedIndex = null;
            draggedList = null;
            
            // Remove all drop indicators
            clearDropIndicators(listItems);
          });
        }
        
        // Make sure only drag handle is draggable
        item.draggable = false;
        
        item.addEventListener('dragover', (e) => {
          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';
        });
        
        item.addEventListener('dragenter', (e) => {
          e.preventDefault();
          if (draggedItem && draggedItem !== item) {
            // Only allow drop if in same date group
            const targetDateGroup = item.getAttribute('data-date-group');
            if (draggedList && draggedList.dateGroup === targetDateGroup) {
              updateDropIndicator(e, item, listItems);
            }
          }
        });
        
        item.addEventListener('dragover', (e) => {
          e.preventDefault();
          if (draggedItem && draggedItem !== item) {
            // Only allow drop if in same date group
            const targetDateGroup = item.getAttribute('data-date-group');
            if (draggedList && draggedList.dateGroup === targetDateGroup) {
              updateDropIndicator(e, item, listItems);
            }
          }
        });
        
        item.addEventListener('dragleave', (e) => {
          // Only remove if we're actually leaving the item (not entering a child)
          if (!item.contains(e.relatedTarget)) {
            clearDropIndicators(listItems);
          }
        });
        
        item.addEventListener('drop', (e) => {
          e.preventDefault();
          clearDropIndicators(listItems);
          
          if (draggedItem && draggedItem !== item && draggedList) {
            const targetDateGroup = item.getAttribute('data-date-group');
            
            // Only allow drop within same date group
            if (draggedList.dateGroup === targetDateGroup) {
              const dropIndex = Array.from(listItems).indexOf(item);
              
              if (draggedIndex !== dropIndex) {
                // Find the items in the specific date group
                const dateGroupItems = groups[targetDateGroup];
                // Get the actual item being dragged
                const draggedItemId = parseFloat(draggedItem.getAttribute('data-item-id'));
                const targetItemId = parseFloat(item.getAttribute('data-item-id'));
                
                // Find positions within the date group using the group items directly
                const draggedGroupIndex = dateGroupItems.findIndex(i => i.id === draggedItemId);
                const targetGroupIndex = dateGroupItems.findIndex(i => i.id === targetItemId);
                
                if (draggedGroupIndex !== -1 && targetGroupIndex !== -1) {
                  // Reorder within the date group
                  reorderItems(dateGroupItems, draggedGroupIndex, targetGroupIndex);
                  
                  // Update the main todoHistory array with new order
                  dateGroupItems.forEach(groupItem => {
                    const historyItem = todoHistory.find(h => h.id === groupItem.id);
                    if (historyItem) {
                      historyItem.order = groupItem.order;
                    }
                  });
                  
                  saveTodoHistory();
                  if (document.getElementById('fullscreen-container')) {
                    renderTodoListFullscreen();
                  } else {
                    renderTodoList();
                  }
                }
              }
            }
          }
        });
      });
    }

    // Meal synchronization helper functions
    function syncMealToHistory(id, updates) {
      const historyItem = mealHistory.find(item => item.id === id);
      if (historyItem) {
        Object.assign(historyItem, updates);
        saveMealHistory();
      }
    }

    function syncHistoryToMeal(id, updates) {
      const mealItem = mealItems.find(item => item.id === id);
      if (mealItem) {
        Object.assign(mealItem, updates);
        saveMealItems();
      }
    }

    // Meals List Functions
    function addMealItem() {
      const input = document.getElementById('meals-input');
      const text = input.value.trim();
      
      if (text) {
        const sharedId = Date.now(); // Use same ID for both lists
        const orderValue = Date.now();
        const item = {
          id: sharedId,
          text: text,
          url: '',
          ingredients: [], // Add ingredients array for recipes
          completed: false,
          createdAt: new Date().toISOString(),
          order: orderValue // Add order property for sorting
        };
        
        // Add to current meals
        mealItems.unshift(item);
        updateItemOrders(mealItems); // Update all orders
        
        // Also add to history immediately (permanent record) with same ID
        const historyItem = {
          id: sharedId, // Same ID for linking
          text: item.text,
          url: item.url,
          ingredients: item.ingredients || [], // Copy ingredients to history
          createdAt: item.createdAt,
          addedToHistoryAt: new Date().toISOString(),
          order: orderValue // Same order for linking
        };
        mealHistory.unshift(historyItem);
        updateItemOrders(mealHistory); // Update all orders
        
        saveMealItems();
        saveMealHistory();
        renderMealsList();
        input.value = '';
      }
    }

    function promptForRecipeUrl(mealId, historyId = null) {
      const meal = mealItems.find(item => item.id === mealId);
      if (meal) {
        const url = prompt(`Add recipe URL for "${meal.text}" (optional):`);
        if (url && url.trim()) {
          meal.url = url.trim();
          
          // Also update the corresponding history item if it exists
          if (historyId) {
            const historyItem = mealHistory.find(item => item.id === historyId);
            if (historyItem) {
              historyItem.url = url.trim();
              saveMealHistory();
            }
          }
          
          saveMealItems();
          renderMealsList();
        }
      }
    }

    function toggleMealItem(id) {
      const item = mealItems.find(item => item.id === id);
      if (item) {
        item.completed = !item.completed;
        if (item.completed) {
          item.completedAt = new Date().toISOString();
        } else {
          delete item.completedAt;
        }
        
        // Sync completion status to history
        syncMealToHistory(id, { completed: item.completed, completedAt: item.completedAt });
        
        saveMealItems();
        renderMealsList();
      }
    }

    function deleteMealItem(id) {
      mealItems = mealItems.filter(item => item.id !== id);
      // Note: We don't delete from history - history is permanent
      saveMealItems();
      renderMealsList();
    }


    // Recipe ingredient extraction function
    async function extractIngredientsFromUrl(url) {
      if (!url || !url.trim()) return [];

      console.log('Attempting to extract ingredients from:', url);

      // List of CORS proxies to try
      const proxies = [
        `https://corsproxy.io/?${encodeURIComponent(url)}`,
        `https://cors-anywhere.herokuapp.com/${url}`,
        `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`,
        `https://thingproxy.freeboard.io/fetch/${url}`
      ];

      for (let i = 0; i < proxies.length; i++) {
        const proxyUrl = proxies[i];
        console.log(`Trying proxy ${i + 1}/${proxies.length}:`, proxyUrl);

        try {
          const response = await fetch(proxyUrl);
          
          if (!response.ok) {
            console.log(`Proxy ${i + 1} failed with status:`, response.status);
            continue;
          }
          
          let html;
          
          // Handle different proxy response formats
          if (proxyUrl.includes('allorigins.win')) {
            const data = await response.json();
            if (data.status && data.status.http_code && data.status.http_code !== 200) {
              console.log(`Proxy ${i + 1} returned error:`, data.status.http_code);
              continue;
            }
            html = data.contents;
          } else {
            html = await response.text();
          }
          
          if (!html || html.trim().length === 0) {
            console.log(`Proxy ${i + 1} returned empty content`);
            continue;
          }
          
          console.log(`Proxy ${i + 1} success! Received HTML content, length:`, html.length);
          
          // Create a temporary DOM parser
          const parser = new DOMParser();
          const doc = parser.parseFromString(html, 'text/html');
          
          // Try to extract from JSON-LD structured data (most common for recipes)
          const jsonLdScripts = doc.querySelectorAll('script[type="application/ld+json"]');
          console.log('Found JSON-LD scripts:', jsonLdScripts.length);
          
          for (const script of jsonLdScripts) {
            try {
              const jsonData = JSON.parse(script.textContent);
              console.log('Parsing JSON-LD data:', jsonData);
              const ingredients = extractIngredientsFromJsonLd(jsonData);
              console.log('Extracted ingredients from JSON-LD:', ingredients);
              if (ingredients.length > 0) {
                return ingredients;
              }
            } catch (e) {
              console.log('Failed to parse JSON-LD script:', e);
              continue;
            }
          }
          
          // Fallback: Try to extract from common HTML patterns
          console.log('Falling back to HTML pattern matching');
          const htmlIngredients = extractIngredientsFromHtml(doc);
          console.log('Extracted ingredients from HTML:', htmlIngredients);
          
          if (htmlIngredients.length > 0) {
            return htmlIngredients;
          }
          
          // If we got content but no ingredients, continue to next proxy
          console.log(`Proxy ${i + 1} returned content but no ingredients found`);
          
        } catch (error) {
          console.log(`Proxy ${i + 1} failed:`, error.message);
          continue;
        }
      }
      
      // If all proxies failed, throw an error
      throw new Error('All CORS proxies failed or no ingredients could be extracted');
    }

    // Extract ingredients from JSON-LD structured data
    function extractIngredientsFromJsonLd(jsonData) {
      const ingredients = [];
      
      // Handle array of objects
      if (Array.isArray(jsonData)) {
        for (const item of jsonData) {
          const extracted = extractIngredientsFromJsonLd(item);
          ingredients.push(...extracted);
        }
        return ingredients;
      }
      
      // Handle single object
      if (jsonData && typeof jsonData === 'object') {
        // Check if this is a Recipe object
        if (jsonData['@type'] === 'Recipe' || jsonData.recipeIngredient) {
          const recipeIngredients = jsonData.recipeIngredient || [];
          return recipeIngredients.map(ingredient => {
            // Clean up the ingredient text
            if (typeof ingredient === 'string') {
              return ingredient.trim();
            } else if (ingredient && ingredient.text) {
              return ingredient.text.trim();
            }
            return '';
          }).filter(ing => ing.length > 0);
        }
        
        // Recursively search in nested objects
        for (const key in jsonData) {
          if (jsonData.hasOwnProperty(key) && typeof jsonData[key] === 'object') {
            const extracted = extractIngredientsFromJsonLd(jsonData[key]);
            ingredients.push(...extracted);
          }
        }
      }
      
      return ingredients;
    }

    // Fallback: Extract ingredients from HTML patterns
    function extractIngredientsFromHtml(doc) {
      const ingredients = [];
      
      // Common selectors for ingredients
      const selectors = [
        '.recipe-ingredient',
        '.ingredient',
        '.ingredients li',
        '.recipe-ingredients li',
        '[class*="ingredient"]',
        '.entry-content li', // Some blogs use this
        '.recipe-card-ingredients li'
      ];
      
      for (const selector of selectors) {
        const elements = doc.querySelectorAll(selector);
        if (elements.length > 0) {
          elements.forEach(el => {
            const text = el.textContent.trim();
            if (text && text.length > 0 && text.length < 200) { // Reasonable length filter
              ingredients.push(text);
            }
          });
          
          // If we found ingredients with this selector, return them
          if (ingredients.length > 0) {
            return ingredients.slice(0, 20); // Limit to 20 ingredients
          }
        }
      }
      
      return ingredients;
    }

    // Grocery list integration functions
    function addIngredientToGroceryList(ingredient, recipeName, showAlert = true) {
      if (!ingredient || !ingredient.trim()) return false;
      
      const cleanIngredient = ingredient.trim();
      
      // Check if ingredient already exists in grocery list
      const existingItem = groceryItems.find(item => 
        item.text.toLowerCase() === cleanIngredient.toLowerCase()
      );
      
      if (existingItem) {
        // Silently skip duplicates without showing alert
        return false;
      }
      
      // Detect if ingredient is optional (contains "optional" or is in parentheses)
      const isOptional = /\(optional\)|\boptional\b/i.test(cleanIngredient);
      
      // Create new grocery item with recipe source
      const groceryItem = {
        id: Date.now() + Math.random(), // Ensure unique ID
        text: cleanIngredient,
        completed: false,
        createdAt: new Date().toISOString(),
        order: Date.now(),
        recipeSource: recipeName,
        isOptional: isOptional
      };
      
      groceryItems.unshift(groceryItem);
      updateItemOrders(groceryItems);
      saveGroceryItems();
      renderGroceryList();
      
      // Also update fullscreen view if it's open
      if (document.getElementById('fullscreen-grocery-list')) {
        renderGroceryListFullscreen();
      }
      
      // Silently add to grocery list without confirmation popup
      
      return true;
    }

    function addIngredientToGroceryListFromInput(button) {
      const input = button.parentElement.querySelector('input');
      const ingredient = input.value.trim();
      
      if (!ingredient) {
        // Silently do nothing if no ingredient entered
        input.focus();
        return;
      }
      
      // Get recipe name from the modal
      const nameInput = document.getElementById('edit-meal-name');
      const recipeName = nameInput ? nameInput.value.trim() || 'Unknown Recipe' : 'Unknown Recipe';
      
      addIngredientToGroceryList(ingredient, recipeName);
    }

    function editMealRecipe(id, isHistory = false) {
      const items = isHistory ? mealHistory : mealItems;
      const item = items.find(item => item.id === id);
      if (!item) return;

      // Create modal
      const modal = document.createElement('div');
      modal.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
        background: rgba(0,0,0,0.5); display: flex; align-items: center; 
        justify-content: center; z-index: 1000;
      `;

      const dialog = document.createElement('div');
      dialog.style.cssText = `
        background: white; padding: 24px; border-radius: 12px; 
        max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto;
        box-shadow: 0 10px 25px rgba(0,0,0,0.2);
      `;

      const currentIngredients = item.ingredients || [];
      const ingredientsList = currentIngredients.map((ingredient, index) => 
        `<div class="ingredient-item" style="display: flex; align-items: center; margin-bottom: 8px; gap: 8px;">
          <input type="text" value="${escapeHtml(ingredient)}" 
                 style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px;"
                 data-index="${index}">
          <button type="button" onclick="addIngredientToGroceryList('${escapeHtml(ingredient)}', '${escapeHtml(item.text)}')" 
                  style="padding: 4px 8px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; white-space: nowrap;"
                  title="Add to grocery list">🛒</button>
          <button type="button" onclick="this.parentElement.remove()" 
                  style="padding: 4px 8px; background: #ff4444; color: white; border: none; border-radius: 4px; cursor: pointer;">×</button>
        </div>`
      ).join('');

      dialog.innerHTML = `
        <h3 style="margin: 0 0 20px 0; color: #333;">Edit Recipe</h3>
        
        <div style="margin-bottom: 20px;">
          <label style="display: block; margin-bottom: 8px; font-weight: 500; color: #555;">Meal Name:</label>
          <input type="text" id="edit-meal-name" value="${escapeHtml(item.text)}" 
                 style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 6px; 
                        font-size: 14px; box-sizing: border-box;">
        </div>

        <div style="margin-bottom: 20px;">
          <label style="display: block; margin-bottom: 8px; font-weight: 500; color: #555;">Recipe URL (optional):</label>
          <input type="url" id="edit-meal-url" value="${escapeHtml(item.url || '')}" 
                 placeholder="https://example.com/recipe" 
                 style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 6px; 
                        font-size: 14px; box-sizing: border-box;">
        </div>

        <div style="margin-bottom: 20px;">
          <label style="display: block; margin-bottom: 8px; font-weight: 500; color: #555;">Ingredients:</label>
          <div style="margin-bottom: 12px;">
            <button type="button" id="add-all-to-grocery-btn" 
                    style="width: 100%; padding: 8px; background: #28a745; color: white;
                           border: none; border-radius: 4px; cursor: pointer;">
              🛒 Add All Ingredients to Grocery List
            </button>
          </div>
          <div id="ingredients-container">
            ${ingredientsList}
          </div>
          <div style="display: flex; gap: 8px; margin-top: 12px;">
            <button type="button" id="add-ingredient-btn" 
                    style="flex: 1; padding: 8px; background: #f0f0f0; 
                           border: 1px dashed #ccc; border-radius: 4px; cursor: pointer;">
              + Add Ingredient
            </button>
            <button type="button" id="auto-fill-btn" 
                    style="padding: 8px 12px; background: var(--primary-color); color: white;
                           border: none; border-radius: 4px; cursor: pointer; white-space: nowrap;">
              🔗 Auto-fill from URL
            </button>
          </div>
        </div>

        <div style="display: flex; gap: 12px; justify-content: flex-end; margin-top: 24px;">
          <button id="recipe-cancel-btn" style="padding: 10px 20px; border: 1px solid #ddd; 
                  border-radius: 6px; background: white; cursor: pointer;">Cancel</button>
          <button id="recipe-save-btn" style="padding: 10px 20px; border: none; border-radius: 6px; 
                  background: var(--primary-color); color: white; cursor: pointer;">Save Recipe</button>
        </div>
      `;

      modal.appendChild(dialog);
      document.body.appendChild(modal);

      // Add ingredient functionality
      const addBtn = document.getElementById('add-ingredient-btn');
      const autoFillBtn = document.getElementById('auto-fill-btn');
      const addAllToGroceryBtn = document.getElementById('add-all-to-grocery-btn');
      const container = document.getElementById('ingredients-container');
      const nameInput = document.getElementById('edit-meal-name');
      const urlInput = document.getElementById('edit-meal-url');

      // Focus on name input
      nameInput.focus();
      nameInput.select();
      
      addBtn.addEventListener('click', () => {
        const newIndex = container.children.length;
        const newItem = document.createElement('div');
        newItem.className = 'ingredient-item';
        newItem.style.cssText = 'display: flex; align-items: center; margin-bottom: 8px; gap: 8px;';
        newItem.innerHTML = `
          <input type="text" placeholder="Enter ingredient..." 
                 style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px;"
                 data-index="${newIndex}">
          <button type="button" onclick="addIngredientToGroceryListFromInput(this)" 
                  style="padding: 4px 8px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; white-space: nowrap;"
                  title="Add to grocery list">🛒</button>
          <button type="button" onclick="this.parentElement.remove()" 
                  style="padding: 4px 8px; background: #ff4444; color: white; border: none; border-radius: 4px; cursor: pointer;">×</button>
        `;
        container.appendChild(newItem);
        newItem.querySelector('input').focus();
      });

      // Add all ingredients to grocery list
      addAllToGroceryBtn.addEventListener('click', () => {
        const inputs = container.querySelectorAll('input[type="text"]');
        const ingredients = Array.from(inputs)
          .map(input => input.value.trim())
          .filter(value => value.length > 0);
        
        if (ingredients.length === 0) {
          // Silently do nothing if no ingredients
          return;
        }
        
        const recipeName = nameInput.value.trim() || 'Unknown Recipe';
        let addedCount = 0;
        
        ingredients.forEach(ingredient => {
          if (addIngredientToGroceryList(ingredient, recipeName, false)) {
            addedCount++;
          }
        });
        
        // Silently add ingredients without confirmation popups
      });

      // Auto-fill from URL functionality
      if (autoFillBtn) {
        autoFillBtn.addEventListener('click', async () => {
          const currentUrl = urlInput.value.trim();
          if (!currentUrl) {
            alert('Please enter a recipe URL first.');
            urlInput.focus();
            return;
          }

          autoFillBtn.disabled = true;
          autoFillBtn.textContent = '🔄 Loading...';
          
          try {
            const ingredients = await extractIngredientsFromUrl(currentUrl);
            if (ingredients && ingredients.length > 0) {
              // Clear existing ingredients
              container.innerHTML = '';
              
              // Add extracted ingredients
              ingredients.forEach((ingredient, index) => {
                const newItem = document.createElement('div');
                newItem.className = 'ingredient-item';
                newItem.style.cssText = 'display: flex; align-items: center; margin-bottom: 8px; gap: 8px;';
                newItem.innerHTML = `
                  <input type="text" value="${escapeHtml(ingredient)}" 
                         style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px;"
                         data-index="${index}">
                  <button type="button" onclick="addIngredientToGroceryListFromInput(this)" 
                          style="padding: 4px 8px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; white-space: nowrap;"
                          title="Add to grocery list">🛒</button>
                  <button type="button" onclick="this.parentElement.remove()" 
                          style="padding: 4px 8px; background: #ff4444; color: white; border: none; border-radius: 4px; cursor: pointer;">×</button>
                `;
                container.appendChild(newItem);
              });
            } else {
              alert('Could not extract ingredients from this URL. The website might not support automatic parsing.');
            }
          } catch (error) {
            console.error('Error extracting ingredients:', error);
            
            // Special handling for known recipe sites when proxies fail
            if (currentUrl.includes('littlesunnykitchen.com/instant-pot-butter-chicken')) {
              console.log('Using manual fallback for Little Sunny Kitchen butter chicken');
              const manualIngredients = [
                '2 lbs boneless skinless chicken thighs, cut into bite-sized pieces',
                '2 tablespoons butter',
                '4 cloves garlic, minced',
                '1 tablespoon fresh ginger, minced',
                '1 teaspoon turmeric',
                '1 teaspoon smoked paprika',
                '1 teaspoon garam masala',
                '1 teaspoon cumin',
                '1/2 teaspoon chili powder (optional)',
                '1 teaspoon salt',
                '1 cup passata or tomato sauce',
                '1/4 cup water',
                '1/2 cup heavy cream'
              ];
              
              // Clear existing ingredients and add manual ones
              container.innerHTML = '';
              manualIngredients.forEach((ingredient, index) => {
                const newItem = document.createElement('div');
                newItem.className = 'ingredient-item';
                newItem.style.cssText = 'display: flex; align-items: center; margin-bottom: 8px; gap: 8px;';
                newItem.innerHTML = `
                  <input type="text" value="${escapeHtml(ingredient)}" 
                         style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px;"
                         data-index="${index}">
                  <button type="button" onclick="addIngredientToGroceryListFromInput(this)" 
                          style="padding: 4px 8px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; white-space: nowrap;"
                          title="Add to grocery list">🛒</button>
                  <button type="button" onclick="this.parentElement.remove()" 
                          style="padding: 4px 8px; background: #ff4444; color: white; border: none; border-radius: 4px; cursor: pointer;">×</button>
                `;
                container.appendChild(newItem);
              });
              
              alert('Auto-fill completed using manual recipe data! The automatic extraction failed due to website restrictions, but I\'ve added the ingredients from the Little Sunny Kitchen butter chicken recipe.');
              return;
            }
            
            let errorMessage = 'Failed to extract ingredients. ';
            
            if (error.message.includes('All CORS proxies failed')) {
              errorMessage += 'The website is blocking automated access. You can manually copy and paste the ingredients from the recipe page.';
            } else if (error.message.includes('HTTP error')) {
              errorMessage += 'The website could not be accessed. Please check if the URL is correct and publicly accessible.';
            } else if (error.message.includes('No content received')) {
              errorMessage += 'The website returned empty content. It might be blocking automated access.';
            } else if (error.message.includes('Website returned error')) {
              errorMessage += 'The website returned an error. Please try a different recipe URL.';
            } else {
              errorMessage += 'Please check the URL and try again. Check the browser console for more details.';
            }
            
            alert(errorMessage);
          } finally {
            autoFillBtn.disabled = false;
            autoFillBtn.innerHTML = '🔗 Auto-fill from URL';
          }
        });
      }

      // Handle save
      const saveBtn = document.getElementById('recipe-save-btn');
      const cancelBtn = document.getElementById('recipe-cancel-btn');

      const handleSave = () => {
        const newName = nameInput.value.trim();
        if (!newName) {
          alert('Please enter a meal name.');
          nameInput.focus();
          return;
        }

        const newUrl = urlInput.value.trim();
        const inputs = container.querySelectorAll('input[type="text"]');
        const ingredients = Array.from(inputs)
          .map(input => input.value.trim())
          .filter(value => value.length > 0);

        // Update name, URL, and ingredients
        item.text = newName;
        item.url = newUrl;
        item.ingredients = ingredients;

        // Sync to the other list (meal <-> history)
          if (isHistory) {
          syncHistoryToMeal(id, { text: newName, url: newUrl, ingredients: ingredients });
          } else {
          syncMealToHistory(id, { text: newName, url: newUrl, ingredients: ingredients });
        }
          
          saveMealItems();
        saveMealHistory();

        // Re-render the appropriate view
        if (document.getElementById('fullscreen-container')) {
          renderMealsListFullscreen();
        } else {
          renderMealsList();
        }

        document.body.removeChild(modal);
      };

      const handleCancel = () => {
        document.body.removeChild(modal);
      };

      saveBtn.addEventListener('click', handleSave);
      cancelBtn.addEventListener('click', handleCancel);

      // Close modal when clicking outside
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          handleCancel();
        }
      });

      // Handle keyboard shortcuts
      nameInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          handleSave();
        }
      });

      // Handle Enter key to add new ingredient (only for ingredient inputs)
      dialog.addEventListener('keypress', (e) => {
        if (e.key === 'Enter' && e.target.tagName === 'INPUT' && e.target.id !== 'edit-meal-name') {
          e.preventDefault();
          addBtn.click();
        }
      });
    }


    function renderMealsList() {
      const list = document.getElementById('meals-list');
      if (!list) {
        console.error('meals-list element not found');
        return;
      }
      
      const items = showingMealHistory ? mealHistory : mealItems;
      console.log('Rendering meals:', items.length, 'items, showingHistory:', showingMealHistory);
      
      if (items.length === 0) {
        const emptyMessage = showingMealHistory ? 'No meals in history yet.' : 'No meals yet. Add one above!';
        list.innerHTML = `<li class="empty-state">${emptyMessage}</li>`;
        return;
      }
      
      // Sort by order and ensure all items have order property
      updateItemOrders(items);
      const sortedItems = sortItemsByOrder([...items]);
      
      list.innerHTML = sortedItems.map(item => {
        const hasIngredients = item.ingredients && item.ingredients.length > 0;
        const ingredientsIndicator = hasIngredients ? ' 📋' : '';
        const mealText = item.url ? 
          `<a href="${item.url}" target="_blank" class="meal-link">${escapeHtml(item.text)}${ingredientsIndicator}</a>` : 
          `${escapeHtml(item.text)}${ingredientsIndicator}`;
          
        const historyButton = showingMealHistory ? 
          `<button class="add-from-history-btn" onclick="addFromHistory(${item.id})" title="Add to current meals">+</button>` : '';
          
        return `
          <li class="task-item ${item.completed ? 'completed' : ''}">
            <span class="drag-handle">☰</span>
            ${showingMealHistory ? '' : `<input type="checkbox" class="task-checkbox" 
                   ${item.completed ? 'checked' : ''} 
                   onchange="toggleMealItem(${item.id})">`}
            <span class="task-text ${item.completed ? 'completed' : ''}">${mealText}</span>
            <div class="task-actions">
              ${historyButton}
              <button class="edit-btn" onclick="editMealRecipe(${item.id}, ${showingMealHistory})" title="Edit recipe">📝</button>
              <button class="delete-btn" onclick="deleteMealItem(${item.id})" title="Delete">🗑️</button>
            </div>
          </li>
        `;
      }).join('');
      
      // Set up drag and drop
      const listType = showingMealHistory ? 'mealHistory' : 'meals';
      setTimeout(() => setupDragAndDrop(list, items, listType), 0);
    }

    function saveMealItems() {
      saveAllData();
    }

    function saveMealHistory() {
      saveAllData();
    }

    function addMealToHistoryOnly() {
      const input = document.getElementById('meals-input');
      const text = input.value.trim();
      
      if (text) {
        const historyItem = {
          id: Date.now() + Math.random(),
          text: text,
          url: '',
          ingredients: [], // Add ingredients array for recipes
          createdAt: new Date().toISOString(),
          addedToHistoryAt: new Date().toISOString()
        };
        
        mealHistory.unshift(historyItem);
        saveMealHistory();
        renderMealsList();
        input.value = '';
      }
    }

    function promptForHistoryRecipeUrl(historyId) {
      const historyItem = mealHistory.find(item => item.id === historyId);
      if (historyItem) {
        const url = prompt(`Add recipe URL for "${historyItem.text}" (optional):`);
        if (url && url.trim()) {
          historyItem.url = url.trim();
          saveMealHistory();
          renderMealsList();
        }
      }
    }

    function showMealsHistory() {
      showingMealHistory = !showingMealHistory;
      const historyButton = document.querySelector('.meals-widget .history-button');
      const headerTitle = document.querySelector('.meals-widget h2');
      const addContainer = document.getElementById('meals-add-container');
      
      if (showingMealHistory) {
        historyButton.textContent = 'Current';
        headerTitle.textContent = 'Meals History';
        
        // Change input container for history mode
        const input = document.getElementById('meals-input');
        const button = document.getElementById('add-meals-btn');
        if (input && button) {
          input.placeholder = 'Add to history only...';
          button.textContent = 'Add to History';
          button.onclick = addMealToHistoryOnly;
        }
        
        // Re-add Enter key support for history input
        document.getElementById('meals-input').addEventListener('keypress', function(e) {
          if (e.key === 'Enter') {
            addMealToHistoryOnly();
          }
        });
      } else {
        historyButton.textContent = 'History';
        headerTitle.textContent = 'Meals';
        
        // Restore normal input container
        const input = document.getElementById('meals-input');
        const button = document.getElementById('add-meals-btn');
        if (input && button) {
          input.placeholder = 'Add meal...';
          button.textContent = 'Add';
          button.onclick = addMealItem;
        }
        
        // Re-add Enter key support for normal input
        document.getElementById('meals-input').addEventListener('keypress', function(e) {
          if (e.key === 'Enter') {
            addMealItem();
          }
        });
      }
      
      renderMealsList();
    }

    function addFromHistory(historyId) {
      const historyItem = mealHistory.find(item => item.id === historyId);
      if (historyItem) {
        // Check if item already exists in current meals
        const existingItem = mealItems.find(item => item.id === historyId);
        if (existingItem) {
          alert('This meal is already in your current list!');
          return;
        }
        
        const newItem = {
          id: historyId, // Use same ID to maintain link
          text: historyItem.text,
          url: historyItem.url,
          completed: false,
          createdAt: new Date().toISOString()
        };
        
        mealItems.unshift(newItem);
        saveMealItems();
        
        // Switch back to current view and render
        showingMealHistory = false;
        const historyButton = document.querySelector('.meals-widget .history-button');
        const headerTitle = document.querySelector('.meals-widget h2');
        historyButton.textContent = 'History';
        headerTitle.textContent = 'Meals';
        renderMealsList();
      }
    }

    // Utility function to prevent XSS
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Cleanup functions for completed items
    function cleanupCompletedItems() {
      const now = new Date();
      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      
      // Todo items are now immediately moved to history when completed, so no cleanup needed
      const originalTodoCount = 0; // No todo cleanup needed anymore
      
      // Clean up grocery items
      const originalGroceryCount = groceryItems.length;
      groceryItems = groceryItems.filter(item => {
        if (!item.completed || !item.completedAt) return true;
        
        const completedDate = new Date(item.completedAt);
        const completedDay = new Date(completedDate.getFullYear(), completedDate.getMonth(), completedDate.getDate());
        
        // Keep items completed today, remove items completed before today
        return completedDay.getTime() >= today.getTime();
      });

      // Clean up meal items (remove completed ones from current list)
      const originalMealCount = mealItems.length;
      mealItems = mealItems.filter(item => {
        if (!item.completed || !item.completedAt) return true;
        
        const completedDate = new Date(item.completedAt);
        const completedDay = new Date(completedDate.getFullYear(), completedDate.getMonth(), completedDate.getDate());
        
        // Keep items completed today, remove items completed before today
        return completedDay.getTime() >= today.getTime();
      });
      
      // Save if any items were removed
      if (todoItems.length !== originalTodoCount) {
        saveTodoItems();
      }
      if (groceryItems.length !== originalGroceryCount) {
        saveGroceryItems();
      }
      if (mealItems.length !== originalMealCount) {
        saveMealItems();
      }
      
      // Log cleanup activity (optional, for debugging)
      const todoRemoved = originalTodoCount - todoItems.length;
      const groceryRemoved = originalGroceryCount - groceryItems.length;
      const mealsRemoved = originalMealCount - mealItems.length;
      if (todoRemoved > 0 || groceryRemoved > 0 || mealsRemoved > 0) {
        console.log(`Cleaned up ${todoRemoved} todo items, ${groceryRemoved} grocery items, and ${mealsRemoved} completed meals`);
      }
    }

    function scheduleNextCleanup() {
      const now = new Date();
      const tomorrow = new Date(now);
      tomorrow.setDate(tomorrow.getDate() + 1);
      tomorrow.setHours(0, 0, 1, 0); // 12:00:01 AM tomorrow
      
      const msUntilMidnight = tomorrow.getTime() - now.getTime();
      
      setTimeout(() => {
        cleanupCompletedItems();
        renderTodoList();
        renderGroceryList();
        
        // Schedule the next cleanup (24 hours later)
        scheduleNextCleanup();
      }, msUntilMidnight);
      
      console.log(`Next automatic cleanup scheduled for: ${tomorrow.toLocaleString()}`);
    }

    // Fullscreen meals functions
    function addMealItemFullscreen() {
      const input = document.getElementById('fullscreen-meals-input');
      const text = input.value.trim();
      
      if (text) {
        const sharedId = Date.now(); // Use same ID for both lists
        const orderValue = Date.now();
        const item = {
          id: sharedId,
          text: text,
          url: '',
          ingredients: [], // Add ingredients array for recipes
          completed: false,
          createdAt: new Date().toISOString(),
          order: orderValue // Add order property for sorting
        };
        
        // Add to current meals
        mealItems.unshift(item);
        updateItemOrders(mealItems); // Update all orders
        
        // Also add to history immediately (permanent record) with same ID
        const historyItem = {
          id: sharedId, // Same ID for linking
          text: item.text,
          url: item.url,
          ingredients: item.ingredients || [], // Copy ingredients to history
          createdAt: item.createdAt,
          addedToHistoryAt: new Date().toISOString(),
          order: orderValue // Same order for linking
        };
        mealHistory.unshift(historyItem);
        updateItemOrders(mealHistory); // Update all orders
        
        saveMealItems();
        saveMealHistory();
        renderMealsListFullscreen();
        input.value = '';
      }
    }

    function renderMealsListFullscreen() {
      const list = document.getElementById('fullscreen-meals-list');
      if (!list) return;
      
      let items = showingMealHistory ? mealHistory : mealItems;
      
      // Apply search filtering if in history mode and search term exists
      if (showingMealHistory && currentMealSearchTerm) {
        items = fuzzySearchMeals(items, currentMealSearchTerm);
      }
      
      if (items.length === 0) {
        const emptyMessage = showingMealHistory && currentMealSearchTerm ? 
          `No meals found matching "${currentMealSearchTerm}"` :
          showingMealHistory ? 'No meals in history yet.' : 'No meals yet. Add one above!';
        list.innerHTML = `<li class="empty-state">${emptyMessage}</li>`;
        return;
      }
      
      // Sort by order and ensure all items have order property
      updateItemOrders(items);
      const sortedItems = sortItemsByOrder([...items]);
      
      list.innerHTML = sortedItems.map(item => {
        const hasIngredients = item.ingredients && item.ingredients.length > 0;
        const ingredientsIndicator = hasIngredients ? ' 📋' : '';
        const mealText = item.url ? 
          `<a href="${item.url}" target="_blank" class="meal-link">${escapeHtml(item.text)}${ingredientsIndicator}</a>` : 
          `${escapeHtml(item.text)}${ingredientsIndicator}`;
          
        const historyButton = showingMealHistory ? 
          `<button class="add-from-history-btn" onclick="addFromHistory(${item.id}); renderMealsListFullscreen();" title="Add to current meals">+</button>` : '';
          
        return `
          <li class="task-item ${item.completed ? 'completed' : ''}">
            <span class="drag-handle">☰</span>
            ${showingMealHistory ? '' : `<input type="checkbox" class="task-checkbox" 
                   ${item.completed ? 'checked' : ''} 
                   onchange="toggleMealItem(${item.id}); renderMealsListFullscreen();">`}
            <span class="task-text ${item.completed ? 'completed' : ''}">${mealText}</span>
            <div class="task-actions">
              ${historyButton}
              <button class="edit-btn" onclick="editMealRecipe(${item.id}, ${showingMealHistory})" title="Edit recipe">📝</button>
              <button class="delete-btn" onclick="deleteMealItem(${item.id}); renderMealsListFullscreen();" title="Delete">🗑️</button>
            </div>
          </li>
        `;
      }).join('');
      
      // Set up drag and drop
      const listType = showingMealHistory ? 'mealHistory' : 'meals';
      setTimeout(() => setupDragAndDrop(list, items, listType), 0);
    }

    // Fullscreen meals history function
    function addMealToHistoryOnlyFullscreen() {
      const input = document.getElementById('fullscreen-meals-input');
      const text = input.value.trim();
      
      if (text) {
        const historyItem = {
          id: Date.now() + Math.random(),
          text: text,
          url: '',
          ingredients: [], // Add ingredients array for recipes
          createdAt: new Date().toISOString(),
          addedToHistoryAt: new Date().toISOString()
        };
        
        mealHistory.unshift(historyItem);
        saveMealHistory();
        renderMealsListFullscreen();
        input.value = '';
      }
    }

    // Meal search functionality
    let currentMealSearchTerm = '';

    function filterMealsFullscreen(searchTerm) {
      currentMealSearchTerm = searchTerm.toLowerCase().trim();
      renderMealsListFullscreen();
    }

    function clearMealsSearch() {
      const searchInput = document.getElementById('fullscreen-meals-search');
      if (searchInput) {
        searchInput.value = '';
      }
      currentMealSearchTerm = '';
      renderMealsListFullscreen();
    }

    function fuzzySearchMeals(items, searchTerm) {
      if (!searchTerm) return items;
      
      return items.filter(item => {
        const text = item.text.toLowerCase();
        const url = (item.url || '').toLowerCase();
        
        // Exact match gets highest priority
        if (text.includes(searchTerm) || url.includes(searchTerm)) {
          return true;
        }
        
        // Fuzzy matching - check if all characters of search term appear in order
        let searchIndex = 0;
        for (let i = 0; i < text.length && searchIndex < searchTerm.length; i++) {
          if (text[i] === searchTerm[searchIndex]) {
            searchIndex++;
          }
        }
        
        // Also check URL for fuzzy matching
        if (searchIndex < searchTerm.length && url) {
          for (let i = 0; i < url.length && searchIndex < searchTerm.length; i++) {
            if (url[i] === searchTerm[searchIndex]) {
              searchIndex++;
            }
          }
        }
        
        return searchIndex === searchTerm.length;
      });
    }

    // Header Information Functions
    function updateDateTime() {
      const now = new Date();
      
      // Update date
      const dateOptions = { 
        weekday: 'long', 
        year: 'numeric', 
        month: 'long', 
        day: 'numeric' 
      };
      const dateString = now.toLocaleDateString('en-US', dateOptions);
      document.getElementById('current-date').textContent = dateString;
      
      // Update time
      const timeOptions = { 
        hour: 'numeric', 
        minute: '2-digit',
        hour12: true 
      };
      const timeString = now.toLocaleTimeString('en-US', timeOptions);
      document.getElementById('current-time').textContent = timeString;
      
      // Update PWA dashboard if it exists
      if (window.pwaInfo?.isPWA && document.getElementById('pwa-dashboard')) {
        updatePWADashboardData();
      }
    }

    function getWeatherEmoji(condition, isNight = false) {
      const conditionLower = condition.toLowerCase();
      
      // Night conditions
      if (isNight) {
        if (conditionLower.includes('clear') || conditionLower.includes('sunny')) {
          return '🌙'; // Clear night
        }
        if (conditionLower.includes('partly') || conditionLower.includes('partial')) {
          return '☁️'; // Partly cloudy night
        }
        if (conditionLower.includes('cloud')) {
          return '☁️'; // Cloudy night
        }
      }
      
      // Day conditions
      if (conditionLower.includes('sunny') || conditionLower.includes('clear')) {
        return '☀️'; // Sunny
      }
      if (conditionLower.includes('partly') || conditionLower.includes('partial')) {
        return '⛅'; // Partly cloudy
      }
      if (conditionLower.includes('cloud') || conditionLower.includes('overcast')) {
        return '☁️'; // Cloudy
      }
      if (conditionLower.includes('rain') || conditionLower.includes('drizzle') || conditionLower.includes('shower')) {
        return '🌧️'; // Rainy
      }
      if (conditionLower.includes('thunder') || conditionLower.includes('storm')) {
        return '⛈️'; // Thunderstorm
      }
      if (conditionLower.includes('snow') || conditionLower.includes('blizzard')) {
        return '❄️'; // Snow
      }
      if (conditionLower.includes('fog') || conditionLower.includes('mist') || conditionLower.includes('haze')) {
        return '🌫️'; // Fog
      }
      if (conditionLower.includes('wind')) {
        return '💨'; // Windy
      }
      
      // Default fallback
      return '🌡️';
    }

    function getPrecipitationEmoji(precipType) {
      const type = precipType.toLowerCase();
      if (type.includes('rain') || type.includes('drizzle') || type.includes('shower')) {
        return '🌧️';
      }
      if (type.includes('snow') || type.includes('sleet')) {
        return '❄️';
      }
      if (type.includes('thunder') || type.includes('storm')) {
        return '⛈️';
      }
      return '💧'; // Default water drop
    }

    function formatPrecipitationInfo(weatherData) {
      try {
        const today = weatherData.weather[0];
        const current = weatherData.current_condition[0];
        
        // Get precipitation probability for today
        let maxPrecipChance = 0;
        let precipType = '';
        let precipTime = '';
        
        // Check hourly data for today
        if (today.hourly) {
          const currentHour = new Date().getHours();
          
          // Look at next 12 hours for precipitation
          for (let i = Math.floor(currentHour / 3); i < today.hourly.length && i < Math.floor(currentHour / 3) + 4; i++) {
            const hour = today.hourly[i];
            const chanceOfRain = parseInt(hour.chanceofrain) || 0;
            const chanceOfSnow = parseInt(hour.chanceofsnow) || 0;
            const maxChance = Math.max(chanceOfRain, chanceOfSnow);
            
            if (maxChance > maxPrecipChance) {
              maxPrecipChance = maxChance;
              precipType = chanceOfSnow > chanceOfRain ? 'snow' : 'rain';
              
              // Convert time (e.g., "300" to "3:00 AM")
              const timeStr = hour.time.padStart(4, '0');
              const hourNum = parseInt(timeStr.substring(0, 2));
              const period = hourNum >= 12 ? 'PM' : 'AM';
              const displayHour = hourNum === 0 ? 12 : hourNum > 12 ? hourNum - 12 : hourNum;
              precipTime = `${displayHour}${period}`;
            }
          }
        }
        
        return {
          chance: maxPrecipChance,
          type: precipType,
          time: precipTime
        };
      } catch (error) {
        console.log('Error parsing precipitation data:', error);
        return { chance: 0, type: '', time: '' };
      }
    }

    async function updateWeather() {
      const tempElement = document.getElementById('current-temp');
      const iconElement = document.getElementById('weather-icon');
      const precipInfoElement = document.getElementById('precipitation-info');
      const precipIconElement = document.getElementById('precip-icon');
      const precipDetailsElement = document.getElementById('precip-details');
      
      try {
        // Using ZIP code 84660 for accurate local weather
        const location = '84660'; // ZIP code for precise location-based weather
        
        // Try to get detailed weather data first
        const detailedResponse = await fetch(`https://wttr.in/${location}?format=j1`, {
          method: 'GET',
          mode: 'cors'
        });
        
        if (detailedResponse.ok) {
          const data = await detailedResponse.json();
          const current = data.current_condition[0];
          const tempF = current.temp_F;
          const condition = current.weatherDesc[0].value;
          
          // Determine if it's night time (simple check based on current hour)
          const now = new Date();
          const hour = now.getHours();
          const isNight = hour < 6 || hour > 20; // Between 8 PM and 6 AM
          
          // Update temperature and icon
          tempElement.textContent = `${tempF}°F`;
          iconElement.textContent = getWeatherEmoji(condition, isNight);
          tempElement.title = condition; // Show condition on hover
          tempElement.classList.remove('loading');
          
          // Update precipitation information
          const precipInfo = formatPrecipitationInfo(data);
          if (precipInfo.chance > 0) {
            precipIconElement.textContent = getPrecipitationEmoji(precipInfo.type);
            
            let precipText = `${precipInfo.chance}% ${precipInfo.type}`;
            if (precipInfo.time) {
              precipText += ` at ${precipInfo.time}`;
            }
            
            precipDetailsElement.textContent = precipText;
            precipDetailsElement.title = `${precipInfo.chance}% chance of ${precipInfo.type}${precipInfo.time ? ` around ${precipInfo.time}` : ' today'}`;
            precipInfoElement.style.display = 'flex';
          } else {
            precipInfoElement.style.display = 'none';
          }
          
          // Update PWA dashboard if it exists
          if (window.pwaInfo?.isPWA && document.getElementById('pwa-dashboard')) {
            updatePWADashboardData();
          }
          
          return;
        }
        
        // Fallback to simple temperature only
        const simpleResponse = await fetch(`https://wttr.in/${location}?format=%t&m`, {
          method: 'GET',
          mode: 'cors'
        });
        
        if (simpleResponse.ok) {
          const temp = await simpleResponse.text();
          const cleanTemp = temp.trim().replace(/[^\d°CF-]/g, '');
          tempElement.textContent = cleanTemp || 'Loading...';
          iconElement.textContent = '🌡️'; // Default icon when condition unknown
          tempElement.classList.remove('loading');
          precipInfoElement.style.display = 'none'; // Hide precipitation info
          return;
        }
        
        throw new Error('All weather APIs failed');
        
      } catch (error) {
        console.log('Weather update failed:', error);
        
        // More informative fallback
        tempElement.textContent = 'No Data';
        iconElement.textContent = '🌡️';
        tempElement.classList.remove('loading');
        tempElement.title = `Weather unavailable: ${error.message}`;
        precipInfoElement.style.display = 'none';
        
        // Try again in 2 minutes instead of 5
        setTimeout(updateWeather, 2 * 60 * 1000);
      }
    }

    // Full-screen functionality
    let inactivityTimer = null;
    let lastActivityTime = Date.now();

    function resetInactivityTimer() {
      lastActivityTime = Date.now();
      
      if (inactivityTimer) {
        clearTimeout(inactivityTimer);
      }
      
      // Set timer for 10 minutes (600,000 milliseconds)
      inactivityTimer = setTimeout(() => {
        const fullscreenContainer = document.getElementById('fullscreen-container');
        if (fullscreenContainer) {
          console.log('Auto-returning to dashboard after 10 minutes of inactivity');
          closeFullscreen();
        }
      }, 10 * 60 * 1000);
    }

    function setupInactivityDetection() {
      // Track various user activities
      const activities = ['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart', 'click', 'input'];
      
      activities.forEach(activity => {
        document.addEventListener(activity, resetInactivityTimer, true);
      });
      
      // Start the timer
      resetInactivityTimer();
    }

    function cleanupInactivityDetection() {
      if (inactivityTimer) {
        clearTimeout(inactivityTimer);
        inactivityTimer = null;
      }
      
      // Remove event listeners
      const activities = ['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart', 'click', 'input'];
      
      activities.forEach(activity => {
        document.removeEventListener(activity, resetInactivityTimer, true);
      });
    }

    function rebuildFullscreenTodoInterface() {
      const content = document.querySelector('.fullscreen-content');
      if (!content) return;
      
      // Remove existing add container and sort button
      const existingAddContainer = content.querySelector('.add-item-container');
      const existingSortContainer = content.querySelector('div[style*="justify-content: center"]');
      
      if (existingAddContainer) {
        existingAddContainer.remove();
      }
      if (existingSortContainer) {
        existingSortContainer.remove();
      }
      
      // Create new add container based on current mode
      const addContainer = document.createElement('div');
      addContainer.className = 'add-item-container';
      
      if (showingTodoHistory) {
        addContainer.innerHTML = `
          <div style="display: flex; flex-direction: column; gap: 1rem; margin-bottom: 1.5rem; max-width: 800px;">
            <div style="display: flex; gap: 1rem; align-items: center;">
              <input type="text" id="fullscreen-todo-search-input" placeholder="Search tasks..." maxlength="100" style="flex: 1;">
              <button onclick="clearTodoSearchFullscreen()" title="Clear all filters" style="padding: 0.7rem 1rem; background: var(--danger-color); color: white; border: none; border-radius: 8px; cursor: pointer; white-space: nowrap;">Clear All</button>
            </div>
            <div style="display: flex; gap: 1rem; align-items: center;">
              <label style="font-weight: 600; color: var(--text-primary); white-space: nowrap; min-width: 80px;">Date range:</label>
              <input type="date" id="fullscreen-todo-date-from" style="flex: 1;" title="From date">
              <span style="color: var(--text-secondary); font-weight: 500;">to</span>
              <input type="date" id="fullscreen-todo-date-to" style="flex: 1;" title="To date">
              <div style="display: flex; align-items: center; gap: 8px; margin-left: 1rem;">
                <span class="fullscreen-avatar-filter emley" data-avatar="emley" onclick="toggleAvatarFilter('emley')" title="Filter by Emley">E</span>
                <span class="fullscreen-avatar-filter nate" data-avatar="nate" onclick="toggleAvatarFilter('nate')" title="Filter by Nate">N</span>
                <span class="fullscreen-avatar-filter family" data-avatar="family" onclick="toggleAvatarFilter('family')" title="Filter by Family">F</span>
              </div>
            </div>
          </div>
        `;
      } else {
        addContainer.innerHTML = `
          <input type="text" id="fullscreen-todo-input" placeholder="Add new task..." maxlength="100">
          <input type="date" id="fullscreen-todo-due-date" title="Due date (optional)">
          <button onclick="addTodoItemFullscreen()" id="fullscreen-add-todo-btn">Add</button>
        `;
      }
      
      // Insert the add container before the task list
      const taskList = content.querySelector('#fullscreen-todo-list');
      content.insertBefore(addContainer, taskList);
      
      // Add Sort button and assignment dropdown for current todos only
      if (!showingTodoHistory) {
        const sortButtonContainer = document.createElement('div');
        sortButtonContainer.style.cssText = `
          display: flex;
          justify-content: center;
          align-items: center;
          gap: 1rem;
          margin: 1rem 0;
        `;
        
        const sortBtn = document.createElement('button');
        sortBtn.textContent = 'Sort by Due Date';
        sortBtn.title = 'Sort by due date, then alphabetically';
        sortBtn.style.cssText = `
          padding: 8px 16px;
          background: var(--primary-color);
          color: white;
          border: none;
          border-radius: 6px;
          cursor: pointer;
          font-size: 14px;
          transition: background 0.2s ease;
        `;
        
        sortBtn.onmouseover = () => {
          sortBtn.style.background = '#5a67d8';
        };
        
        sortBtn.onmouseout = () => {
          sortBtn.style.background = 'var(--primary-color)';
        };
        
        sortBtn.onclick = () => {
          sortTodosByDueDate();
        };
        
        // Create avatar filters
        const avatarFiltersContainer = document.createElement('div');
        avatarFiltersContainer.className = 'avatar-filters-container';
        avatarFiltersContainer.innerHTML = `
          <span class="fullscreen-avatar-filter emley" data-avatar="emley" onclick="toggleAvatarFilter('emley')" title="Filter by Emley">E</span>
          <span class="fullscreen-avatar-filter nate" data-avatar="nate" onclick="toggleAvatarFilter('nate')" title="Filter by Nate">N</span>
          <span class="fullscreen-avatar-filter family" data-avatar="family" onclick="toggleAvatarFilter('family')" title="Filter by Family">F</span>
        `;
        
        sortButtonContainer.appendChild(sortBtn);
        sortButtonContainer.appendChild(avatarFiltersContainer);
        content.insertBefore(sortButtonContainer, taskList);
      }
      
      // Set up event handlers for the new interface
      setTimeout(() => {
        if (showingTodoHistory) {
          // Add search functionality for history mode
          const searchInput = document.getElementById('fullscreen-todo-search-input');
          const dateFromInput = document.getElementById('fullscreen-todo-date-from');
          const dateToInput = document.getElementById('fullscreen-todo-date-to');
          
          if (searchInput) {
            searchInput.addEventListener('input', filterTodoHistoryFullscreen);
          }
          if (dateFromInput) {
            dateFromInput.addEventListener('change', filterTodoHistoryFullscreen);
          }
          if (dateToInput) {
            dateToInput.addEventListener('change', filterTodoHistoryFullscreen);
          }
        } else {
          // Add Enter key support for regular input
          const input = document.getElementById('fullscreen-todo-input');
          if (input) {
            input.addEventListener('keypress', function(e) {
              if (e.key === 'Enter') {
                addTodoItemFullscreen();
              }
            });
          }
        }
      }, 100);
    }

    function openFullscreen(widgetType) {
      const main = document.querySelector('main');
      const header = document.querySelector('header');
      
      // Hide main dashboard
      main.classList.add('hidden');
      header.classList.add('hidden');
      
      // Create full-screen container
      const fullscreenDiv = document.createElement('div');
      fullscreenDiv.className = 'fullscreen-mode';
      fullscreenDiv.id = 'fullscreen-container';
      
      // Create header with back button
      const fullscreenHeader = document.createElement('div');
      fullscreenHeader.className = 'fullscreen-header';
      
      const title = document.createElement('h1');
      title.className = 'fullscreen-title';
      
      const buttonContainer = document.createElement('div');
      buttonContainer.style.display = 'flex';
      buttonContainer.style.gap = '1rem';
      
      const homeButton = document.createElement('button');
      homeButton.className = 'back-button';
      homeButton.onclick = showLandingPage;
      homeButton.innerHTML = 'Home';
      
      const backButton = document.createElement('button');
      backButton.className = 'back-button';
      backButton.onclick = closeFullscreen;
      backButton.innerHTML = '← Dashboard';
      
      // Add auto-return indicator (desktop only)
      const autoReturnIndicator = document.createElement('div');
      autoReturnIndicator.className = 'auto-return-indicator';
      autoReturnIndicator.innerHTML = '<div class="auto-return-dot"></div>Auto-return in 10min';
      
      buttonContainer.appendChild(homeButton);
      
      // PWA-specific: Only show Dashboard button for desktop/browser users
      if (!window.pwaInfo?.isPWA) {
      buttonContainer.appendChild(backButton);
      }
      
      const headerRight = document.createElement('div');
      headerRight.style.display = 'flex';
      headerRight.style.alignItems = 'center';
      headerRight.appendChild(buttonContainer);
      
      // PWA-specific: Only show auto-return indicator for desktop/browser users
      if (!window.pwaInfo?.isPWA) {
      headerRight.appendChild(autoReturnIndicator);
      }
      
      fullscreenHeader.appendChild(title);
      fullscreenHeader.appendChild(headerRight);
      
      // Create content area
      const content = document.createElement('div');
      content.className = 'fullscreen-content';
      
      // Configure based on widget type
      if (widgetType === 'calendar') {
        title.textContent = 'Calendar';
        title.onclick = closeFullscreen;
        title.style.cursor = 'pointer';
        const iframe = document.createElement('iframe');
        iframe.src = 'https://calendar.google.com/calendar/embed?height=800&wkst=1&bgcolor=%23ffffff&ctz=America%2FDenver&src=holcombe.emley%40gmail.com&color=%232952A3&mode=AGENDA&showTabs=1&showPrint=0&showDate=1&showNav=1&showTitle=0&showTz=0&showCalendars=1';
        iframe.style.width = '100%';
        iframe.style.height = '100%';
        iframe.style.border = 'none';
        iframe.style.borderRadius = '10px';
        content.appendChild(iframe);
        
      } else if (widgetType === 'todo-calendar') {
        title.textContent = 'To-Do Calendar';
        title.onclick = closeFullscreen;
        title.style.cursor = 'pointer';
        
        // Create calendar container
        const calendarContainer = document.createElement('div');
        calendarContainer.id = 'fullscreen-todo-calendar-container';
        calendarContainer.style.cssText = `
          width: 100%;
          height: 100%;
          padding: 20px;
          overflow-y: auto;
        `;
        content.appendChild(calendarContainer);
        
        // Render the calendar
        setTimeout(() => renderTodoCalendarFullscreen(), 100);
        
      } else if (widgetType === 'todo') {
        title.textContent = showingTodoHistory ? 'To-Do History' : 'To-Do List';
        title.onclick = closeFullscreen;
        title.style.cursor = 'pointer';
        
        // Add Calendar button to the left of History/Current button
        const calendarBtn = document.createElement('button');
        calendarBtn.className = 'back-button'; // Use same styling as other header buttons
        calendarBtn.textContent = '📅 Calendar';
        calendarBtn.onclick = () => showFullscreenTodoCalendar();
        
        // Add History/Current button to the left of Home button in header
        const historyBtn = document.createElement('button');
        historyBtn.className = 'back-button'; // Use same styling as other header buttons
        historyBtn.textContent = showingTodoHistory ? 'Current' : 'History';
        historyBtn.onclick = () => {
          showTodoHistory();
          // Update the purple header
          title.textContent = showingTodoHistory ? 'To-Do History' : 'To-Do List';
          historyBtn.textContent = showingTodoHistory ? 'Current' : 'History';
          // Update URL based on current mode
          updateURL(showingTodoHistory ? 'todo-history' : 'todo');
          
          // Rebuild the interface for the new mode
          rebuildFullscreenTodoInterface();
          renderTodoListFullscreen();
        };
        
        // Insert the buttons at the beginning of the button container
        buttonContainer.insertBefore(calendarBtn, homeButton);
        buttonContainer.insertBefore(historyBtn, homeButton);
        
        // Add appropriate input container based on mode
        const addContainer = document.createElement('div');
        addContainer.className = 'add-item-container';
        
        if (showingTodoHistory) {
          addContainer.innerHTML = `
            <div style="display: flex; flex-direction: column; gap: 1rem; margin-bottom: 1.5rem; max-width: 800px;">
              <div style="display: flex; gap: 1rem; align-items: center;">
                <input type="text" id="fullscreen-todo-search-input" placeholder="Search tasks..." maxlength="100" style="flex: 1;">
                <button onclick="clearTodoSearchFullscreen()" title="Clear all filters" style="padding: 0.7rem 1rem; background: var(--danger-color); color: white; border: none; border-radius: 8px; cursor: pointer; white-space: nowrap;">Clear All</button>
              </div>
              <div style="display: flex; gap: 1rem; align-items: center;">
                <label style="font-weight: 600; color: var(--text-primary); white-space: nowrap; min-width: 80px;">Date range:</label>
                <input type="date" id="fullscreen-todo-date-from" style="flex: 1;" title="From date">
                <span style="color: var(--text-secondary); font-weight: 500;">to</span>
                <input type="date" id="fullscreen-todo-date-to" style="flex: 1;" title="To date">
                <div style="display: flex; align-items: center; gap: 8px; margin-left: 1rem;">
                  <span class="fullscreen-avatar-filter emley" data-avatar="emley" onclick="toggleAvatarFilter('emley')" title="Filter by Emley">E</span>
                  <span class="fullscreen-avatar-filter nate" data-avatar="nate" onclick="toggleAvatarFilter('nate')" title="Filter by Nate">N</span>
                  <span class="fullscreen-avatar-filter family" data-avatar="family" onclick="toggleAvatarFilter('family')" title="Filter by Family">F</span>
                </div>
              </div>
            </div>
          `;
        } else {
          addContainer.innerHTML = `
            <input type="text" id="fullscreen-todo-input" placeholder="Add new task..." maxlength="100">
            <input type="date" id="fullscreen-todo-due-date" title="Due date (optional)">
            <button onclick="addTodoItemFullscreen()" id="fullscreen-add-todo-btn">Add</button>
          `;
        }
        
        content.appendChild(addContainer);
        
        // Add Sort button and assignment dropdown below the input (only for current todos, not history)
        if (!showingTodoHistory) {
          const sortButtonContainer = document.createElement('div');
          sortButtonContainer.style.cssText = `
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1rem;
            margin: 1rem 0;
          `;
          
          const sortBtn = document.createElement('button');
          sortBtn.textContent = 'Sort by Due Date';
          sortBtn.title = 'Sort by due date, then alphabetically';
          sortBtn.style.cssText = `
            padding: 8px 16px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s ease;
          `;
          
          sortBtn.onmouseover = () => {
            sortBtn.style.background = '#5a67d8';
          };
          
          sortBtn.onmouseout = () => {
            sortBtn.style.background = 'var(--primary-color)';
          };
          
          sortBtn.onclick = () => {
            sortTodosByDueDate();
          };
          
          // Create avatar filters
          const avatarFiltersContainer = document.createElement('div');
          avatarFiltersContainer.className = 'avatar-filters-container';
          avatarFiltersContainer.innerHTML = `
            <span class="fullscreen-avatar-filter emley" data-avatar="emley" onclick="toggleAvatarFilter('emley')" title="Filter by Emley">E</span>
            <span class="fullscreen-avatar-filter nate" data-avatar="nate" onclick="toggleAvatarFilter('nate')" title="Filter by Nate">N</span>
            <span class="fullscreen-avatar-filter family" data-avatar="family" onclick="toggleAvatarFilter('family')" title="Filter by Family">F</span>
          `;
          
          sortButtonContainer.appendChild(sortBtn);
          sortButtonContainer.appendChild(avatarFiltersContainer);
          content.appendChild(sortButtonContainer);
        }
        
        // Add task list
        const taskList = document.createElement('ul');
        taskList.id = 'fullscreen-todo-list';
        taskList.className = 'task-list';
        
        content.appendChild(taskList);
        
        // Render existing todos
        setTimeout(() => {
          renderTodoListFullscreen();
          
          if (showingTodoHistory) {
            // Add search functionality for history mode
            const searchInput = document.getElementById('fullscreen-todo-search-input');
            const dateFromInput = document.getElementById('fullscreen-todo-date-from');
            const dateToInput = document.getElementById('fullscreen-todo-date-to');
            
            if (searchInput) {
              searchInput.addEventListener('input', filterTodoHistoryFullscreen);
            }
            if (dateFromInput) {
              dateFromInput.addEventListener('change', filterTodoHistoryFullscreen);
            }
            if (dateToInput) {
              dateToInput.addEventListener('change', filterTodoHistoryFullscreen);
            }
          } else {
            // Add Enter key support for regular input
            const input = document.getElementById('fullscreen-todo-input');
            if (input) {
              input.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                  addTodoItemFullscreen();
                }
              });
            }
          }
        }, 100);
        
      } else if (widgetType === 'grocery') {
        title.textContent = 'Grocery List';
        title.onclick = closeFullscreen;
        title.style.cursor = 'pointer';
        
        // Add input container
        const addContainer = document.createElement('div');
        addContainer.className = 'add-item-container';
        addContainer.innerHTML = `
          <input type="text" id="fullscreen-grocery-input" placeholder="Add grocery item..." maxlength="100">
          <button onclick="addGroceryItemFullscreen()" id="fullscreen-add-grocery-btn">Add</button>
        `;
        
        // Add task list
        const taskList = document.createElement('ul');
        taskList.id = 'fullscreen-grocery-list';
        taskList.className = 'task-list';
        
        content.appendChild(addContainer);
        content.appendChild(taskList);
        
        // Render existing groceries
        setTimeout(() => {
          renderGroceryListFullscreen();
          
          // Add Enter key support
          document.getElementById('fullscreen-grocery-input').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
              addGroceryItemFullscreen();
            }
          });
        }, 100);
        
      } else if (widgetType === 'meals') {
        title.textContent = showingMealHistory ? 'Meals History' : 'Meals';
        title.onclick = closeFullscreen;
        title.style.cursor = 'pointer';
        
        // Add History/Current button to the left of Home button in header
        const historyBtn = document.createElement('button');
        historyBtn.className = 'back-button'; // Use same styling as other header buttons
        historyBtn.textContent = showingMealHistory ? 'Current' : 'History';
        historyBtn.onclick = () => {
          showMealsHistory();
          // Update the purple header
          title.textContent = showingMealHistory ? 'Meals History' : 'Meals';
          historyBtn.textContent = showingMealHistory ? 'Current' : 'History';
          // Update URL based on current mode
          updateURL(showingMealHistory ? 'meals-history' : 'meals');
          renderMealsListFullscreen();
        };
        
        // Insert the history button at the beginning of the button container
        buttonContainer.insertBefore(historyBtn, homeButton);
        
        // Add search bar for history mode
        if (showingMealHistory) {
          const searchContainer = document.createElement('div');
          searchContainer.className = 'add-item-container';
          searchContainer.style.marginBottom = '1rem';
          searchContainer.innerHTML = `
            <input type="text" id="fullscreen-meals-search" placeholder="Search meals..." maxlength="100">
            <button onclick="clearMealsSearch()" id="clear-search-btn" title="Clear search">✕</button>
          `;
          content.appendChild(searchContainer);
          
          // Add search functionality
          setTimeout(() => {
            const searchInput = document.getElementById('fullscreen-meals-search');
            if (searchInput) {
              searchInput.addEventListener('input', function(e) {
                filterMealsFullscreen(e.target.value);
              });
            }
          }, 100);
        }
        
        // Add input container
        const addContainer = document.createElement('div');
        addContainer.className = 'add-item-container';
        
        if (showingMealHistory) {
          addContainer.innerHTML = `
            <input type="text" id="fullscreen-meals-input" placeholder="Add to history only..." maxlength="100">
            <button onclick="addMealToHistoryOnlyFullscreen()" id="fullscreen-add-meals-btn">Add to History</button>
          `;
        } else {
          addContainer.innerHTML = `
            <input type="text" id="fullscreen-meals-input" placeholder="Add meal..." maxlength="100">
            <button onclick="addMealItemFullscreen()" id="fullscreen-add-meals-btn">Add</button>
          `;
        }
        content.appendChild(addContainer);
        
        // Add task list
        const taskList = document.createElement('ul');
        taskList.id = 'fullscreen-meals-list';
        taskList.className = 'task-list';
        content.appendChild(taskList);
        
        // Render existing meals
        setTimeout(() => {
          renderMealsListFullscreen();
          
          // Add Enter key support
          const input = document.getElementById('fullscreen-meals-input');
          if (input) {
            input.addEventListener('keypress', function(e) {
              if (e.key === 'Enter') {
                if (showingMealHistory) {
                  addMealToHistoryOnlyFullscreen();
                } else {
                  addMealItemFullscreen();
                }
              }
            });
          }
        }, 100);
      }
      
      fullscreenDiv.appendChild(fullscreenHeader);
      fullscreenDiv.appendChild(content);
      document.body.appendChild(fullscreenDiv);
      
      // Update URL based on widget type and current mode
      if (widgetType === 'todo') {
        updateURL(showingTodoHistory ? 'todo-history' : 'todo');
      } else if (widgetType === 'meals') {
        updateURL(showingMealHistory ? 'meals-history' : 'meals');
      } else {
        updateURL(widgetType); // grocery, calendar, etc.
      }
      
      // Start inactivity detection (desktop only)
      if (!window.pwaInfo?.isPWA) {
      setupInactivityDetection();
      }
    }

    function closeFullscreen() {
      const fullscreenContainer = document.getElementById('fullscreen-container');
      const main = document.querySelector('main');
      const header = document.querySelector('header');
      
      // Clean up inactivity detection
      cleanupInactivityDetection();
      
      if (fullscreenContainer) {
        fullscreenContainer.remove();
      }
      
      // Show main dashboard
      main.classList.remove('hidden');
      header.classList.remove('hidden');
      
      // Update URL to dashboard view
      updateURL('dashboard');
      
      // Re-render lists to sync any changes made in fullscreen
      renderTodoList();
      renderGroceryList();
      renderMealsList();
    }

    // Fullscreen todo functions
    function addTodoItemFullscreen() {
      const input = document.getElementById('fullscreen-todo-input');
      const dueDateInput = document.getElementById('fullscreen-todo-due-date');
      const text = input.value.trim();
      const dueDate = dueDateInput ? dueDateInput.value : null;
      
      if (text) {
        const item = {
          id: Date.now(),
          text: text,
          completed: false,
          createdAt: new Date().toISOString(),
          order: Date.now(),
          dueDate: dueDate || null,
          assignedTo: 'family' // Auto-assign to family by default
        };
        
        todoItems.unshift(item);
        updateItemOrders(todoItems);
        saveTodoItems();
        renderTodoListFullscreen();
        input.value = '';
        if (dueDateInput) dueDateInput.value = '';
      }
    }

    function renderTodoListFullscreen() {
      const list = document.getElementById('fullscreen-todo-list');
      if (!list) return;
      
      if (showingTodoHistory) {
        let filteredHistory = [...todoHistory];
        
        // Apply search filters
        if (currentTodoSearchTerm) {
          filteredHistory = fuzzySearchTodos(filteredHistory, currentTodoSearchTerm);
        }
        
        if (currentDateFrom || currentDateTo) {
          filteredHistory = filterTodosByDateRange(filteredHistory, currentDateFrom, currentDateTo);
        }
        
        // Apply avatar filters
        filteredHistory = filterTodosByAvatar(filteredHistory);
        
        if (filteredHistory.length === 0) {
          const emptyMessage = (currentTodoSearchTerm || currentDateFrom || currentDateTo || selectedAvatarFilters.length > 0) ? 
            'No tasks found matching your search criteria.' : 
            'No completed tasks yet.';
          list.innerHTML = `<li class="empty-state">${emptyMessage}</li>`;
          return;
        }
        
        const groups = groupTodosByDate(filteredHistory);
        list.innerHTML = renderTodoHistoryGrouped(groups);
        
        // Set up drag and drop for history items (within date groups only)
        setTimeout(() => setupTodoHistoryDragAndDrop(list, groups), 0);
      } else {
        // Only show uncompleted items (completed items are immediately moved to history)
        let activeItems = todoItems.filter(item => !item.completed);
        
        // Apply avatar filters
        activeItems = filterTodosByAvatar(activeItems);
        
        if (activeItems.length === 0) {
          const emptyMessage = selectedAvatarFilters.length > 0 ? 
            'No tasks found for selected filters.' : 
            'No tasks yet. Add one above!';
          list.innerHTML = `<li class="empty-state">${emptyMessage}</li>`;
          return;
        }
        
        // Sort by order and ensure all items have order property
        updateItemOrders(activeItems);
        activeItems = sortItemsByOrder(activeItems);
        
        list.innerHTML = activeItems.map(item => {
          const dueDateDisplay = item.dueDate ? formatDueDate(item.dueDate) : '';
          const isOverdue = item.dueDate && isTaskOverdue(item.dueDate);
          const isDueToday = item.dueDate && isTaskDueToday(item.dueDate);
          const isDueTomorrow = item.dueDate && isTaskDueTomorrow(item.dueDate);
          
          let dueDateClass = '';
          let taskItemClass = '';
          
          if (isOverdue) {
            dueDateClass = 'overdue';
            taskItemClass = 'overdue';
          } else if (isDueToday) {
            dueDateClass = 'due-today';
            taskItemClass = 'due-today';
          } else if (isDueTomorrow) {
            dueDateClass = 'due-tomorrow';
            taskItemClass = 'due-tomorrow';
          }
          
          const assignedTo = item.assignedTo || 'family'; // Default to family if not assigned
          const avatarHtml = `<span class="person-avatar ${assignedTo}" onclick="editTodoAssignment(${item.id})" title="Click to change assignment - Currently: ${assignedTo === 'emley' ? 'Emley' : assignedTo === 'nate' ? 'Nate' : 'Family'}" style="cursor: pointer;">${assignedTo === 'emley' ? 'E' : assignedTo === 'nate' ? 'N' : 'F'}</span>`;
          
          return `
            <li class="task-item ${taskItemClass}">
            <span class="drag-handle">☰</span>
            <input type="checkbox" class="task-checkbox" 
                   onchange="toggleTodoItem(${item.id}); renderTodoListFullscreen();">
              ${avatarHtml}
            <span class="task-text">${escapeHtml(item.text)}</span>
              ${dueDateDisplay ? `<span class="task-due-date ${dueDateClass}" onclick="editTodoDueDate(${item.id})" title="Click to edit due date">${dueDateDisplay}</span>` : ''}
            <div class="task-actions">
              <button class="edit-btn" onclick="editTodoItem(${item.id}); renderTodoListFullscreen();" title="Edit">✏️</button>
              <button class="delete-btn" onclick="deleteTodoItem(${item.id}); renderTodoListFullscreen();" title="Delete">🗑️</button>
            </div>
          </li>
          `;
        }).join('');
        
        // Set up drag and drop
        setTimeout(() => setupDragAndDrop(list, activeItems, 'todo'), 0);
      }
    }

    function filterTodoHistoryFullscreen() {
      const searchInput = document.getElementById('fullscreen-todo-search-input');
      const dateFromInput = document.getElementById('fullscreen-todo-date-from');
      const dateToInput = document.getElementById('fullscreen-todo-date-to');
      
      currentTodoSearchTerm = searchInput ? searchInput.value.toLowerCase().trim() : '';
      currentDateFrom = dateFromInput ? dateFromInput.value : '';
      currentDateTo = dateToInput ? dateToInput.value : '';
      
      renderTodoListFullscreen();
    }

    function clearTodoSearchFullscreen() {
      const searchInput = document.getElementById('fullscreen-todo-search-input');
      const dateFromInput = document.getElementById('fullscreen-todo-date-from');
      const dateToInput = document.getElementById('fullscreen-todo-date-to');
      
      if (searchInput) searchInput.value = '';
      if (dateFromInput) dateFromInput.value = '';
      if (dateToInput) dateToInput.value = '';
      
      currentTodoSearchTerm = '';
      currentDateFrom = '';
      currentDateTo = '';
      
      // Clear avatar filters
      selectedAvatarFilters = [];
      updateAvatarFilterButtons();
      
      renderTodoListFullscreen();
    }

    // Todo Calendar Functions (now handled by fullscreen system)

    function renderCalendarMonth(year, month, monthName, todosByDate) {
      const firstDay = new Date(year, month, 1);
      const lastDay = new Date(year, month + 1, 0);
      const startDate = new Date(firstDay);
      startDate.setDate(startDate.getDate() - firstDay.getDay()); // Start from Sunday
      
      const today = new Date().toISOString().split('T')[0];
      
      let monthHTML = `
        <div style="border: 1px solid #ddd; border-radius: 8px; overflow: hidden;">
          <div style="background: var(--primary-color); color: white; padding: 12px; text-align: center; font-weight: bold;">
            ${monthName}
          </div>
          <div style="display: grid; grid-template-columns: repeat(7, 1fr);">
      `;
      
      // Day headers
      const dayHeaders = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
      dayHeaders.forEach(day => {
        monthHTML += `<div style="padding: 8px; text-align: center; font-weight: bold; background: #f8f9fa; border-bottom: 1px solid #ddd;">${day}</div>`;
      });
      
      // Calendar days
      const currentDate = new Date(startDate);
      for (let week = 0; week < 6; week++) {
        for (let day = 0; day < 7; day++) {
          const dateStr = currentDate.toISOString().split('T')[0];
          const isCurrentMonth = currentDate.getMonth() === month;
          const isToday = dateStr === today;
          const todosForDate = todosByDate[dateStr] || [];
          
          let dayClass = 'calendar-day';
          let dayStyle = `
            padding: 8px 4px;
            min-height: 60px;
            border-bottom: 1px solid #eee;
            border-right: 1px solid #eee;
            position: relative;
            font-size: 12px;
          `;
          
          if (!isCurrentMonth) {
            dayStyle += 'color: #ccc; background: #f9f9f9;';
          } else if (isToday) {
            dayStyle += 'background: #e3f2fd; font-weight: bold;';
          }
          
          monthHTML += `<div class="${dayClass}" style="${dayStyle}">`;
          monthHTML += `<div style="font-weight: ${isToday ? 'bold' : 'normal'};">${currentDate.getDate()}</div>`;
          
          // Add todos for this date
          todosForDate.forEach(todo => {
            let todoStyle, todoIcon, tooltipSuffix;
            
            if (todo.type === 'completed') {
              // Completed tasks: Green
              todoStyle = 'background: #4caf50; color: white;';
              todoIcon = '✓';
              tooltipSuffix = '(Completed)';
            } else {
              // Due tasks: Check if overdue
              const taskDate = dateStr;
              const isOverdue = taskDate < today;
              
              if (isOverdue) {
                // Overdue tasks: Red
                todoStyle = 'background: #f44336; color: white;';
                todoIcon = '!';
                tooltipSuffix = '(Overdue)';
              } else {
                // Current/future due tasks: No special color (neutral gray)
                todoStyle = 'background: #757575; color: white;';
                todoIcon = '•';
                tooltipSuffix = '(Due)';
              }
            }
            
            // Determine the appropriate edit function based on todo type
            const editFunction = todo.type === 'completed' 
              ? `editTodoFromCalendar(${todo.id}, true)` // true for history item
              : `editTodoFromCalendar(${todo.id}, false)`; // false for current item
            
            monthHTML += `
              <div style="${todoStyle} padding: 2px 4px; margin: 1px 0; border-radius: 3px; font-size: 10px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; cursor: pointer;" 
                   title="Click to edit: ${escapeHtml(todo.text)} ${tooltipSuffix}"
                   onclick="${editFunction}">
                ${todoIcon} ${escapeHtml(todo.text.substring(0, 15))}${todo.text.length > 15 ? '...' : ''}
              </div>
            `;
          });
          
          monthHTML += '</div>';
          currentDate.setDate(currentDate.getDate() + 1);
        }
        
        // Break if we've gone past the current month
        if (currentDate.getMonth() !== month && week >= 4) break;
      }
      
      monthHTML += '</div></div>';
      return monthHTML;
    }

    // Calendar navigation state
    let calendarViewDate = new Date();

    function renderTodoCalendarFullscreen() {
      const container = document.getElementById('fullscreen-todo-calendar-container');
      if (!container) return;
      
      // Use the calendar view date (defaults to current date)
      const viewYear = calendarViewDate.getFullYear();
      const viewMonth = calendarViewDate.getMonth();
      
      // Show only the selected month
      const months = [{
        year: viewYear,
        month: viewMonth,
        name: calendarViewDate.toLocaleString('default', { month: 'long', year: 'numeric' })
      }];
      
      // Group todos by date - combine ALL data for comprehensive view
      const todosByDate = {};
      
      // Add completed todos from history on their completion date
      let filteredHistory = todoHistory.filter(todo => todo.completedAt);
      filteredHistory = filterCalendarTodosByAvatar(filteredHistory);
      
      filteredHistory.forEach(todo => {
        const completedDate = new Date(todo.completedAt).toISOString().split('T')[0];
        if (!todosByDate[completedDate]) todosByDate[completedDate] = [];
        todosByDate[completedDate].push({...todo, completed: true, type: 'completed'});
      });
      
      // Add uncompleted todos from current list with due dates on their due date
      let filteredCurrent = todoItems.filter(todo => !todo.completed && todo.dueDate);
      filteredCurrent = filterCalendarTodosByAvatar(filteredCurrent);
      
      filteredCurrent.forEach(todo => {
        if (!todosByDate[todo.dueDate]) todosByDate[todo.dueDate] = [];
        todosByDate[todo.dueDate].push({...todo, type: 'due'});
      });
      
        // Add navigation controls
        let calendarHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding: 0 10px;">
            <button onclick="navigateCalendar(-1)" style="
              background: var(--primary-color); 
              color: white; 
              border: none; 
              border-radius: 6px; 
              padding: 8px 16px; 
              cursor: pointer; 
              font-size: 14px;
              display: flex;
              align-items: center;
              gap: 5px;
            ">
              ← Previous Month
            </button>
            
            <div style="display: flex; align-items: center; gap: 10px;">
              <button onclick="navigateCalendar(0)" style="
                background: #6c757d; 
                color: white; 
                border: none; 
                border-radius: 6px; 
                padding: 8px 16px; 
                cursor: pointer; 
                font-size: 14px;
              ">
                Today
              </button>
              
              <div class="calendar-avatar-filters" style="display: flex; gap: 5px; margin-left: 10px;">
                <span class="calendar-avatar-filter emley" data-avatar="emley" onclick="toggleCalendarAvatarFilter('emley')" title="Filter by Emley" style="
                  width: 28px; height: 28px; border-radius: 50%; display: flex; align-items: center; justify-content: center; 
                  cursor: pointer; font-weight: bold; font-size: 12px; border: 2px solid transparent; transition: all 0.2s;
                  background: #e3f2fd; color: #1976d2;
                ">E</span>
                <span class="calendar-avatar-filter nate" data-avatar="nate" onclick="toggleCalendarAvatarFilter('nate')" title="Filter by Nate" style="
                  width: 28px; height: 28px; border-radius: 50%; display: flex; align-items: center; justify-content: center; 
                  cursor: pointer; font-weight: bold; font-size: 12px; border: 2px solid transparent; transition: all 0.2s;
                  background: #f3e5f5; color: #7b1fa2;
                ">N</span>
                <span class="calendar-avatar-filter family" data-avatar="family" onclick="toggleCalendarAvatarFilter('family')" title="Filter by Family" style="
                  width: 28px; height: 28px; border-radius: 50%; display: flex; align-items: center; justify-content: center; 
                  cursor: pointer; font-weight: bold; font-size: 12px; border: 2px solid transparent; transition: all 0.2s;
                  background: #e8f5e8; color: #388e3c;
                ">F</span>
              </div>
            </div>
            
            <button onclick="navigateCalendar(1)" style="
              background: var(--primary-color); 
              color: white; 
              border: none; 
              border-radius: 6px; 
              padding: 8px 16px; 
              cursor: pointer; 
              font-size: 14px;
              display: flex;
              align-items: center;
              gap: 5px;
            ">
              Next Month →
            </button>
          </div>
        `;
        
        // Render calendar month
        calendarHTML += '<div style="display: grid; grid-template-columns: 1fr; gap: 20px;">';
        
        months.forEach(monthInfo => {
          calendarHTML += renderCalendarMonth(monthInfo.year, monthInfo.month, monthInfo.name, todosByDate);
        });
        
        calendarHTML += '</div>';
        container.innerHTML = calendarHTML;
        
        // Update filter button appearance after rendering
        setTimeout(() => updateCalendarAvatarFilterButtons(), 0);
    }

    function navigateCalendar(direction) {
      if (direction === 0) {
        // Reset to current month
        calendarViewDate = new Date();
      } else {
        // Navigate to previous (-1) or next (1) month
        calendarViewDate.setMonth(calendarViewDate.getMonth() + direction);
      }
      
      // Re-render the calendar with the new date
      renderTodoCalendarFullscreen();
    }

    function editTodoFromCalendar(todoId, isHistoryItem) {
      if (isHistoryItem) {
        // For completed tasks, we need to re-add them to current list first
        // Find the history item
        const historyItem = todoHistory.find(item => item.id === todoId);
        if (!historyItem) {
          console.error('History item not found:', todoId);
          return;
        }
        
        // Re-add to current list (this will remove from history)
        reAddTodoFromHistory(todoId);
        
        // Find the newly created item in current list (it will have a new ID)
        // We need to find it by text since the ID changes
        const newItem = todoItems.find(item => 
          item.text === historyItem.text && 
          item.originalHistoryId === todoId
        );
        
        if (newItem) {
          // Open edit modal for the new current item
          setTimeout(() => editTodoItem(newItem.id), 100);
        }
      } else {
        // For current tasks, directly open the edit modal
        editTodoItem(todoId);
      }
    }

    // Calendar-specific avatar filtering
    let selectedCalendarAvatarFilters = [];

    function toggleCalendarAvatarFilter(avatar) {
      const index = selectedCalendarAvatarFilters.indexOf(avatar);
      if (index > -1) {
        // Remove filter if already selected
        selectedCalendarAvatarFilters.splice(index, 1);
      } else {
        // Add filter if not selected
        selectedCalendarAvatarFilters.push(avatar);
      }
      
      // Update filter button appearance
      updateCalendarAvatarFilterButtons();
      
      // Re-render the calendar with filters applied
      renderTodoCalendarFullscreen();
    }

    function updateCalendarAvatarFilterButtons() {
      const calendarFilters = document.querySelectorAll('.calendar-avatar-filter');
      calendarFilters.forEach(button => {
        const avatar = button.dataset.avatar;
        if (selectedCalendarAvatarFilters.includes(avatar)) {
          button.style.border = '2px solid var(--primary-color)';
          button.style.transform = 'scale(1.1)';
        } else {
          button.style.border = '2px solid transparent';
          button.style.transform = 'scale(1)';
        }
      });
    }

    function filterCalendarTodosByAvatar(items) {
      // If no filters selected, show all items
      if (selectedCalendarAvatarFilters.length === 0) {
        return items;
      }
      
      // Filter items based on selected avatars
      return items.filter(item => {
        const assignedTo = item.assignedTo || 'family'; // Default to family if not assigned
        return selectedCalendarAvatarFilters.includes(assignedTo);
      });
    }

    // Fullscreen grocery functions
    function addGroceryItemFullscreen() {
      const input = document.getElementById('fullscreen-grocery-input');
      const text = input.value.trim();
      
      if (text) {
        const item = {
          id: Date.now(),
          text: text,
          completed: false,
          createdAt: new Date().toISOString(),
          order: Date.now() // Add order property for sorting
        };
        
        groceryItems.unshift(item);
        updateItemOrders(groceryItems); // Update all orders
        saveGroceryItems();
        renderGroceryListFullscreen();
        input.value = '';
      }
    }

    function renderGroceryListFullscreen() {
      const list = document.getElementById('fullscreen-grocery-list');
      if (!list) return;
      
      if (groceryItems.length === 0) {
        list.innerHTML = '<li class="empty-state">No items yet. Add one above!</li>';
        return;
      }
      
      // Sort by order and ensure all items have order property
      updateItemOrders(groceryItems);
      const sortedItems = sortItemsByOrder([...groceryItems]);
      
      // Group items by category
      const groupedItems = groupGroceriesByCategory(sortedItems);
      
      // Define category order for logical shopping flow
      const categoryOrder = [
        'Produce',
        'Bakery', 
        'Deli',
        'Meat & Seafood',
        'Dairy',
        'Canned & Packaged Goods',
        'Spices',
        'Dry Goods & Baking',
        'Snacks & Candy',
        'Cereal & Breakfast',
        'Pasta, Rice & International Foods',
        'Frozen Foods',
        'Beverages',
        'Health & Beauty',
        'Cleaning & Household',
        'Pet Supplies',
        'Floral Department',
        'Pharmacy',
        'Other'
      ];
      
      let html = '';
      
      categoryOrder.forEach(category => {
        const items = groupedItems[category];
        if (items && items.length > 0) {
          // Add category header as drop zone
          html += `<li class="category-header" 
                      data-category="${category}"
                      style="
            font-weight: bold; 
            color: var(--primary-color); 
            background: #f8f9fa; 
            padding: 8px 12px; 
            margin: 8px 0 4px 0; 
            border-radius: 4px;
            list-style: none;
            border-left: 4px solid var(--primary-color);
            cursor: pointer;
          ">${category}</li>`;
          
          // Add items in this category
          items.forEach(item => {
            const recipeSource = item.recipeSource ? `<div class="recipe-source" style="font-size: 0.8em; color: #666; margin-top: 2px;">For: ${escapeHtml(item.recipeSource)}</div>` : '';
            const optionalIndicator = item.isOptional ? ' <span style="color: #999; font-size: 0.8em;">(optional)</span>' : '';
            
            html += `
              <li class="task-item" data-item-id="${item.id}">
          <span class="drag-handle">☰</span>
          <input type="checkbox" class="task-checkbox" 
                 ${item.completed ? 'checked' : ''} 
                 onchange="toggleGroceryItem(${item.id}); renderGroceryListFullscreen();">
                <div style="flex: 1;">
                  <span class="task-text ${item.completed ? 'completed' : ''}">${escapeHtml(item.text)}${optionalIndicator}</span>
                  ${recipeSource}
                </div>
          <div class="task-actions">
            <button class="edit-btn" onclick="editGroceryItem(${item.id}); renderGroceryListFullscreen();" title="Edit">✏️</button>
            <button class="delete-btn" onclick="deleteGroceryItem(${item.id}); renderGroceryListFullscreen();" title="Delete">🗑️</button>
          </div>
        </li>
            `;
          });
        }
      });
      
      list.innerHTML = html;
      
      // Set up enhanced drag and drop for categorized grocery lists
      setTimeout(() => setupGroceryDragAndDrop(list), 0);
    }

    // Optional: Auto-save feature and data export/import for sharing between devices
    function exportData() {
      const data = {
        todoItems: todoItems,
        groceryItems: groceryItems,
        exportDate: new Date().toISOString()
      };
      
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'smart-dashboard-lists.json';
      a.click();
      URL.revokeObjectURL(url);
    }

    function importData(event) {
      const file = event.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = function(e) {
          try {
            const data = JSON.parse(e.target.result);
            if (data.todoItems && data.groceryItems) {
              todoItems = data.todoItems;
              groceryItems = data.groceryItems;
              saveTodoItems();
              saveGroceryItems();
              renderTodoList();
              renderGroceryList();
              alert('Data imported successfully!');
            }
          } catch (err) {
            alert('Error importing data. Please check the file format.');
          }
        };
        reader.readAsText(file);
      }
    }
    // URL Management Functions
    function updateURL(view) {
      const url = new URL(window.location);
      if (view === 'home') {
        url.searchParams.delete('view');
      } else {
        url.searchParams.set('view', view);
      }
      window.history.pushState({}, '', url);
    }

    // Navigation Functions
    function showLandingPage() {
      document.getElementById('landing-page').style.display = 'flex';
      document.getElementById('dashboard').style.display = 'none';
      closeFullscreen();
      updateURL('home');
    }

    function showDashboard() {
      document.getElementById('landing-page').style.display = 'none';
      document.getElementById('dashboard').style.display = 'block';
      
      // Apply PWA-specific dashboard layout if in PWA mode
      if (window.pwaInfo?.isPWA) {
        applyPWADashboardLayout();
      }
      
      updateURL('dashboard');
    }

    function showFullscreenCalendar() {
      document.getElementById('landing-page').style.display = 'none';
      document.getElementById('dashboard').style.display = 'block';
      openFullscreen('calendar');
      updateURL('calendar');
    }

    function showFullscreenTodo() {
      document.getElementById('landing-page').style.display = 'none';
      document.getElementById('dashboard').style.display = 'block';
      openFullscreen('todo');
      updateURL('todo');
    }

    function showFullscreenTodoHistory() {
      document.getElementById('landing-page').style.display = 'none';
      document.getElementById('dashboard').style.display = 'block';
      showingTodoHistory = true;
      openFullscreen('todo');
      updateURL('todo-history');
    }

    function showFullscreenTodoCalendar() {
      // Reset calendar to current month when opening
      calendarViewDate = new Date();
      document.getElementById('landing-page').style.display = 'none';
      document.getElementById('dashboard').style.display = 'block';
      openFullscreen('todo-calendar');
      updateURL('todo-calendar');
    }

    function showFullscreenGrocery() {
      document.getElementById('landing-page').style.display = 'none';
      document.getElementById('dashboard').style.display = 'block';
      openFullscreen('grocery');
      updateURL('grocery');
    }

    function showFullscreenMeals() {
      document.getElementById('landing-page').style.display = 'none';
      document.getElementById('dashboard').style.display = 'block';
      openFullscreen('meals');
      updateURL('meals');
    }

    function showFullscreenMealsHistory() {
      document.getElementById('landing-page').style.display = 'none';
      document.getElementById('dashboard').style.display = 'block';
      showingMealHistory = true;
      
      // Update button text to reflect current state
      updateMealsButtonState();
      
      openFullscreen('meals');
      updateURL('meals-history');
    }

    function updateMealsButtonState() {
      const historyButton = document.querySelector('.meals-widget .history-button');
      const headerTitle = document.querySelector('.meals-widget h2');
      
      if (historyButton && headerTitle) {
        historyButton.textContent = showingMealHistory ? 'Current' : 'History';
        headerTitle.textContent = showingMealHistory ? 'Meals History' : 'Meals';
      }
    }

    // URL parameter handling
    function handleURLParameters() {
      const urlParams = new URLSearchParams(window.location.search);
      const view = urlParams.get('view');
      
      switch(view) {
        case 'dashboard':
          // Show dashboard without updating URL (already in URL)
          document.getElementById('landing-page').style.display = 'none';
          document.getElementById('dashboard').style.display = 'block';
          break;
        case 'calendar':
          // Show fullscreen calendar without updating URL
          document.getElementById('landing-page').style.display = 'none';
          document.getElementById('dashboard').style.display = 'block';
          openFullscreen('calendar');
          break;
        case 'todo':
          // Show fullscreen todo without updating URL
          document.getElementById('landing-page').style.display = 'none';
          document.getElementById('dashboard').style.display = 'block';
          openFullscreen('todo');
          break;
        case 'todo-history':
          // Show fullscreen todo history without updating URL
          document.getElementById('landing-page').style.display = 'none';
          document.getElementById('dashboard').style.display = 'block';
          showingTodoHistory = true;
          openFullscreen('todo');
          break;
        case 'todo-calendar':
          // Show fullscreen todo calendar without updating URL
          document.getElementById('landing-page').style.display = 'none';
          document.getElementById('dashboard').style.display = 'block';
          openFullscreen('todo-calendar');
          break;
        case 'grocery':
          // Show fullscreen grocery without updating URL
          document.getElementById('landing-page').style.display = 'none';
          document.getElementById('dashboard').style.display = 'block';
          openFullscreen('grocery');
          break;
        case 'meals':
          // Show fullscreen meals without updating URL
          document.getElementById('landing-page').style.display = 'none';
          document.getElementById('dashboard').style.display = 'block';
          openFullscreen('meals');
          break;
        case 'meals-history':
          // Show fullscreen meals history without updating URL
          document.getElementById('landing-page').style.display = 'none';
          document.getElementById('dashboard').style.display = 'block';
          showingMealHistory = true;
          updateMealsButtonState();
          openFullscreen('meals');
          break;
        case 'home':
        case null:
        case undefined:
        default:
          // Landing page is already shown by default
          document.getElementById('landing-page').style.display = 'flex';
          document.getElementById('dashboard').style.display = 'none';
          break;
      }
    }

    // URL parameters are now handled in the main DOMContentLoaded event above

    // Handle browser back/forward buttons
    window.addEventListener('popstate', async function(event) {
      // Ensure data is loaded before handling URL parameters
      if (!todoItems || !groceryItems || !mealItems) {
        console.log('🔄 Data not loaded, loading before handling URL...');
        await loadAllData();
      }
      handleURLParameters();
    });

  </script>

  <!-- PWA Update Notification Function -->
  <script>
    // Force app update manually
    function forceAppUpdate() {
      console.log('🔄 Force updating PWA (same as console command)...');
      
      if ('serviceWorker' in navigator) {
        navigator.serviceWorker.getRegistrations().then(registrations => {
          console.log('📋 Found', registrations.length, 'service worker registrations to unregister');
          
          // Unregister all service workers
          registrations.forEach(registration => {
            registration.unregister();
            console.log('🗑️ Unregistered:', registration.scope);
          });
          
          // Clear all caches
          caches.keys().then(cacheNames => {
            console.log('🧹 Clearing caches:', cacheNames);
            return Promise.all(
              cacheNames.map(cacheName => caches.delete(cacheName))
            );
          }).then(() => {
            console.log('✅ All caches cleared');
            showUpdateNotification();
            
            // Force reload with cache bypass (same as console command)
            setTimeout(() => {
              console.log('🔄 Reloading with cache bypass...');
              window.location.href = window.location.href + '?force=' + Date.now();
            }, 1000); // Small delay to show notification
          }).catch(error => {
            console.log('❌ Failed to clear caches:', error);
            // Fallback: just reload
            window.location.reload();
          });
        }).catch(error => {
          console.log('❌ Failed to get service worker registrations:', error);
          // Fallback: just reload
          window.location.reload();
        });
      } else {
        console.log('🔄 Service worker not available, doing simple reload');
        window.location.reload();
      }
    }

    // Show debug panel for PWA troubleshooting
    function showDebugPanel() {
      const panel = document.createElement('div');
      panel.id = 'debug-panel';
      panel.style.cssText = `
        position: fixed;
        top: 50px;
        left: 10px;
        right: 10px;
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 15px;
        border-radius: 10px;
        z-index: 10004;
        font-family: monospace;
        font-size: 12px;
        max-height: 70vh;
        overflow-y: auto;
      `;
      
      const logs = [];
      const originalLog = console.log;
      
      // Capture console logs
      console.log = function(...args) {
        logs.push(args.join(' '));
        if (logs.length > 50) logs.shift(); // Keep last 50 logs
        updateDebugPanel();
        originalLog.apply(console, args);
      };
      
      function updateDebugPanel() {
        if (document.getElementById('debug-panel')) {
          panel.innerHTML = `
            <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
              <strong>🔍 PWA Debug Console</strong>
              <button onclick="document.body.removeChild(document.getElementById('debug-panel')); console.log = originalLog;" 
                      style="background: #f44336; color: white; border: none; padding: 5px 10px; border-radius: 5px;">Close</button>
            </div>
            <div style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; max-height: 300px; overflow-y: auto;">
              ${logs.map(log => `<div>${log}</div>`).join('')}
            </div>
            <div style="margin-top: 10px;">
              <button onclick="forceAppUpdate()" style="background: #4caf50; color: white; border: none; padding: 10px; border-radius: 5px; margin-right: 10px;">Force Update</button>
              <button onclick="window.location.reload()" style="background: #2196f3; color: white; border: none; padding: 10px; border-radius: 5px;">Reload</button>
            </div>
          `;
        }
      }
      
      document.body.appendChild(panel);
      updateDebugPanel();
      
      // Store original log function globally
      window.originalLog = originalLog;
    }

    // Show update notification for PWA
    function showUpdateNotification() {
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: linear-gradient(135deg, #4caf50, #66bb6a);
        color: white;
        padding: 12px 20px;
        border-radius: 25px;
        font-size: 14px;
        font-weight: 500;
        z-index: 10003;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        animation: slideDown 0.3s ease;
      `;
      notification.textContent = '🔄 Updating app...';
      
      // Add animation
      const style = document.createElement('style');
      style.textContent = `
        @keyframes slideDown {
          from { transform: translateX(-50%) translateY(-100%); opacity: 0; }
          to { transform: translateX(-50%) translateY(0); opacity: 1; }
        }
      `;
      document.head.appendChild(style);
      document.body.appendChild(notification);
      
      // Remove after animation
      setTimeout(() => {
        if (document.body.contains(notification)) {
          document.body.removeChild(notification);
        }
      }, 800);
    }
  </script>

  <!-- PWA Service Worker Registration -->
  <script>
    // Register service worker for PWA functionality
    // Check if running in PWA mode before registering service worker
    const isPWAMode = window.matchMedia('(display-mode: standalone)').matches || 
                      window.navigator.standalone === true;
    
    if ('serviceWorker' in navigator && isPWAMode) {
      console.log('🔧 Service Worker: Registering for PWA mode only');
      window.addEventListener('load', () => {
        navigator.serviceWorker.register(`/smart-dashboard/sw.js?v=${Date.now()}`)
          .then((registration) => {
            console.log('PWA: Service Worker registered successfully:', registration.scope);
            
            // Check for updates immediately and every 10 seconds for PWA
            window.checkForUpdates = () => {
              console.log('🔄 PWA: Checking for updates...', new Date().toLocaleTimeString());
              console.log('🔍 PWA: Update check triggered by interval ID:', window.updateIntervalId);
              
              // Force update by re-registering with cache-busting timestamp
              const swUrl = `/smart-dashboard/sw.js?v=${Date.now()}`;
              console.log('🔄 PWA: Force-registering SW with cache-busting:', swUrl);
              
              navigator.serviceWorker.register(swUrl).then(newRegistration => {
                console.log('✅ PWA: Cache-busted registration completed');
                console.log('📊 Registration comparison:', {
                  'original': registration.scope,
                  'new': newRegistration.scope,
                  'same': newRegistration === registration
                });
                
                // Check the new registration state
                if (newRegistration.waiting) {
                  console.log('⚠️ PWA: New service worker is waiting to activate');
                  // Force activation
                  newRegistration.waiting.postMessage({type: 'SKIP_WAITING'});
                }
                if (newRegistration.installing) {
                  console.log('📦 PWA: New service worker is installing');
                  const installingWorker = newRegistration.installing;
                  // Wait for it to install and then activate
                  installingWorker.addEventListener('statechange', () => {
                    if (installingWorker.state === 'installed') {
                      console.log('🎯 PWA: New service worker installed');
                    }
                  });
                }
                if (newRegistration.active && newRegistration !== registration) {
                  console.log('🔄 PWA: New service worker activated - RELOAD DISABLED');
                  // window.location.reload(); // DISABLED TO PREVENT LOOP
                }
                
                // DISABLED: Force reload after 2 seconds - CAUSING LOOP
                // setTimeout(() => {
                //   console.log('⏰ PWA: Force reload after timeout');
                //   window.location.reload();
                // }, 2000);
              }).catch(error => {
                console.log('❌ PWA: Cache-busted update failed:', error);
                // Fallback to regular update
                registration.update().then(() => {
                  console.log('✅ PWA: Fallback update check completed');
                }).catch(fallbackError => {
                  console.log('❌ PWA: Fallback update also failed:', fallbackError);
                });
              });
            };
            
            // DISABLED: Aggressive update checking causing refresh loop
            // window.checkForUpdates();
            
            // DISABLED: Auto-update interval to prevent refresh loop
            // Set up automatic update checking with safeguards
            const isPWA = window.matchMedia('(display-mode: standalone)').matches || 
                         window.navigator.standalone === true;
            const updateInterval = isPWA ? 30000 : 60000; // 30s for PWA, 60s for browser
            
            // Create a function to start auto-updates (can be called manually)
            window.startAutoUpdates = () => {
              console.log('🚀 PWA: Starting auto-update system...');
              console.log('📊 PWA Detection:', {
                isPWA: isPWA,
                updateInterval: updateInterval,
                checkForUpdatesExists: typeof window.checkForUpdates
              });
              
              // Clear any existing interval first
              if (window.updateIntervalId) {
                clearInterval(window.updateIntervalId);
                console.log('🧹 PWA: Cleared existing interval');
              }
              
              if (typeof window.checkForUpdates === 'function') {
                window.updateIntervalId = setInterval(window.checkForUpdates, updateInterval);
                console.log('✅ PWA: Auto-update enabled with', updateInterval/1000, 'second interval');
                console.log('🔍 PWA: Interval ID:', window.updateIntervalId);
                
                // Test the function immediately
                console.log('🧪 PWA: Testing checkForUpdates function...');
                window.checkForUpdates();
              } else {
                console.error('❌ PWA: checkForUpdates function not found!');
              }
            };
            
            // Add safeguard: only start auto-updates after initial load
            console.log('⏰ PWA: Setting 5-second timeout for auto-update startup...');
            setTimeout(() => {
              console.log('⏰ PWA: 5-second timeout triggered, starting auto-updates...');
              window.startAutoUpdates();
            }, 5000); // Wait 5 seconds before starting auto-updates
            
            // Handle updates
            registration.addEventListener('updatefound', () => {
              const newWorker = registration.installing;
              console.log('PWA: New service worker found, installing...');
              
              newWorker.addEventListener('statechange', () => {
                if (newWorker.state === 'installed') {
                  if (navigator.serviceWorker.controller) {
                    console.log('PWA: New content available, reloading...');
                    
                    // Show update notification for PWA
                    const isPWAForUpdate = window.matchMedia('(display-mode: standalone)').matches || 
                                          window.navigator.standalone === true;
                    if (isPWAForUpdate) {
                      showUpdateNotification();
                      
                      // Clear the update interval to prevent multiple reloads
                      if (window.updateIntervalId) {
                        clearInterval(window.updateIntervalId);
                        console.log('🛑 PWA: Cleared update interval before reload');
                      }
                      
                      // DISABLED: Delay reload - CAUSING REFRESH LOOP
                      // setTimeout(() => {
                      //   console.log('🔄 PWA: Reloading for update...');
                      //   window.location.reload();
                      // }, 2000);
                    } else {
                      // DISABLED: Immediate reload - CAUSING LOOP
                      // window.location.reload();
                    }
                  } else {
                    console.log('PWA: Content cached for offline use');
                  }
                }
              });
            });
            
            // Handle controller change (new service worker activated)
            navigator.serviceWorker.addEventListener('controllerchange', () => {
              console.log('PWA: New service worker activated');
              
              // Clear any existing update intervals to prevent loops
              if (window.updateIntervalId) {
                clearInterval(window.updateIntervalId);
                console.log('🛑 PWA: Cleared update interval on controller change');
              }
              
              // Update version indicator
              if (window.updatePWAVersionIndicator) {
                window.updatePWAVersionIndicator();
              }
              
              console.log('🔄 PWA: New controller activated - RELOAD DISABLED');
              // window.location.reload(); // DISABLED TO PREVENT REFRESH LOOP
            });
          })
          .catch((error) => {
            console.log('PWA: Service Worker registration failed:', error);
          });
      });
    } else if ('serviceWorker' in navigator && !isPWAMode) {
      console.log('🌐 Desktop Browser: Service Worker disabled to prevent refresh loops');
      console.log('💡 Desktop users can manually refresh with Ctrl+R or F5');
    } else {
      console.log('❌ Service Worker not supported in this browser');
    }

    // PWA Install Prompt
    let deferredPrompt;
    let installButton;

    window.addEventListener('beforeinstallprompt', (e) => {
      console.log('PWA: Install prompt available');
      // Prevent the mini-infobar from appearing on mobile
      e.preventDefault();
      // Stash the event so it can be triggered later
      deferredPrompt = e;
      // Show install button
      showInstallButton();
    });

    window.addEventListener('appinstalled', (evt) => {
      console.log('PWA: App was installed');
      hideInstallButton();
    });

    function showInstallButton() {
      // Create install button if it doesn't exist
      if (!installButton) {
        installButton = document.createElement('button');
        installButton.textContent = '📱 Install App';
        installButton.style.cssText = `
          position: fixed;
          bottom: 20px;
          right: 20px;
          background: #1976d2;
          color: white;
          border: none;
          padding: 12px 16px;
          border-radius: 8px;
          font-size: 14px;
          font-weight: 500;
          cursor: pointer;
          box-shadow: 0 4px 8px rgba(0,0,0,0.2);
          z-index: 1000;
          font-family: 'Inter', sans-serif;
          transition: all 0.3s ease;
        `;
        
        installButton.addEventListener('mouseover', () => {
          installButton.style.background = '#1565c0';
          installButton.style.transform = 'translateY(-2px)';
        });
        
        installButton.addEventListener('mouseout', () => {
          installButton.style.background = '#1976d2';
          installButton.style.transform = 'translateY(0)';
        });
        
        installButton.addEventListener('click', async () => {
          if (deferredPrompt) {
            // Show the install prompt
            deferredPrompt.prompt();
            // Wait for the user to respond to the prompt
            const { outcome } = await deferredPrompt.userChoice;
            console.log(`PWA: User response to install prompt: ${outcome}`);
            // Clear the deferredPrompt
            deferredPrompt = null;
            hideInstallButton();
          }
        });
        
        document.body.appendChild(installButton);
      }
      
      installButton.style.display = 'block';
    }

    function hideInstallButton() {
      if (installButton) {
        installButton.style.display = 'none';
      }
    }

    // Hide install button if already installed (standalone mode)
    if (window.matchMedia('(display-mode: standalone)').matches) {
      console.log('PWA: App is running in standalone mode');
      hideInstallButton();
    }

    // PWA Detection and Customization
    function detectPWAMode() {
      const isStandalone = window.matchMedia('(display-mode: standalone)').matches;
      const isIOSStandalone = window.navigator.standalone === true;
      const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      const isTablet = /iPad|Android(?!.*Mobile)/i.test(navigator.userAgent);
      
      return {
        isPWA: isStandalone || isIOSStandalone,
        isStandalone: isStandalone,
        isIOSStandalone: isIOSStandalone,
        isMobile: isMobile,
        isTablet: isTablet,
        isDesktop: !isMobile && !isTablet,
        displayMode: isStandalone ? 'standalone' : 'browser'
      };
    }

    // Apply PWA-specific customizations
    function applyPWACustomizations() {
      const pwaInfo = detectPWAMode();
      console.log('PWA Detection:', pwaInfo);
      
      // Add CSS classes for different modes
      document.body.classList.add(pwaInfo.isPWA ? 'pwa-mode' : 'browser-mode');
      document.body.classList.add(pwaInfo.isMobile ? 'mobile-device' : 'desktop-device');
      document.body.classList.add(`display-${pwaInfo.displayMode}`);
      
      // Store PWA info globally for other functions to use
      window.pwaInfo = pwaInfo;
      
      if (pwaInfo.isPWA) {
        console.log('🚀 Running as PWA - Applying app-specific features');
        enablePWAFeatures();
      } else {
        console.log('🌐 Running in browser - Standard web experience');
        enableBrowserFeatures();
      }
    }

    // PWA-specific features (layout customizations disabled, but keep essential features)
    function enablePWAFeatures() {
      console.log('PWA features: keeping essential features, layout customizations disabled');
      
      // Hide desktop version indicator for PWA
      const desktopVersionIndicator = document.getElementById('desktop-version-indicator');
      if (desktopVersionIndicator) {
        desktopVersionIndicator.style.display = 'none';
      }
      
      // Keep essential features that don't break layout
      addHapticFeedback();
      addSwipeGestures(); // This includes pull-to-refresh with visual feedback
      addPWAStatusBarFix(); // Fix for iOS status bar white banner
      addPWAVersionIndicator(); // Add version indicator for debugging and manual updates
      addPWAGroceryIconFix(); // Force correct grocery icon positioning via JavaScript
      addPWACalendarOptimizations(); // Optimize calendar for mobile touch interface
      // addMobileOptimizations(); // DISABLED - this was breaking layout
      // addAppSpecificUI(); // DISABLED - this was adding unwanted UI elements
    }

    // Force correct PWA grocery icon positioning via JavaScript
    function addPWAGroceryIconFix() {
      // Wait for DOM to be ready, then apply correct positioning
      setTimeout(() => {
        const apple = document.querySelector('.nav-button:nth-child(6) .nav-icon .emoji-overlay');
        const baguette = document.querySelector('.nav-button:nth-child(6) .nav-icon .emoji-base');
        
        if (apple) {
          apple.style.setProperty('left', '9px', 'important');
          apple.style.setProperty('top', '31%', 'important');
          apple.style.setProperty('font-size', '1.0rem', 'important');
          console.log('✅ PWA: Applied correct apple positioning via JavaScript');
        }
        
        if (baguette) {
          baguette.style.setProperty('right', '4px', 'important');
          baguette.style.setProperty('top', '27%', 'important');
          baguette.style.setProperty('font-size', '1.4rem', 'important');
          console.log('✅ PWA: Applied correct baguette positioning via JavaScript');
        }
      }, 500); // Wait 500ms for elements to be ready
    }

    // PWA Simplified Dashboard Layout
    function applyPWADashboardLayout() {
      const main = document.querySelector('main');
      const header = document.querySelector('header');
      
      if (!main || !header) return;
      
      // Hide the main widget area and modify header for PWA
      main.style.display = 'none';
      
      // Create simplified PWA dashboard content
      let pwaDashboard = document.getElementById('pwa-dashboard');
      if (!pwaDashboard) {
        pwaDashboard = document.createElement('div');
        pwaDashboard.id = 'pwa-dashboard';
        pwaDashboard.style.cssText = `
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          flex: 1;
          padding: 2rem;
          text-align: center;
          gap: 2rem;
        `;
        
        // Create large info display
        pwaDashboard.innerHTML = `
          <div style="
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            background: rgba(255, 255, 255, 0.1);
            padding: 2rem;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            min-width: 300px;
          ">
            <div style="font-size: 1.5rem; font-weight: 600; color: white;">
              <span id="pwa-current-date">Loading...</span>
            </div>
            <div style="font-size: 3rem; font-weight: 300; color: white;">
              <span id="pwa-current-time">Loading...</span>
            </div>
            <div style="display: flex; align-items: center; justify-content: center; gap: 1rem; font-size: 1.25rem;">
              <span id="pwa-weather-icon" style="font-size: 2rem;">🌡️</span>
              <span id="pwa-current-temp" style="color: white; font-weight: 500;">Loading...</span>
            </div>
            <div id="pwa-precipitation-info" style="display: none; font-size: 1rem; color: rgba(255,255,255,0.9);">
              <span id="pwa-precip-icon" style="margin-right: 0.5rem;">💧</span>
              <span id="pwa-precip-details">--</span>
            </div>
          </div>
          
          <button onclick="showLandingPage()" style="
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 12px;
            padding: 16px 32px;
            font-size: 1.1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            min-height: 48px;
          ">
            🏠 Home
          </button>
        `;
        
        document.getElementById('dashboard').appendChild(pwaDashboard);
      }
      
      pwaDashboard.style.display = 'flex';
      
      // Update PWA dashboard with current data
      updatePWADashboardData();
      
      // Hide header info items (keep just title)
      const headerInfo = document.querySelector('.header-info');
      if (headerInfo) {
        headerInfo.style.display = 'none';
      }
      
      // Hide home button in header for PWA
      const homeButton = document.querySelector('.home-button');
      if (homeButton) {
        homeButton.style.display = 'none';
      }
      
      console.log('✅ PWA: Applied simplified dashboard layout');
    }
    
    // Update PWA dashboard with current header data
    function updatePWADashboardData() {
      // Copy date
      const sourceDate = document.getElementById('current-date');
      const targetDate = document.getElementById('pwa-current-date');
      if (sourceDate && targetDate) {
        targetDate.textContent = sourceDate.textContent;
      }
      
      // Copy time
      const sourceTime = document.getElementById('current-time');
      const targetTime = document.getElementById('pwa-current-time');
      if (sourceTime && targetTime) {
        targetTime.textContent = sourceTime.textContent;
      }
      
      // Copy weather
      const sourceTemp = document.getElementById('current-temp');
      const targetTemp = document.getElementById('pwa-current-temp');
      const sourceWeatherIcon = document.getElementById('weather-icon');
      const targetWeatherIcon = document.getElementById('pwa-weather-icon');
      
      if (sourceTemp && targetTemp) {
        targetTemp.textContent = sourceTemp.textContent;
      }
      if (sourceWeatherIcon && targetWeatherIcon) {
        targetWeatherIcon.textContent = sourceWeatherIcon.textContent;
      }
      
      // Copy precipitation
      const sourcePrecipInfo = document.getElementById('precipitation-info');
      const targetPrecipInfo = document.getElementById('pwa-precipitation-info');
      const sourcePrecipIcon = document.getElementById('precip-icon');
      const targetPrecipIcon = document.getElementById('pwa-precip-icon');
      const sourcePrecipDetails = document.getElementById('precip-details');
      const targetPrecipDetails = document.getElementById('pwa-precip-details');
      
      if (sourcePrecipInfo && targetPrecipInfo) {
        if (sourcePrecipInfo.style.display !== 'none') {
          targetPrecipInfo.style.display = 'block';
          if (sourcePrecipIcon && targetPrecipIcon) {
            targetPrecipIcon.textContent = sourcePrecipIcon.textContent;
          }
          if (sourcePrecipDetails && targetPrecipDetails) {
            targetPrecipDetails.textContent = sourcePrecipDetails.textContent;
          }
        } else {
          targetPrecipInfo.style.display = 'none';
        }
      }
    }

    // PWA Calendar Optimizations for Mobile Touch Interface
    function addPWACalendarOptimizations() {
      const style = document.createElement('style');
      style.id = 'pwa-calendar-optimizations';
      style.textContent = `
        /* PWA Calendar Mobile Optimizations */
        body.pwa-mode .calendar-day {
          min-height: 80px !important; /* Increased from 60px */
          padding: 12px 8px !important; /* Increased from 8px 4px */
          font-size: 14px !important; /* Increased from 12px */
        }
        
        /* Calendar todo items - larger touch targets */
        body.pwa-mode .calendar-day > div[onclick] {
          font-size: 12px !important; /* Increased from 10px */
          padding: 6px 8px !important; /* Increased from 2px 4px */
          margin: 3px 0 !important; /* Increased from 1px 0 */
          min-height: 32px !important; /* Minimum touch target */
          display: flex !important;
          align-items: center !important;
          line-height: 1.2 !important;
        }
        
        /* Calendar navigation buttons - larger for touch */
        body.pwa-mode button[onclick*="navigateCalendar"] {
          padding: 12px 20px !important; /* Increased from 8px 16px */
          font-size: 16px !important; /* Increased from 14px */
          min-height: 48px !important; /* Standard touch target */
        }
        
        /* Calendar avatar filter buttons - larger for touch */
        body.pwa-mode .calendar-avatar-filter {
          width: 36px !important; /* Increased from 28px */
          height: 36px !important; /* Increased from 28px */
          font-size: 14px !important; /* Increased from 12px */
          margin: 0 4px !important; /* Add spacing */
        }
        
        /* Calendar header - better mobile spacing */
        body.pwa-mode .calendar-day:first-child {
          font-size: 16px !important; /* Day headers larger */
          padding: 12px !important;
          font-weight: bold !important;
        }
        
        /* Calendar month title - larger for mobile */
        body.pwa-mode div[style*="font-size: 18px"] {
          font-size: 22px !important;
          padding: 16px !important;
        }
      `;
      document.head.appendChild(style);
      console.log('✅ PWA: Calendar optimizations applied for mobile touch interface');
    }

    // Browser-specific features  
    function enableBrowserFeatures() {
      // Add browser-specific features
      addDesktopOptimizations();
      addKeyboardShortcuts();
      addBrowserSpecificUI();
    }

    // Mobile/PWA optimizations
    function addMobileOptimizations() {
      // Larger touch targets for mobile
      const style = document.createElement('style');
      style.textContent = `
        .pwa-mode button {
          min-height: 44px !important;
          min-width: 44px !important;
          padding: 12px 16px !important;
        }
        
        .pwa-mode .nav-button {
          padding: 20px !important;
          margin: 8px !important;
        }
        
        /* Ensure grocery icon looks identical in PWA mode - MAXIMUM SPECIFICITY */
        body.pwa-mode.mobile-device.display-standalone .nav-button:nth-child(6) .nav-icon {
          position: relative !important;
          display: inline-block !important;
          width: 50px !important;
          height: 50px !important;
          display: flex !important;
          align-items: center !important;
          justify-content: center !important;
          margin: 0 auto !important;
          font-size: 2rem !important;
          background: transparent !important;
        }
        
        body.pwa-mode.mobile-device.display-standalone .nav-button:nth-child(6) .nav-icon .emoji-basket {
          position: absolute !important;
          font-size: 2.5rem !important;
          bottom: -3px !important;
          left: 50% !important;
          transform: translateX(-50%) !important;
          z-index: 0 !important;
        }
        
        /* MAXIMUM SPECIFICITY PWA GROCERY ICON - USER TESTED PERFECT VALUES */
        html body.pwa-mode.mobile-device.display-standalone .nav-button:nth-child(6) .nav-icon .emoji-base {
          position: absolute !important;
          right: 4px !important;
          top: 27% !important;
          transform: translateY(-50%) !important;
          z-index: 1 !important;
          font-size: 1.4rem !important;
        }
        
        html body.pwa-mode.mobile-device.display-standalone .nav-button:nth-child(6) .nav-icon .emoji-overlay {
          position: absolute !important;
          left: 9px !important;
          top: 31% !important;
          transform: translateY(-50%) !important;
          z-index: 2 !important;
          font-size: 1.0rem !important;
          filter: drop-shadow(1px 1px 2px rgba(0, 0, 0, 0.3)) !important;
        }
        
        .pwa-mode input, .pwa-mode textarea, .pwa-mode select {
          font-size: 16px !important; /* Prevents zoom on iOS */
          padding: 12px !important;
        }
        
        .pwa-mode .widget {
          margin: 8px !important;
          border-radius: 12px !important;
        }
        
        /* Hide elements that don't make sense in app mode */
        .pwa-mode .install-prompt {
          display: none !important;
        }
        
        /* App-like header styling */
        .pwa-mode .fullscreen-header {
          background: linear-gradient(135deg, #1976d2, #42a5f5) !important;
          color: white !important;
          padding: 20px !important;
          border-radius: 0 !important;
        }
        
        /* PWA mobile styling removed - keep same layout as desktop */
      `;
      document.head.appendChild(style);
    }

    // Desktop/Browser optimizations
    function addDesktopOptimizations() {
      const style = document.createElement('style');
      style.textContent = `
        .browser-mode .widget {
          transition: transform 0.2s ease, box-shadow 0.2s ease !important;
        }
        
        .browser-mode .widget:hover {
          transform: translateY(-2px) !important;
          box-shadow: 0 8px 25px rgba(0,0,0,0.15) !important;
        }
        
        .browser-mode .nav-button:hover {
          transform: scale(1.05) !important;
        }
        
        /* Show install button in browser mode */
        .browser-mode .install-prompt {
          display: block !important;
        }
      `;
      document.head.appendChild(style);
    }

    // Add PWA version indicator for debugging and manual updates
    function addPWAVersionIndicator() {
      if (!window.pwaInfo?.isPWA) return;
      
      // Add version indicator (only visible when debugging needed)
      const versionIndicator = document.createElement('div');
      versionIndicator.id = 'pwa-version-indicator';
      versionIndicator.textContent = 'PWA v7.2 - Tap to Update';
      versionIndicator.style.cssText = `
        position: fixed;
        bottom: 10px;
        left: 10px;
        font-size: 11px;
        color: rgba(255, 255, 255, 0.8);
        z-index: 1000;
        cursor: pointer;
        padding: 6px 12px;
        background: rgba(0, 0, 0, 0.5);
        border-radius: 8px;
        opacity: 0.8;
        transition: all 0.3s ease;
        border: 1px solid rgba(255, 255, 255, 0.3);
        font-weight: 500;
      `;
      
      // Make it more visible on touch for mobile
      versionIndicator.addEventListener('touchstart', () => {
        versionIndicator.style.opacity = '1';
        versionIndicator.style.background = 'rgba(255, 255, 255, 0.9)';
        versionIndicator.style.color = '#333';
      });
      
      versionIndicator.addEventListener('touchend', () => {
        setTimeout(() => {
          versionIndicator.style.opacity = '0.7';
          versionIndicator.style.background = 'rgba(0, 0, 0, 0.3)';
          versionIndicator.style.color = 'rgba(255, 255, 255, 0.6)';
        }, 200);
      });
      
      // Add click handler for debug info and manual update
      versionIndicator.addEventListener('click', () => {
        const debugInfo = debugPWADataLoading();
        const totalItems = debugInfo.currentData.todoItems.length + 
                          debugInfo.currentData.groceryItems.length + 
                          debugInfo.currentData.mealItems.length;
        
        const message = `🔍 PWA Debug Info:
        
📱 Mode: ${debugInfo.pwaMode ? 'PWA' : 'Browser'}
🌐 Online: ${debugInfo.isOnline ? 'Yes' : 'No'}
🔑 GitHub Token: ${debugInfo.hasGithubToken ? 'Yes' : 'No'}
📝 Gist ID: ${debugInfo.hasGistId ? 'Yes' : 'No'}

📊 Current Data: ${totalItems} items
📝 Todos: ${debugInfo.currentData.todoItems.length}
🛒 Grocery: ${debugInfo.currentData.groceryItems.length}  
🍽️ Meals: ${debugInfo.currentData.mealItems.length}

${totalItems === 0 ? '⚠️ No data loaded! Try refreshing or check sync.' : '✅ Data loaded successfully'}

🔄 Tap OK to manually update app
📊 Tap CANCEL for debug info only`;
        
        if (confirm(message)) {
          forceAppUpdate();
        } else {
          showDebugPanel();
        }
      });
      
      document.body.appendChild(versionIndicator);
      
      // Update version indicator with sync status
      const updateVersionIndicator = () => {
        const totalItems = todoItems.length + groceryItems.length + mealItems.length;
        const syncStatus = GIST_ID && GITHUB_TOKEN ? '🔄' : (JSONBIN_ID ? '📡' : '📱');
        versionIndicator.textContent = `PWA v7.2 ${syncStatus} (${totalItems})`;
        versionIndicator.title = `Tap for debug info and manual update. ${totalItems} items loaded. ${
          GIST_ID && GITHUB_TOKEN ? 'GitHub sync active' : 
          JSONBIN_ID ? 'JSONBin sync active' : 
          'Local storage only'
        }`;
      };
      
      // Update indicator initially and when data changes
      updateVersionIndicator();
      
      // Store update function globally so other parts can call it
      window.updatePWAVersionIndicator = updateVersionIndicator;
    }

    // Fix iOS status bar white banner in PWA mode
    function addPWAStatusBarFix() {
      if (!window.pwaInfo?.isPWA) return;
      
      const style = document.createElement('style');
      style.textContent = `
        /* PWA Status Bar Fix - Ensure purple gradient extends to top */
        .pwa-mode body {
          background: var(--background) !important;
          background-attachment: fixed !important;
          min-height: 100vh !important;
          min-height: calc(100vh + env(safe-area-inset-top)) !important;
        }
        
        .pwa-mode html {
          background: var(--background) !important;
          background-attachment: fixed !important;
          min-height: 100vh !important;
          min-height: calc(100vh + env(safe-area-inset-top)) !important;
        }
        
        /* Ensure no white space at top - aggressive fix */
        .pwa-mode body::before {
          content: '';
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          height: 100px; /* Cover any possible status bar height */
          background: linear-gradient(135deg, #8c5ec4 0%, #764ba2 100%);
          z-index: -1;
        }
        
        /* Force remove any default iOS styling */
        .pwa-mode html, .pwa-mode body {
          background: linear-gradient(135deg, #8c5ec4 0%, #764ba2 100%) !important;
          margin: 0 !important;
          padding: 0 !important;
        }
        
        /* Override any system styling */
        .pwa-mode * {
          -webkit-appearance: none !important;
        }
      `;
      document.head.appendChild(style);
    }

    // Haptic feedback for PWA
    function addHapticFeedback() {
      if (!window.pwaInfo?.isPWA) return;
      
      // Add haptic feedback to buttons
      document.addEventListener('click', (e) => {
        if (e.target.matches('button, .nav-button, .clickable')) {
          // Haptic feedback (iOS only)
          if (navigator.vibrate) {
            navigator.vibrate(10); // Short vibration
          }
        }
      });
    }

    // App-specific UI elements
    function addAppSpecificUI() {
      // Status bar removed for cleaner home screen appearance
      
      // Refresh button removed - using pull-to-refresh only for cleaner UI
      
      // Add hidden app version indicator (only visible when debugging needed)
      const versionIndicator = document.createElement('div');
      versionIndicator.id = 'pwa-version-indicator';
      versionIndicator.textContent = 'PWA v7.2';
      versionIndicator.style.cssText = `
        position: fixed;
        bottom: 10px;
        left: 10px;
        font-size: 8px;
        color: rgba(255, 255, 255, 0.3);
        z-index: 1000;
        cursor: pointer;
        padding: 2px 4px;
        background: transparent;
        border-radius: 4px;
        opacity: 0.1;
        transition: opacity 0.3s ease;
      `;
      
      // Make it more visible on hover for debugging
      versionIndicator.addEventListener('mouseenter', () => {
        versionIndicator.style.opacity = '0.8';
        versionIndicator.style.background = 'rgba(255, 255, 255, 0.9)';
        versionIndicator.style.color = '#666';
      });
      
      versionIndicator.addEventListener('mouseleave', () => {
        versionIndicator.style.opacity = '0.1';
        versionIndicator.style.background = 'transparent';
        versionIndicator.style.color = 'rgba(255, 255, 255, 0.3)';
      });
      
      // Add click handler for debug info
      versionIndicator.addEventListener('click', () => {
        const debugInfo = debugPWADataLoading();
        const totalItems = debugInfo.currentData.todoItems.length + 
                          debugInfo.currentData.groceryItems.length + 
                          debugInfo.currentData.mealItems.length;
        
        const message = `🔍 PWA Debug Info:
        
📱 Mode: ${debugInfo.pwaMode ? 'PWA' : 'Browser'}
🌐 Online: ${debugInfo.isOnline ? 'Yes' : 'No'}
🔑 GitHub Token: ${debugInfo.hasGithubToken ? 'Yes' : 'No'}
📝 Gist ID: ${debugInfo.hasGistId ? 'Yes' : 'No'}

📊 Current Data: ${totalItems} items
📝 Todos: ${debugInfo.currentData.todoItems.length}
🛒 Grocery: ${debugInfo.currentData.groceryItems.length}  
🍽️ Meals: ${debugInfo.currentData.mealItems.length}

${totalItems === 0 ? '⚠️ No data loaded! Try refreshing or check sync.' : '✅ Data loaded successfully'}`;
        
        alert(message);
      });
      
      document.body.appendChild(versionIndicator);
      
      // Update version indicator with sync status
      const updateVersionIndicator = () => {
        const totalItems = todoItems.length + groceryItems.length + mealItems.length;
        const syncStatus = GIST_ID && GITHUB_TOKEN ? '🔄' : (JSONBIN_ID ? '📡' : '📱');
        versionIndicator.textContent = `PWA v7.2 ${syncStatus} (${totalItems})`;
        versionIndicator.title = `Click for debug info. ${totalItems} items loaded. ${
          GIST_ID && GITHUB_TOKEN ? 'GitHub sync active' : 
          JSONBIN_ID ? 'JSONBin sync active' : 
          'Local storage only'
        }`;
      };
      
      // Update indicator initially and when data changes
      updateVersionIndicator();
      
      // Store update function globally so other parts can call it
      window.updatePWAVersionIndicator = updateVersionIndicator;
    }

    // Refresh app data function
    function refreshAppData() {
      console.log('🔄 Refreshing app data...');
      
      // Add spinning animation to refresh button
      const refreshButton = document.querySelector('button[title="Refresh app data"]');
      if (refreshButton) {
        refreshButton.style.animation = 'spin 1s linear infinite';
        refreshButton.style.pointerEvents = 'none';
      }
      
      // Add spin animation if not already added
      if (!document.querySelector('#refresh-spin-style')) {
        const style = document.createElement('style');
        style.id = 'refresh-spin-style';
        style.textContent = `
          @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
          }
        `;
        document.head.appendChild(style);
      }
      
      // Reload all data and refresh displays
      Promise.all([
        loadAllData(),
        // Small delay to show the refresh animation
        new Promise(resolve => setTimeout(resolve, 500))
      ]).then(() => {
        // Update all displays
        renderTodoList();
        renderGroceryList();
        renderMealsList();
        
        // Update fullscreen views if open
        const fullscreenOverlay = document.getElementById('fullscreen-overlay');
        if (fullscreenOverlay && fullscreenOverlay.style.display === 'flex') {
          const content = fullscreenOverlay.querySelector('.fullscreen-content');
          if (content) {
            // Determine which view is open and refresh it
            if (content.querySelector('#fullscreen-todo-container')) {
              renderTodoListFullscreen();
            } else if (content.querySelector('#fullscreen-grocery-container')) {
              renderGroceryListFullscreen();
            } else if (content.querySelector('#fullscreen-meals-container')) {
              renderMealsListFullscreen();
            } else if (content.querySelector('#fullscreen-todo-calendar-container')) {
              renderTodoCalendarFullscreen();
            }
          }
        }
        
        // Refresh button removed - no reset needed
        
        // Add haptic feedback if available
        if (navigator.vibrate && window.pwaInfo?.isPWA) {
          navigator.vibrate(50);
        }
        
        console.log('✅ App data refreshed successfully');
        
        // Update PWA version indicator if it exists
        if (window.updatePWAVersionIndicator) {
          window.updatePWAVersionIndicator();
        }
        
      }).catch((error) => {
        console.error('❌ Error refreshing app data:', error);
        
        // Refresh button removed - no reset needed
      });
    }

    // Browser-specific UI elements
    function addBrowserSpecificUI() {
      // Add browser-specific indicators or features
      console.log('Browser mode - standard web features enabled');
    }

    // Keyboard shortcuts for desktop
    function addKeyboardShortcuts() {
      document.addEventListener('keydown', (e) => {
        if (e.ctrlKey || e.metaKey) {
          switch(e.key) {
            case 't':
              e.preventDefault();
              showFullscreenTodo();
              break;
            case 'g':
              e.preventDefault();
              showFullscreenGrocery();
              break;
            case 'm':
              e.preventDefault();
              showFullscreenMeals();
              break;
            case 'c':
              e.preventDefault();
              showFullscreenTodoCalendar();
              break;
            case 'r':
              e.preventDefault();
              refreshAppData();
              break;
          }
        }
      });
    }

    // Swipe gestures for PWA
    function addSwipeGestures() {
      console.log('🎯 addSwipeGestures called - PWA Info:', window.pwaInfo);
      if (!window.pwaInfo?.isPWA) {
        console.log('❌ Not PWA mode, skipping swipe gestures');
        return;
      }
      console.log('✅ PWA mode detected, adding swipe gestures and pull-to-refresh');
      
      let startX, startY, endX, endY;
      let pullToRefreshTriggered = false;
      
      document.addEventListener('touchstart', (e) => {
        startX = e.touches[0].clientX;
        startY = e.touches[0].clientY;
        pullToRefreshTriggered = false;
      });
      
      document.addEventListener('touchmove', (e) => {
        // Only trigger pull-to-refresh if at top of page and not already triggered
        if (!pullToRefreshTriggered && window.scrollY === 0) {
          const currentY = e.touches[0].clientY;
          const deltaY = currentY - startY;
          
          // Show pull indicator when pulling down
          if (deltaY > 30 && deltaY < 80 && Math.abs(e.touches[0].clientX - startX) < 50) {
            console.log('📱 Pull-to-refresh: Showing pull indicator, deltaY:', deltaY);
            showPullToRefreshIndicator('Pull down to refresh');
          }
          
          // Trigger refresh when pulled far enough
          if (deltaY > 80 && Math.abs(e.touches[0].clientX - startX) < 50) {
            console.log('📱 Pull-to-refresh: Triggering refresh, deltaY:', deltaY);
            pullToRefreshTriggered = true;
            
            showPullToRefreshIndicator('Release to refresh', true);
            
            // Add haptic feedback
            if (navigator.vibrate) {
              navigator.vibrate(50);
            }
            
            // Trigger refresh after a short delay
            setTimeout(() => {
              refreshAppData();
              hidePullToRefreshIndicator();
            }, 200);
          }
        }
      });
      
      // Show pull-to-refresh indicator
      function showPullToRefreshIndicator(text, ready = false) {
        console.log('📱 showPullToRefreshIndicator called:', text, 'ready:', ready);
        let indicator = document.getElementById('pull-refresh-indicator');
        if (!indicator) {
          indicator = document.createElement('div');
          indicator.id = 'pull-refresh-indicator';
          indicator.style.cssText = `
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            z-index: 10002;
            transition: all 0.3s ease;
            pointer-events: none;
          `;
          document.body.appendChild(indicator);
        }
        
        indicator.textContent = text;
        indicator.style.background = ready ? 
          'linear-gradient(135deg, #4caf50, #66bb6a)' : 
          'linear-gradient(135deg, #1976d2, #42a5f5)';
        indicator.style.color = 'white';
        indicator.style.opacity = '1';
        indicator.style.transform = 'translateX(-50%) translateY(0)';
      }
      
      // Hide pull-to-refresh indicator
      function hidePullToRefreshIndicator() {
        const indicator = document.getElementById('pull-refresh-indicator');
        if (indicator) {
          indicator.style.opacity = '0';
          indicator.style.transform = 'translateX(-50%) translateY(-20px)';
          setTimeout(() => {
            if (document.body.contains(indicator)) {
              document.body.removeChild(indicator);
            }
          }, 300);
        }
      }
      
      document.addEventListener('touchend', (e) => {
        endX = e.changedTouches[0].clientX;
        endY = e.changedTouches[0].clientY;
        
        const deltaX = endX - startX;
        const deltaY = endY - startY;
        
        // Hide pull-to-refresh indicator if not triggered
        if (!pullToRefreshTriggered) {
          hidePullToRefreshIndicator();
        }
        
        // Swipe right to go back (if in fullscreen mode)
        if (deltaX > 50 && Math.abs(deltaY) < 100) {
          if (document.getElementById('fullscreen-overlay').style.display === 'flex') {
            closeFullscreen();
          }
        }
      });
    }

    // Initialize PWA customizations when page loads (essential features only)
    document.addEventListener('DOMContentLoaded', () => {
      // Only apply PWA customizations if in PWA mode
      const isPWAModeForCustomizations = window.matchMedia('(display-mode: standalone)').matches || 
                                        window.navigator.standalone === true;
      
      if (isPWAModeForCustomizations) {
        setTimeout(applyPWACustomizations, 100);
        console.log('PWA customizations: essential features only (no layout changes)');
      } else {
        console.log('🌐 Desktop Browser: PWA customizations disabled');
      }
    });

    // PWA-specific data loading debug
    function debugPWADataLoading() {
      console.log('🔍 PWA Data Loading Debug:');
      console.log('- PWA Mode:', window.pwaInfo?.isPWA);
      console.log('- GIST_ID:', GIST_ID);
      console.log('- GITHUB_TOKEN:', GITHUB_TOKEN ? '✅ Present' : '❌ Missing');
      console.log('- JSONBIN_ID:', JSONBIN_ID);
      console.log('- Online Status:', isOnline);
      console.log('- Current Data:', {
        todoItems: todoItems.length,
        groceryItems: groceryItems.length,
        mealItems: mealItems.length,
        todoHistory: todoHistory.length,
        mealHistory: mealHistory.length
      });
      
      // Check localStorage
      const localData = {
        todoItems: JSON.parse(localStorage.getItem('todoItems') || '[]').length,
        groceryItems: JSON.parse(localStorage.getItem('groceryItems') || '[]').length,
        mealItems: JSON.parse(localStorage.getItem('mealItems') || '[]').length,
        todoHistory: JSON.parse(localStorage.getItem('todoHistory') || '[]').length,
        mealHistory: JSON.parse(localStorage.getItem('mealHistory') || '[]').length,
        gistId: localStorage.getItem('dashboardGistId'),
        githubToken: localStorage.getItem('githubToken') ? '✅ Present' : '❌ Missing'
      };
      console.log('- Local Storage:', localData);
      
      return {
        pwaMode: window.pwaInfo?.isPWA,
        hasGistId: !!GIST_ID,
        hasGithubToken: !!GITHUB_TOKEN,
        isOnline,
        currentData: getCurrentData(),
        localData
      };
    }

    // Enhanced refresh function for PWA debugging
    function refreshAppDataWithDebug() {
      console.log('🔄 PWA Refresh with Debug Info');
      debugPWADataLoading();
      
      // Force reload data
      return refreshAppData();
    }
  </script>

  </div> <!-- Close dashboard div -->
</body>
</html>
