<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Bennett Hub - Smart Dashboard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <!-- PWA Manifest -->
  <link rel="manifest" href="/smart-dashboard/manifest.json">
  
  <!-- PWA Meta Tags -->
  <meta name="application-name" content="Bennett Hub">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="Bennett Hub">
  <meta name="description" content="Smart Dashboard for Todo Lists, Grocery Lists, Meal Planning, and Calendar Management">
  <meta name="format-detection" content="telephone=no">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="msapplication-config" content="browserconfig.xml">
  <meta name="msapplication-TileColor" content="#1976d2">
  <meta name="msapplication-tap-highlight" content="no">
  <meta name="theme-color" content="#667eea">
  
  <!-- Apple Touch Icons -->
  <link rel="apple-touch-icon" href="/smart-dashboard/icon-152.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/smart-dashboard/icon-152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/smart-dashboard/icon-180.png">
  <link rel="apple-touch-icon" sizes="167x167" href="/smart-dashboard/icon-167.png">
  
  <!-- Standard Favicon -->
  <link rel="icon" type="image/png" sizes="32x32" href="/smart-dashboard/icon-32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/smart-dashboard/icon-16.png">
  <link rel="shortcut icon" href="/smart-dashboard/favicon.ico">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
    
    /* PWA Loading Screen */
    #pwa-loading-screen {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 99999;
      opacity: 1;
      transition: opacity 0.3s ease-out;
    }
    
    #pwa-loading-screen.hidden {
      opacity: 0;
      pointer-events: none;
    }
    
    .loading-spinner {
      width: 50px;
      height: 50px;
      border: 4px solid rgba(255, 255, 255, 0.3);
      border-top: 4px solid white;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    /* Landing Page Styles */
    .landing-page {
      min-height: 100vh;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      display: flex;
      align-items: flex-start;
      justify-content: center;
      padding: 2rem;
      overflow-y: auto;
    }

    .landing-container {
      text-align: center;
      max-width: 800px;
      width: 100%;
      margin-top: 2rem;
    }

    .landing-title {
      font-size: 3rem;
      font-weight: 700;
      color: white;
      margin: 0 0 0.5rem 0;
      text-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }

    .landing-subtitle {
      font-size: 1.2rem;
      color: rgba(255, 255, 255, 0.9);
      margin: 0 0 1rem 0;
      font-weight: 300;
    }

    .navigation-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1.5rem;
      max-width: 600px;
      margin: 0 auto;
    }

    .nav-button {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 20px;
      padding: 2rem;
      color: white;
      text-decoration: none;
      transition: all 0.3s ease;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
    }

    .nav-button:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: translateY(-4px);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
    }

    .nav-icon {
      font-size: 2.5rem;
    }
    
    
    /* Shift grocery icon and text down by 2% within button (desktop only) */
    .nav-button:nth-child(6) .nav-icon {
      transform: translateY(2%) !important;
    }
    
    .nav-button:nth-child(6) .nav-label {
      transform: translateY(2%) !important;
    }
    
    /* Grocery icon: Apple and baguette in basket */
    .nav-button:nth-child(6) .nav-icon {
      position: relative;
      display: inline-block;
      width: 50px;
      height: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 auto;
      font-size: 2rem;
      background: transparent;
    }

    .nav-button:nth-child(6) .nav-icon .emoji-basket {
      position: absolute !important;
      font-size: 2.5rem !important;
      bottom: -3px !important;
      left: 50% !important;
      transform: translateX(-50%) !important;
      z-index: 0 !important;
    }
    
    .nav-button:nth-child(6) .nav-icon .emoji-base {
      position: absolute !important;
      right: 7px !important;
      top: 25% !important;
      transform: translateY(-50%) !important;
      z-index: 1 !important;
      font-size: 1.3rem !important;
    }
    
    .nav-button:nth-child(6) .nav-icon .emoji-overlay {
      position: absolute !important;
      left: 11px !important;
      top: 28% !important;
      transform: translateY(-50%) !important;
      z-index: 2 !important;
      font-size: 1.15rem !important;
      filter: drop-shadow(1px 1px 2px rgba(0, 0, 0, 0.3)) !important;
    }

    .nav-label {
      font-size: 1.1rem;
      font-weight: 500;
    }

    .dashboard {
      min-height: 100vh;
    }

    @media (max-width: 768px) {
      .landing-title {
        font-size: 2rem;
      }
      
      .navigation-grid {
        grid-template-columns: repeat(2, 1fr);
        gap: 1rem;
      }
      
      .nav-button {
        padding: 1.5rem;
      }
      
      .nav-icon {
        font-size: 2rem;
      }
    }
    
    :root {
      --primary-color: #667eea;
      --primary-dark: #5a6fd8;
      --secondary-color: #764ba2;
      --accent-color: #f093fb;
      --success-color: #4ade80;
      --danger-color: #f87171;
      --warning-color: #fbbf24;
      --background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      --card-background: rgba(255, 255, 255, 0.95);
      --text-primary: #1f2937;
      --text-secondary: #6b7280;
      --border-color: #e5e7eb;
      --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
      --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
    }

    * {
      box-sizing: border-box;
    }

    html {
      background: var(--background) !important;
      margin: 0 !important;
      padding: 0 !important;
      min-height: 100vh !important;
    }

    body {
      margin: 0;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--background) !important;
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow-x: hidden;
      /* Ensure background extends to safe areas on iOS */
      padding-top: env(safe-area-inset-top);
      padding-bottom: env(safe-area-inset-bottom);
      margin-top: calc(-1 * env(safe-area-inset-top));
      margin-bottom: calc(-1 * env(safe-area-inset-bottom));
    }
    
    /* iOS PWA Status Bar Fix - Applied immediately */
    @media (display-mode: standalone) {
      html, body {
        background: linear-gradient(135deg, #8c5ec4 0%, #764ba2 100%) !important;
        background-attachment: fixed !important;
        margin: 0 !important;
        padding: 0 !important;
      }
      
      body::before {
        content: '';
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        height: 100px;
        background: linear-gradient(135deg, #8c5ec4 0%, #764ba2 100%);
        z-index: -1;
      }
    }

    header {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid rgba(255, 255, 255, 0.2);
      color: white;
      text-align: center;
      padding: 1.5rem;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      position: relative;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    header::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(45deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%);
      pointer-events: none;
    }

    .header-title {
      font-size: 2rem;
      font-weight: 600;
      margin: 0;
      z-index: 1;
      position: relative;
    }

    .home-button {
      position: absolute;
      left: 2rem;
      top: 50%;
      transform: translateY(-50%);
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: white;
      border-radius: 12px;
      padding: 0.8rem 1rem;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 1.2rem;
      z-index: 2;
    }

    .home-button:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: translateY(-50%) scale(1.05);
    }

    .header-info {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 2rem;
      font-size: 1rem;
      font-weight: 400;
      opacity: 0.9;
      z-index: 1;
      position: relative;
    }

    .info-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      background: rgba(255, 255, 255, 0.1);
      padding: 0.5rem 1rem;
      border-radius: 20px;
      backdrop-filter: blur(5px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      transition: all 0.3s ease;
    }

    .info-item:hover {
      background: rgba(255, 255, 255, 0.15);
      transform: translateY(-1px);
    }

    .info-icon {
      font-size: 1.1rem;
    }

    .weather-temp {
      font-weight: 500;
    }

    .loading {
      opacity: 0.6;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 0.6; }
      50% { opacity: 1; }
    }

    main {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      grid-template-rows: minmax(400px, 1fr) minmax(200px, 1fr);
      flex: 1;
      gap: 1.5rem;
      padding: 2rem;
      box-sizing: border-box;
      animation: fadeIn 0.6s ease-out;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .widget {
      background: var(--card-background);
      backdrop-filter: blur(10px);
      border-radius: 20px;
      box-shadow: var(--shadow-xl);
      padding: 2rem;
      overflow: hidden;
      position: relative;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .widget:hover {
      transform: translateY(-2px);
      box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.15);
    }

    .widget::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: linear-gradient(90deg, var(--primary-color), var(--accent-color));
      border-radius: 20px 20px 0 0;
    }

    .calendar-widget {
      grid-column: 1 / 4;
      grid-row: 1;
      /* Force stable dimensions to prevent layout shifts */
      min-height: 400px;
      max-height: 600px;
      overflow: hidden;
      /* Complete isolation from other widgets */
      contain: layout style size;
      transform: translateZ(0); /* Force hardware acceleration and isolation */
      will-change: auto;
    }
    
    .calendar-widget iframe {
      /* Ensure iframe doesn't cause layout changes */
      width: 100% !important;
      height: 100% !important;
      min-height: 350px;
      max-height: 550px;
      /* Force iframe isolation and stability */
      contain: strict;
      transform: translateZ(0);
      backface-visibility: hidden;
      pointer-events: auto;
      position: relative;
      z-index: 1;
    }

    /* Custom Calendar Styles */
    .custom-calendar-container {
      height: calc(100% - 40px);
      overflow-y: auto;
      padding-right: 8px;
    }

    .custom-calendar-container::-webkit-scrollbar {
      width: 6px;
    }

    .custom-calendar-container::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.05);
      border-radius: 3px;
    }

    .custom-calendar-container::-webkit-scrollbar-thumb {
      background: rgba(102, 126, 234, 0.3);
      border-radius: 3px;
    }

    .custom-calendar-container::-webkit-scrollbar-thumb:hover {
      background: rgba(102, 126, 234, 0.5);
    }

    .calendar-date-group {
      margin-bottom: 1rem;
    }

    .calendar-date-header {
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      padding: 0.5rem 0;
      border-bottom: 1px solid var(--border-color);
      margin-bottom: 0.5rem;
      position: sticky;
      top: 0;
      background: var(--card-background);
      z-index: 1;
    }

    .calendar-date-header.today {
      color: var(--primary-color);
      border-bottom-color: var(--primary-color);
    }

    .calendar-event {
      display: flex;
      align-items: flex-start;
      padding: 0.75rem;
      margin-bottom: 0.5rem;
      border-radius: 10px;
      background: rgba(102, 126, 234, 0.08);
      border-left: 4px solid var(--primary-color);
      transition: all 0.2s ease;
    }

    .calendar-event:hover {
      background: rgba(102, 126, 234, 0.15);
      transform: translateX(4px);
    }

    .calendar-event.emley-event {
      border-left-color: #d946ef;
      background: rgba(217, 70, 239, 0.08);
    }

    .calendar-event.emley-event:hover {
      background: rgba(217, 70, 239, 0.15);
    }

    .calendar-event.nate-event {
      border-left-color: #60a5fa;
      background: rgba(96, 165, 250, 0.08);
    }

    .calendar-event.nate-event:hover {
      background: rgba(96, 165, 250, 0.15);
    }

    .calendar-event-time {
      min-width: 70px;
      font-size: 0.8rem;
      font-weight: 600;
      color: var(--text-secondary);
      padding-right: 0.75rem;
    }

    .calendar-event-time.all-day {
      font-style: italic;
      color: var(--primary-color);
    }

    .calendar-event-details {
      flex: 1;
    }

    .calendar-event-title {
      font-size: 0.95rem;
      font-weight: 500;
      color: var(--text-primary);
      margin-bottom: 0.25rem;
    }

    .calendar-event-location {
      font-size: 0.8rem;
      color: var(--text-secondary);
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .calendar-event-location::before {
      content: 'ðŸ“';
      font-size: 0.7rem;
    }

    .calendar-loading {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 200px;
      color: var(--text-secondary);
    }

    .calendar-loading-spinner {
      width: 40px;
      height: 40px;
      border: 3px solid rgba(102, 126, 234, 0.2);
      border-top-color: var(--primary-color);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 1rem;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .calendar-error {
      text-align: center;
      padding: 2rem;
      color: var(--danger-color);
    }

    .calendar-error button {
      margin-top: 1rem;
      padding: 0.5rem 1rem;
      background: var(--primary-color);
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
    }

    .calendar-no-events {
      text-align: center;
      padding: 2rem;
      color: var(--text-secondary);
      font-style: italic;
    }

    .calendar-toggle-container {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 0.75rem;
    }

    .calendar-toggle {
      flex: 1;
      padding: 0.4rem 0.75rem;
      border: none;
      border-radius: 8px;
      font-size: 0.8rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      background: rgba(0, 0, 0, 0.05);
      color: var(--text-secondary);
    }

    .calendar-toggle.active {
      background: var(--primary-color);
      color: white;
    }

    .calendar-toggle.emley.active {
      background: #d946ef;
    }

    .calendar-toggle.nate.active {
      background: #60a5fa;
    }

    .todo-widget {
      grid-column: 1;
      grid-row: 2;
      /* Force stable dimensions to prevent layout shifts */
      min-height: 400px;
      max-height: 400px;
      display: flex;
      flex-direction: column;
      /* Complete isolation from other widgets */
      contain: layout style size;
      transform: translateZ(0);
      will-change: auto;
    }

    .todo-widget .task-list {
      max-height: 250px;
      overflow-y: auto;
      overflow-x: hidden;
      flex: 1;
      min-height: 0;
    }

    .todo-widget #todo-add-container {
      /* Fixed height for add container to prevent size changes */
      min-height: 60px;
      max-height: 80px;
      flex-shrink: 0;
      display: flex;
      flex-direction: row;
      justify-content: flex-start;
      align-items: flex-start;
    }

    .grocery-widget {
      grid-column: 2;
      grid-row: 2;
      /* Force stable dimensions to prevent layout shifts */
      min-height: 400px;
      max-height: 400px;
      display: flex;
      flex-direction: column;
      /* Complete isolation from other widgets */
      contain: layout style size;
      transform: translateZ(0);
      will-change: auto;
    }

    .grocery-widget .task-list {
      max-height: 250px;
      overflow-y: auto;
      overflow-x: hidden;
      flex: 1;
      min-height: 0;
    }

    .meals-widget {
      grid-column: 3;
      grid-row: 2;
      /* Force stable dimensions to prevent layout shifts */
      min-height: 400px;
      max-height: 400px;
      display: flex;
      flex-direction: column;
      /* Complete isolation to prevent affecting other widgets */
      contain: layout style size;
      isolation: isolate;
      transform: translateZ(0);
      /* Prevent any cascading effects */
      will-change: auto;
    }

    .meals-widget .task-list {
      max-height: 250px;
      overflow-y: auto;
      overflow-x: hidden;
      flex: 1;
      min-height: 0;
    }

    iframe {
      border: 0;
      width: 100%;
      height: 100%;
      border-radius: 10px;
      /* Prevent any external interference with iframe content */
      isolation: isolate;
      contain: layout style;
      transform: translateZ(0);
      /* Ensure iframe renders independently */
      display: block;
      box-sizing: border-box;
    }

    h2 {
      margin: 0 0 1.5rem 0;
      text-align: center;
      color: var(--text-primary);
      font-size: 1.5rem;
      font-weight: 600;
      position: relative;
      padding-bottom: 0.5rem;
      cursor: pointer;
      transition: all 0.3s ease;
      user-select: none;
      flex-shrink: 0;
    }

    h2:hover {
      color: var(--primary-color);
      transform: translateY(-1px);
    }

    h2::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 40px;
      height: 3px;
      background: linear-gradient(90deg, var(--primary-color), var(--accent-color));
      border-radius: 2px;
      transition: width 0.3s ease;
    }

    h2:hover::after {
      width: 60px;
    }

    /* Full-screen mode styles */
    .fullscreen-mode {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 1000;
      background: var(--background);
      display: flex;
      flex-direction: column;
      animation: slideInFullscreen 0.3s ease-out;
    }

    @keyframes slideInFullscreen {
      from { opacity: 0; transform: scale(0.95); }
      to { opacity: 1; transform: scale(1); }
    }

    .fullscreen-header {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid rgba(255, 255, 255, 0.2);
      color: white;
      padding: 1rem 2rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .fullscreen-title {
      font-size: 1.5rem;
      font-weight: 600;
      margin: 0;
    }

    .back-button {
      background: rgba(255, 255, 255, 0.2);
      border: 1px solid rgba(255, 255, 255, 0.3);
      color: white;
      padding: 0.5rem 1rem;
      border-radius: 20px;
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 500;
      transition: all 0.3s ease;
      backdrop-filter: blur(5px);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .back-button:hover {
      background: rgba(255, 255, 255, 0.3);
      transform: translateY(-1px);
    }

    .auto-return-indicator {
      font-size: 0.8rem;
      opacity: 0.7;
      color: rgba(255, 255, 255, 0.8);
      margin-left: 1rem;
      display: flex;
      align-items: center;
      gap: 0.3rem;
    }

    .auto-return-dot {
      width: 6px;
      height: 6px;
      background: rgba(255, 255, 255, 0.6);
      border-radius: 50%;
      animation: pulse 2s infinite;
    }

    .fullscreen-content {
      flex: 1;
      padding: 1rem 2rem;
      overflow: hidden;
      background: var(--card-background);
      margin: 0.5rem;
      border-radius: 20px;
      box-shadow: var(--shadow-xl);
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .hidden {
      display: none !important;
    }

    /* Meals-specific styles */
    .meal-item {
      display: flex;
      align-items: center;
      padding: 16px 0;
      border-bottom: 1px solid rgba(0, 0, 0, 0.05);
      gap: 12px;
      transition: all 0.2s ease;
      animation: slideIn 0.3s ease-out;
    }

    .meal-item:hover {
      background: rgba(102, 126, 234, 0.03);
      border-radius: 8px;
      margin: 0;
      padding-left: 8px;
      padding-right: 0;
    }

    .meal-text {
      flex: 1;
      font-size: 15px;
      line-height: 1.5;
      word-wrap: break-word;
      color: var(--text-primary);
      transition: all 0.3s ease;
    }

    .meal-text.completed {
      text-decoration: line-through;
      color: var(--text-secondary);
      opacity: 0.7;
    }

    .meal-link {
      color: var(--primary-color);
      text-decoration: none;
      font-weight: 500;
    }

    .meal-link:hover {
      text-decoration: underline;
    }

    .history-button {
      background: linear-gradient(135deg, var(--secondary-color), var(--accent-color));
      color: white;
      border: none;
      border-radius: 8px;
      padding: 6px 12px;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.3s ease;
      position: absolute;
      right: 0;
      top: 50%;
      transform: translateY(-50%);
      min-width: 60px;
      text-align: center;
    }

    .history-button:hover {
      transform: translateY(-50%) translateY(-1px);
      box-shadow: var(--shadow-md);
    }

    /* Drag and Drop Styles */
    .task-item {
      cursor: move;
      transition: all 0.2s ease;
      position: relative;
    }

    .task-item:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .task-item.dragging {
      opacity: 0.6;
      transform: scale(1.02);
      z-index: 1000;
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
      border: 2px solid var(--primary-color);
      background: rgba(255, 255, 255, 0.1);
    }

    /* Insertion indicator - shows where item will be dropped */
    .task-item.drop-target-above::before {
      content: '';
      position: absolute;
      top: -2px;
      left: 0;
      right: 0;
      height: 4px;
      background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
      border-radius: 2px;
      box-shadow: 0 0 8px var(--primary-color);
      z-index: 1001;
      animation: dropIndicator 0.6s ease-in-out infinite alternate;
    }

    .task-item.drop-target-below::after {
      content: '';
      position: absolute;
      bottom: -2px;
      left: 0;
      right: 0;
      height: 4px;
      background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
      border-radius: 2px;
      box-shadow: 0 0 8px var(--primary-color);
      z-index: 1001;
      animation: dropIndicator 0.6s ease-in-out infinite alternate;
    }

    @keyframes dropIndicator {
      0% { opacity: 0.7; transform: scaleX(0.8); }
      100% { opacity: 1; transform: scaleX(1); }
    }

    .drag-handle {
      position: absolute;
      left: 8px;
      top: 50%;
      transform: translateY(-50%);
      color: var(--text-secondary);
      font-size: 16px;
      opacity: 0.6;
      transition: all 0.2s ease;
      cursor: grab;
      padding: 4px;
      border-radius: 4px;
      user-select: none;
    }

    .drag-handle:hover {
      opacity: 1;
      background: rgba(255, 255, 255, 0.1);
      color: var(--primary-color);
    }

    .drag-handle:active {
      cursor: grabbing;
      background: rgba(255, 255, 255, 0.2);
    }

    /* Drag handle positioning - padding is set in main .task-item rule */

    .task-list {
      position: relative;
    }

    /* Fullscreen History Button Styles */
    .fullscreen-history-button {
      background: linear-gradient(135deg, var(--secondary-color), var(--accent-color));
      color: white;
      border: none;
      border-radius: 8px;
      padding: 8px 16px;
      font-size: 1.2rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.3s ease;
      position: absolute;
      right: 0;
      top: 50%;
      transform: translateY(-50%);
      min-width: 80px;
      text-align: center;
    }

    .fullscreen-history-button:hover {
      transform: translateY(-50%) translateY(-1px);
      box-shadow: var(--shadow-md);
    }

    .meal-url-input {
      width: 100%;
      padding: 8px 12px;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      font-size: 13px;
      margin-top: 8px;
      transition: all 0.3s ease;
    }

    .meal-url-input:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1);
    }

    .add-from-history-btn {
      background: var(--success-color);
      color: white;
      border: none;
      border-radius: 6px;
      padding: 4px 8px;
      font-size: 11px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .add-from-history-btn:hover {
      background: #22c55e;
      transform: scale(1.05);
    }

    #clear-search-btn {
      background: var(--danger-color);
      color: white;
      border: none;
      border-radius: 8px;
      padding: 12px 16px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      transition: all 0.2s ease;
      min-width: auto;
    }

    #clear-search-btn:hover {
      background: #dc2626;
      transform: scale(1.05);
    }

    .add-item-container {
      display: flex;
      gap: 12px;
      margin-bottom: 1.5rem;
      position: relative;
      flex-shrink: 0;
      min-height: 60px;
      align-items: flex-start;
    }

    .add-item-container input {
      flex: 1;
      padding: 12px 16px;
      border: 2px solid var(--border-color);
      border-radius: 12px;
      font-size: 14px;
      font-family: inherit;
      background: rgba(255, 255, 255, 0.8);
      transition: all 0.3s ease;
      color: var(--text-primary);
    }

    .add-item-container input:focus {
      outline: none;
      border-color: var(--primary-color);
      background: white;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
      transform: translateY(-1px);
    }

    .add-item-container input::placeholder {
      color: var(--text-secondary);
    }

    .add-item-container button {
      padding: 12px 20px;
      background: linear-gradient(135deg, var(--primary-color), var(--primary-dark));
      color: white;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      font-family: inherit;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: var(--shadow-md);
      position: relative;
      overflow: hidden;
    }

    .add-item-container button:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }

    .add-item-container button:active {
      transform: translateY(0);
    }

    .add-item-container button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: left 0.5s;
    }

    .add-item-container button:hover::before {
      left: 100%;
    }

    .task-list {
      list-style: none;
      padding: 0;
      margin: 0;
      max-height: 350px;
      overflow-y: auto;
      scrollbar-width: thin;
      scrollbar-color: var(--primary-color) transparent;
    }

    .task-list::-webkit-scrollbar {
      width: 6px;
    }

    .task-list::-webkit-scrollbar-track {
      background: transparent;
    }

    .task-list::-webkit-scrollbar-thumb {
      background: var(--primary-color);
      border-radius: 3px;
    }

    .task-item {
      display: flex;
      align-items: center;
      padding: 16px 0;
      padding-left: 56px;
      border-bottom: 1px solid rgba(0, 0, 0, 0.05);
      gap: 12px;
      transition: all 0.2s ease;
      animation: slideIn 0.3s ease-out;
      position: relative;
    }
    
    /* Ensure drag handle spacing in all contexts */
    .task-list .task-item,
    .fullscreen-mode .task-item {
      padding-left: 56px;
    }
    
    /* Fullscreen task list optimization */
    .fullscreen-mode .task-list {
      flex: 1;
      overflow-y: auto;
      margin: 0;
      padding: 0;
      min-height: 0;
      max-height: none;
      /* Ensure drag events work properly */
      touch-action: manipulation;
      -webkit-overflow-scrolling: touch;
    }
    
    /* Ensure drag handles work in fullscreen */
    .fullscreen-mode .drag-handle {
      position: absolute;
      left: 8px;
      top: 50%;
      transform: translateY(-50%);
      z-index: 10;
      pointer-events: auto;
      cursor: grab;
      user-select: none;
    }
    
    .fullscreen-mode .drag-handle:active {
      cursor: grabbing;
    }
    
    /* Ensure task items are properly positioned for dragging in fullscreen */
    .fullscreen-mode .task-item {
      position: relative;
      z-index: 1;
    }
    
    .fullscreen-mode .task-item.dragging {
      z-index: 1000;
    }
    
    .fullscreen-mode .add-item-container {
      flex-shrink: 0;
      margin-bottom: 1rem;
    }
    
    /* Fullscreen header containers should not grow */
    .fullscreen-content > div:first-child {
      flex-shrink: 0;
    }

    @keyframes slideIn {
      from { opacity: 0; transform: translateX(-20px); }
      to { opacity: 1; transform: translateX(0); }
    }

    .task-item:last-child {
      border-bottom: none;
    }

    .task-item:hover {
      background: rgba(102, 126, 234, 0.03);
      border-radius: 8px;
      margin: 0;
      padding-left: 56px;
      padding-right: 0;
    }

    .task-checkbox {
      width: 20px;
      height: 20px;
      margin-left: 0px;
      margin-right: 12px;
      accent-color: var(--primary-color);
      cursor: pointer;
      transition: transform 0.2s ease;
    }

    .task-checkbox:hover {
      transform: scale(1.1);
    }
    
    /* PWA: Larger checkboxes for touch with visible border */
    .pwa-mode .task-checkbox {
      width: 28px;
      height: 28px;
      margin-right: 16px;
      border: 2px solid #667eea;
      border-radius: 4px;
      appearance: none;
      -webkit-appearance: none;
      background: white;
      position: relative;
      flex-shrink: 0;
    }
    
    /* PWA: Checkmark when checked */
    .pwa-mode .task-checkbox:checked {
      background: #667eea;
    }
    
    .pwa-mode .task-checkbox:checked::after {
      content: 'âœ“';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 18px;
      font-weight: bold;
    }
    
    /* Prevent text selection on drag handle */
    .drag-handle {
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
      touch-action: none;
    }
    
    /* Smooth transitions for drag and drop reordering */
    .task-item {
      transition: transform 0.15s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.15s ease;
    }
    
    .task-item.dragging {
      transition: box-shadow 0.15s ease, transform 0.1s ease;
      z-index: 1000;
      box-shadow: 0 8px 24px rgba(102, 126, 234, 0.3), 0 4px 8px rgba(0, 0, 0, 0.1);
      transform: scale(1.03);
    }
    
    .drag-placeholder {
      transition: opacity 0.15s ease;
      background: linear-gradient(135deg, rgba(102, 126, 234, 0.15) 0%, rgba(118, 75, 162, 0.15) 100%) !important;
      border: 2px dashed #667eea !important;
      border-radius: 8px !important;
      opacity: 0.4 !important;
      position: relative;
      animation: placeholderPulse 1.5s ease-in-out infinite;
    }
    
    @keyframes placeholderPulse {
      0%, 100% { 
        border-color: #667eea;
        box-shadow: 0 0 0 rgba(102, 126, 234, 0.4);
      }
      50% { 
        border-color: #764ba2;
        box-shadow: 0 0 12px rgba(102, 126, 234, 0.6);
      }
    }
    
    .drag-placeholder::before {
      content: '';
      position: absolute;
      top: -4px;
      left: 0;
      right: 0;
      height: 4px;
      background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
      border-radius: 2px;
      box-shadow: 0 0 8px rgba(102, 126, 234, 0.6);
      animation: shimmer 1.5s ease-in-out infinite;
    }
    
    .drag-placeholder::after {
      content: '';
      position: absolute;
      bottom: -4px;
      left: 0;
      right: 0;
      height: 4px;
      background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
      border-radius: 2px;
      box-shadow: 0 0 8px rgba(102, 126, 234, 0.6);
      animation: shimmer 1.5s ease-in-out infinite;
    }
    
    @keyframes shimmer {
      0%, 100% { opacity: 0.8; }
      50% { opacity: 1; }
    }
    
    /* Larger touch target for drag handle on PWA */
    .pwa-mode .drag-handle {
      padding: 8px 12px;
      margin: -8px -12px;
      font-size: 18px;
    }

    .task-text {
      flex: 1;
      font-size: 15px;
      line-height: 1.5;
      word-wrap: break-word;
      color: var(--text-primary);
      transition: all 0.3s ease;
    }

    .task-text.completed {
      text-decoration: line-through;
      color: var(--text-secondary);
      opacity: 0.7;
    }

    .task-due-date {
      font-size: 12px;
      color: var(--text-secondary);
      background: rgba(102, 126, 234, 0.1);
      padding: 2px 6px;
      border-radius: 10px;
      margin-left: 8px;
      white-space: nowrap;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .task-due-date:hover {
      background: rgba(102, 126, 234, 0.2);
      transform: translateY(-1px);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .task-due-date.overdue {
      background: rgba(239, 68, 68, 0.1);
      color: #dc2626;
      border: 1px solid rgba(239, 68, 68, 0.2);
    }

    .task-due-date.overdue:hover {
      background: rgba(239, 68, 68, 0.2);
      transform: translateY(-1px);
      box-shadow: 0 2px 4px rgba(239, 68, 68, 0.2);
    }

    .task-due-date.due-today {
      background: rgba(251, 146, 60, 0.1);
      color: #ea580c;
      border: 1px solid rgba(251, 146, 60, 0.2);
    }

    .task-due-date.due-today:hover {
      background: rgba(251, 146, 60, 0.2);
      transform: translateY(-1px);
      box-shadow: 0 2px 4px rgba(251, 146, 60, 0.2);
    }

    .task-due-date.due-tomorrow {
      background: rgba(250, 204, 21, 0.1);
      color: #d97706;
      border: 1px solid rgba(250, 204, 21, 0.2);
    }

    .task-due-date.due-tomorrow:hover {
      background: rgba(250, 204, 21, 0.2);
      transform: translateY(-1px);
      box-shadow: 0 2px 4px rgba(250, 204, 21, 0.2);
    }

    .task-item.overdue {
      border-left: 3px solid #dc2626;
      background: rgba(239, 68, 68, 0.02);
    }

    .task-item.due-today {
      border-left: 3px solid #ea580c;
      background: rgba(251, 146, 60, 0.02);
    }

    .task-item.due-tomorrow {
      border-left: 3px solid #d97706;
      background: rgba(250, 204, 21, 0.02);
    }

    .person-avatar {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      font-size: 11px;
      font-weight: bold;
      color: white;
      margin-right: 8px;
      flex-shrink: 0;
    }

    .person-avatar.emley {
      background: #d946ef; /* Softer magenta-pink that complements the gradient */
    }

    .person-avatar.nate {
      background: #60a5fa; /* Lighter blue for maximum contrast with purple */
    }

    .person-avatar.family {
      background: #9333ea; /* Deeper purple for better contrast with blue */
    }

    .avatar-filter, .fullscreen-avatar-filter {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      font-size: 14px;
      font-weight: bold;
      color: white;
      cursor: pointer;
      border: 2px solid transparent;
      transition: all 0.2s ease;
      margin: 0 4px;
    }

    .avatar-filter:hover, .fullscreen-avatar-filter:hover {
      transform: scale(1.1);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    }

    .avatar-filter.active, .fullscreen-avatar-filter.active {
      border-color: #fff;
      box-shadow: 0 0 0 2px var(--primary-color);
      transform: scale(1.05);
    }

    .avatar-filter.emley, .fullscreen-avatar-filter.emley {
      background: #d946ef;
    }

    .avatar-filter.nate, .fullscreen-avatar-filter.nate {
      background: #60a5fa;
    }

    .avatar-filter.family, .fullscreen-avatar-filter.family {
      background: #9333ea;
    }

    .avatar-filters-container {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      margin: 0.5rem 0;
    }

    .add-item-container input[type="date"] {
      padding: 8px 12px;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      background: var(--bg-secondary);
      color: var(--text-primary);
      font-size: 14px;
      min-width: 140px;
    }

    .add-item-container input[type="date"]:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }

    .add-item-container select {
      padding: 8px 12px;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      background: var(--bg-secondary);
      color: var(--text-primary);
      font-size: 14px;
      min-width: 100px;
    }

    .add-item-container select:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }

    .task-actions {
      display: flex;
      gap: 4px;
      opacity: 1; /* Always visible for better accessibility */
      transition: opacity 0.2s ease;
    }

    .task-item:hover .task-actions {
      opacity: 1;
    }

    .delete-btn, .edit-btn {
      background: none;
      border: none;
      cursor: pointer;
      padding: 8px;
      border-radius: 8px;
      font-size: 16px;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 32px;
      height: 32px;
    }

    .delete-btn {
      color: var(--danger-color);
    }

    .delete-btn:hover {
      background-color: rgba(248, 113, 113, 0.1);
      transform: scale(1.1);
    }

    .edit-btn {
      color: var(--primary-color);
    }

    .edit-btn:hover {
      background-color: rgba(102, 126, 234, 0.1);
      transform: scale(1.1);
    }

    .empty-state {
      text-align: center;
      color: var(--text-secondary);
      font-style: italic;
      padding: 3rem 1rem;
      font-size: 15px;
      background: rgba(102, 126, 234, 0.02);
      border-radius: 12px;
      border: 2px dashed rgba(102, 126, 234, 0.2);
    }

    .date-header {
      background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
      color: white;
      padding: 0.8rem 1rem;
      margin: 1rem 0 0.5rem 0;
      border-radius: 12px;
      font-weight: 600;
      font-size: 0.95rem;
      text-align: center;
      box-shadow: 0 2px 8px rgba(102, 126, 234, 0.2);
    }

    .history-item {
      background: rgba(102, 126, 234, 0.05);
      border-left: 3px solid var(--primary-color);
      margin-left: 1rem;
    }

    .history-item .task-text {
      color: var(--text-secondary);
      /* Removed strikethrough - history items should appear normal */
    }

    .history-item:hover {
      background: rgba(102, 126, 234, 0.08);
      border-radius: 8px;
      margin-left: 1rem;
      margin-right: 0;
    }

    /* Tablet responsiveness */
    @media (min-width: 769px) and (max-width: 1024px) {
      /* Compact header for tablets */
      header {
        padding: 1rem; /* Reduce from 1.5rem to 1rem */
      }
      
      .header-title {
        font-size: 1.6rem; /* Reduce from 2rem to 1.6rem */
        margin-bottom: 0.5rem; /* Add small margin */
      }
      
      .header-info {
        gap: 1.5rem; /* Reduce from 2rem to 1.5rem */
        font-size: 0.9rem; /* Slightly smaller text */
      }
      
      .info-item {
        padding: 0.4rem 0.8rem; /* More compact info items */
      }
      
      /* Calendar optimizations */
      .calendar-widget {
        padding: 1rem;
        min-height: 300px !important; /* Much smaller for tablets */
        max-height: 300px !important; /* Force stable height */
        overflow: hidden;
        /* Enhanced isolation for tablets */
        contain: layout style size !important;
        transform: translateZ(0) !important;
        isolation: isolate;
      }
      
      .calendar-widget iframe {
        height: 250px !important; /* Much smaller calendar height for tablets */
        min-height: 250px !important;
        max-height: 250px !important;
        /* Force iframe isolation on tablets */
        contain: strict !important;
        transform: translateZ(0) !important;
        backface-visibility: hidden !important;
        position: relative !important;
        z-index: 1 !important;
      }
      
      .calendar-widget h2 {
        margin-bottom: 1rem; /* Reduce header margin */
      }
      
      .widget {
        padding: 1.5rem; /* Slightly reduce widget padding on tablets */
      }
      
      /* Make other widgets more compact on tablets */
      .todo-widget, .grocery-widget, .meals-widget {
        padding: 1.2rem;
      }
      
      /* Optimize main grid for better space usage */
      main {
        gap: 1rem; /* Reduce gap between widgets */
        padding: 1rem; /* Reduce main padding */
      }
    }

    /* Mobile responsiveness */
    @media (max-width: 768px) {
      main {
        grid-template-columns: 1fr;
        grid-template-rows: auto auto auto auto;
        padding: 1rem;
        gap: 1rem;
      }

      .calendar-widget {
        grid-column: 1;
        grid-row: 1;
      }

      .todo-widget {
        grid-column: 1;
        grid-row: 2;
      }

      .grocery-widget {
        grid-column: 1;
        grid-row: 3;
      }

      .meals-widget {
        grid-column: 1;
        grid-row: 4;
      }

      .widget {
        padding: 1.5rem;
      }

      header {
        padding: 1rem;
      }

      .header-title {
        font-size: 1.5rem;
      }

      .header-info {
        flex-direction: column;
        gap: 0.5rem;
      }

      .info-item {
        font-size: 0.9rem;
        padding: 0.4rem 0.8rem;
      }

      #precipitation-info {
        font-size: 0.8rem;
        padding: 0.3rem 0.6rem;
      }
      
      .add-item-container {
        flex-direction: column;
        gap: 8px;
      }
      
      .add-item-container button {
        padding: 14px;
        font-size: 16px;
      }
      
      .task-item {
        padding: 14px 0;
      }
      
      .task-text {
        font-size: 16px;
      }

      .task-actions {
        opacity: 1; /* Always show on mobile */
      }

      h2 {
        font-size: 1.25rem;
      }

      .fullscreen-header {
        padding: 1rem;
        flex-direction: column;
        gap: 1rem;
        text-align: center;
      }

      .fullscreen-title {
        font-size: 1.25rem;
      }

      .fullscreen-content {
        margin: 0.25rem;
        padding: 0.75rem 1rem;
      }

      .auto-return-indicator {
        display: none; /* Hide on mobile to save space */
      }
    }

    @media (max-width: 480px) {
      main {
        padding: 0.5rem;
      }

      .widget {
        padding: 1rem;
        border-radius: 16px;
      }

      header {
        font-size: 1.25rem;
      }
    }

    /* Dark mode support */
    @media (prefers-color-scheme: dark) {
      :root {
        --card-background: rgba(30, 41, 59, 0.95);
        --text-primary: #f1f5f9;
        --text-secondary: #94a3b8;
        --border-color: #334155;
      }

      .widget {
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .add-item-container input {
        background: rgba(30, 41, 59, 0.8);
        color: var(--text-primary);
        border-color: var(--border-color);
      }

      .add-item-container input:focus {
        background: rgba(30, 41, 59, 0.95);
      }
    }

    /* Reduced motion support */
    @media (prefers-reduced-motion: reduce) {
      * {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
    }
  </style>
</head>
<body>
  <!-- PWA Loading Screen -->
  <div id="pwa-loading-screen">
    <div class="loading-spinner"></div>
  </div>
  
  <!-- Landing Page -->
  <div id="landing-page" class="landing-page">
    <div class="landing-container">
      <h1 class="landing-title" id="landing-title">Bennett Hub</h1>
      <p class="landing-subtitle" id="landing-subtitle">Your Smart Dashboard</p>
      
      <!-- PWA Version Indicator Placeholder -->
      <div id="pwa-version-placeholder" style="text-align: center; margin-bottom: 1rem;"></div>
      
      <div class="navigation-grid">
        <button class="nav-button" onclick="showDashboard()">
          <span class="nav-icon">
            <img src="dashboard_icon.png?v=1126" alt="Dashboard" style="width: 2.5rem; height: 2.5rem; object-fit: cover; border-radius: 0; display: block;">
          </span>
          <span class="nav-label">Dashboard</span>
        </button>
        
        <button class="nav-button" onclick="showFullscreenCalendar()">
          <span class="nav-icon">
            <img src="google_icon_with_white_outline.png?v=1126" alt="Google Calendar" style="width: 2.5rem; height: 2.5rem; object-fit: cover; border-radius: 0; display: block;">
          </span>
          <span class="nav-label">Google</span>
          <span class="nav-label-secondary">Calendar</span>
        </button>
        
        <button class="nav-button" onclick="showFullscreenTodo()">
          <span class="nav-icon">
            <img src="to_do_list.png?v=1126" alt="To-Do List" style="width: 2.5rem; height: 2.5rem; object-fit: cover; border-radius: 0; display: block;">
          </span>
          <span class="nav-label">To-Do List</span>
        </button>
        
        <button class="nav-button" onclick="showFullscreenTodoHistory()">
          <span class="nav-icon">
            <img src="to_do_history.png?v=1126" alt="To-Do History" style="width: 2.5rem; height: 2.5rem; object-fit: cover; border-radius: 0; display: block;">
          </span>
          <span class="nav-label">To-Do History</span>
        </button>
        
        <button class="nav-button" onclick="showFullscreenTodoCalendar()">
          <span class="nav-icon">
            <img src="to_do_calendar.png?v=1126" alt="To-Do Calendar" style="width: 2.5rem; height: 2.5rem; object-fit: cover; border-radius: 0; display: block;">
          </span>
          <span class="nav-label">To-Do</span>
          <span class="nav-label-secondary">Calendar</span>
        </button>
        
        <button class="nav-button" onclick="showFullscreenGrocery()">
          <span class="nav-icon">
            <img src="shopping_cart.png?v=1126" alt="Grocery" style="width: 2.5rem; height: 2.5rem; object-fit: cover; border-radius: 0; display: block;">
          </span>
          <span class="nav-label">Grocery</span>
        </button>
        
        <button class="nav-button" onclick="showFullscreenMeals()">
          <span class="nav-icon">
            <img src="meals_icon.png?v=1126" alt="Meals" style="width: 2.5rem; height: 2.5rem; object-fit: cover; border-radius: 0; display: block;">
          </span>
          <span class="nav-label">Meals</span>
        </button>
        
        <button class="nav-button" onclick="showFullscreenMealsHistory()">
          <span class="nav-icon">
            <img src="recipe_book.png?v=1126" alt="Meal History" style="width: 2.5rem; height: 2.5rem; object-fit: cover; border-radius: 0; display: block;">
          </span>
          <span class="nav-label">Meal History</span>
        </button>
        
        <button class="nav-button" onclick="showFullscreenMedications()">
          <span class="nav-icon">
            <img src="medication.png?v=1126" alt="Medications" style="width: 2.5rem; height: 2.5rem; object-fit: cover; border-radius: 0; display: block;">
          </span>
          <span class="nav-label">Medications</span>
        </button>
        
        <button class="nav-button" onclick="showFullscreenDishwasher()">
          <span class="nav-icon" id="dishwasher-icon">ðŸ«§</span>
          <span class="nav-label">Dishwasher</span>
        </button>
      </div>
      
      <!-- Desktop Version Indicator -->
      <div id="desktop-version-indicator" style="
        position: fixed;
        bottom: 10px;
        left: 10px;
        font-size: 11px;
        color: rgba(255, 255, 255, 0.6);
        background: rgba(0, 0, 0, 0.3);
        padding: 4px 8px;
        border-radius: 4px;
        font-family: monospace;
        z-index: 1000;
        cursor: pointer;
        transition: all 0.2s ease;
      " onmouseover="this.style.background='rgba(0, 0, 0, 0.5)'" onmouseout="this.style.background='rgba(0, 0, 0, 0.3)'" onclick="showDesktopInfoPopup()">
        Desktop v10.71
      </div>
    </div>
  </div>

  <!-- Dashboard -->
  <div id="dashboard" class="dashboard" style="display: none;">
  <header>
    <button class="home-button" onclick="showLandingPage()" title="Home">Home</button>
    <h1 class="header-title" id="dashboard-title">Bennett Hub</h1>
    <div class="header-info">
      <div class="info-item">
        <span class="info-icon">ðŸ“…</span>
        <span id="current-date">Loading...</span>
      </div>
      <div class="info-item">
        <span class="info-icon">ðŸ•</span>
        <span id="current-time">Loading...</span>
      </div>
      <div class="info-item">
        <span id="weather-icon" class="info-icon">ðŸŒ¡ï¸</span>
        <span id="current-temp" class="weather-temp loading">Loading...</span>
      </div>
          <div class="info-item" id="precipitation-info" style="display: none;">
            <span id="precip-icon" class="info-icon">ðŸ’§</span>
            <span id="precip-details" class="weather-temp">--</span>
          </div>
          <div class="info-item" id="sync-status" onclick="manualSync()" style="cursor: pointer;" title="Click to force sync">
            <span id="sync-icon" class="info-icon">â˜ï¸</span>
            <span id="sync-text" class="weather-temp">Synced</span>
          </div>
          <div class="info-item" onclick="setupGithubAuth()" style="cursor: pointer;" title="Setup GitHub sync">
            <span class="info-icon">ðŸ”</span>
            <span class="weather-temp">GitHub</span>
          </div>
          <div class="info-item" onclick="showDebugInfo()" style="cursor: pointer;" title="Show debug info">
            <span class="info-icon">ðŸ”</span>
            <span class="weather-temp">Debug</span>
          </div>
        </div>
      </header>
  <main>
    <!-- Google Calendar -->
    <div class="widget calendar-widget" id="calendar-widget">
      <h2 onclick="openFullscreen('calendar')" style="cursor: pointer;">Calendar</h2>
      <div id="custom-calendar-content">
        <!-- Custom calendar will be rendered here -->
      </div>
    </div>

    <!-- To-Do List -->
    <div class="widget todo-widget" id="todo-widget">
      <div style="position: relative; text-align: center; margin-bottom: 1.5rem;">
        <button onclick="showFullscreenTodoCalendar()" class="calendar-button" style="position: absolute; left: 0; top: 50%; transform: translateY(-50%); padding: 4px 8px; background: var(--primary-color); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; z-index: 10;">ðŸ“… Calendar</button>
        <h2 onclick="openFullscreen('todo')" style="margin: 0; cursor: pointer; display: inline-block; padding: 0 80px;">To-Do List</h2>
        <button onclick="showTodoHistory()" class="history-button">History</button>
      </div>
      <div class="add-item-container" id="todo-add-container">
        <input type="text" id="todo-input" placeholder="Add new task..." maxlength="100">
        <button onclick="addTodoItem()" id="add-todo-btn">Add</button>
      </div>
      <div class="add-item-container" id="todo-secondary-container" style="margin-top: 0.5rem;">
        <input type="date" id="todo-due-date" title="Due date (optional)">
        <div class="avatar-filters-container">
          <span class="avatar-filter emley" data-avatar="emley" onclick="toggleAvatarFilter('emley')" title="Filter by Emley">E</span>
          <span class="avatar-filter nate" data-avatar="nate" onclick="toggleAvatarFilter('nate')" title="Filter by Nate">N</span>
          <span class="avatar-filter family" data-avatar="family" onclick="toggleAvatarFilter('family')" title="Filter by Family">F</span>
        </div>
      </div>
      <ul id="todo-list" class="task-list">
        <!-- Dynamic content will be loaded here -->
      </ul>
    </div>

    <!-- Grocery List -->
    <div class="widget grocery-widget" id="grocery-widget">
      <h2 onclick="openFullscreen('grocery')">Grocery List</h2>
      <div class="add-item-container">
        <input type="text" id="grocery-input" placeholder="Add grocery item..." maxlength="100">
        <button onclick="addGroceryItem()" id="add-grocery-btn">Add</button>
      </div>
      <ul id="grocery-list" class="task-list">
        <!-- Dynamic content will be loaded here -->
      </ul>
    </div>

    <!-- Meals List -->
    <div class="widget meals-widget" id="meals-widget">
      <div style="position: relative; text-align: center; margin-bottom: 1.5rem;">
        <h2 onclick="openFullscreen('meals')" style="margin: 0; cursor: pointer;">Meals</h2>
        <button onclick="showMealsHistory()" class="history-button">History</button>
      </div>
      <div class="add-item-container" id="meals-add-container">
        <input type="text" id="meals-input" placeholder="Add meal..." maxlength="100">
        <button onclick="addMealItem()" id="add-meals-btn">Add</button>
      </div>
      <ul id="meals-list" class="task-list">
        <!-- Dynamic content will be loaded here -->
      </ul>
    </div>
  </main>

  <script>
    // Device Detection
    const isFireTV = /Silk/.test(navigator.userAgent) || /AFTT/.test(navigator.userAgent);
    console.log('Device detection:', { isFireTV, userAgent: navigator.userAgent });
    
    // Google Calendar API Configuration
    const GOOGLE_CALENDAR_API_KEY = 'AIzaSyBxgE3kxzaI_J_f3lnndONO57txK_Idc7Y';
    const CALENDAR_IDS = {
      emley: 'holcombe.emley@gmail.com',
      nate: '2natertots@gmail.com'
    };
    const CALENDAR_COLORS = {
      emley: '#d946ef',
      nate: '#60a5fa'
    };
    let calendarEvents = [];
    let calendarFilters = { emley: true, nate: true };
    let calendarLastFetch = null;
    const CALENDAR_CACHE_DURATION = 5 * 60 * 1000; // 5 minutes

    // Fetch events from Google Calendar API
    async function fetchCalendarEvents(forceRefresh = false) {
      // Use cache if available and not expired
      if (!forceRefresh && calendarLastFetch && (Date.now() - calendarLastFetch < CALENDAR_CACHE_DURATION)) {
        return calendarEvents;
      }

      const now = new Date();
      const timeMin = now.toISOString();
      const timeMax = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000).toISOString(); // 30 days ahead
      
      const allEvents = [];
      
      for (const [owner, calendarId] of Object.entries(CALENDAR_IDS)) {
        try {
          const url = `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(calendarId)}/events?` +
            `key=${GOOGLE_CALENDAR_API_KEY}&` +
            `timeMin=${encodeURIComponent(timeMin)}&` +
            `timeMax=${encodeURIComponent(timeMax)}&` +
            `singleEvents=true&` +
            `orderBy=startTime&` +
            `maxResults=100`;
          
          const response = await fetch(url);
          
          if (!response.ok) {
            console.error(`Failed to fetch ${owner}'s calendar:`, response.status);
            continue;
          }
          
          const data = await response.json();
          
          if (data.items) {
            data.items.forEach(event => {
              allEvents.push({
                id: event.id,
                title: event.summary || 'Untitled Event',
                start: event.start.dateTime || event.start.date,
                end: event.end.dateTime || event.end.date,
                isAllDay: !event.start.dateTime,
                location: event.location || null,
                description: event.description || null,
                owner: owner,
                color: CALENDAR_COLORS[owner]
              });
            });
          }
        } catch (error) {
          console.error(`Error fetching ${owner}'s calendar:`, error);
        }
      }
      
      // Sort all events by start time
      allEvents.sort((a, b) => new Date(a.start) - new Date(b.start));
      
      calendarEvents = allEvents;
      calendarLastFetch = Date.now();
      
      return allEvents;
    }

    // Format time for display
    function formatEventTime(dateString, isAllDay) {
      if (isAllDay) return 'All day';
      
      const date = new Date(dateString);
      return date.toLocaleTimeString('en-US', { 
        hour: 'numeric', 
        minute: '2-digit',
        hour12: true 
      });
    }

    // Format date header
    function formatDateHeader(dateString) {
      const date = new Date(dateString);
      const today = new Date();
      const tomorrow = new Date(today);
      tomorrow.setDate(tomorrow.getDate() + 1);
      
      const isToday = date.toDateString() === today.toDateString();
      const isTomorrow = date.toDateString() === tomorrow.toDateString();
      
      if (isToday) return { text: 'Today', isToday: true };
      if (isTomorrow) return { text: 'Tomorrow', isToday: false };
      
      const dayName = date.toLocaleDateString('en-US', { weekday: 'long' });
      const monthDay = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
      
      return { text: `${dayName}, ${monthDay}`, isToday: false };
    }

    // Get date key for grouping
    function getDateKey(dateString) {
      const date = new Date(dateString);
      return date.toDateString();
    }

    // Render custom calendar
    async function renderCustomCalendar(container, isFullscreen = false) {
      container.innerHTML = `
        <div class="calendar-loading">
          <div class="calendar-loading-spinner"></div>
          <span>Loading calendar...</span>
        </div>
      `;
      
      try {
        const events = await fetchCalendarEvents();
        
        // Filter events based on active filters
        const filteredEvents = events.filter(event => calendarFilters[event.owner]);
        
        if (filteredEvents.length === 0) {
          container.innerHTML = `
            <div class="calendar-toggle-container">
              <button class="calendar-toggle emley ${calendarFilters.emley ? 'active' : ''}" onclick="toggleCalendarFilter('emley')">
                Emley
              </button>
              <button class="calendar-toggle nate ${calendarFilters.nate ? 'active' : ''}" onclick="toggleCalendarFilter('nate')">
                Nate
              </button>
            </div>
            <div class="calendar-no-events">No upcoming events</div>
          `;
          return;
        }
        
        // Group events by date
        const groupedEvents = {};
        filteredEvents.forEach(event => {
          const dateKey = getDateKey(event.start);
          if (!groupedEvents[dateKey]) {
            groupedEvents[dateKey] = [];
          }
          groupedEvents[dateKey].push(event);
        });
        
        // Build HTML
        let html = `
          <div class="calendar-toggle-container">
            <button class="calendar-toggle emley ${calendarFilters.emley ? 'active' : ''}" onclick="toggleCalendarFilter('emley')">
              Emley
            </button>
            <button class="calendar-toggle nate ${calendarFilters.nate ? 'active' : ''}" onclick="toggleCalendarFilter('nate')">
              Nate
            </button>
          </div>
          <div class="custom-calendar-container">
        `;
        
        for (const [dateKey, dayEvents] of Object.entries(groupedEvents)) {
          const header = formatDateHeader(dayEvents[0].start);
          
          html += `
            <div class="calendar-date-group">
              <div class="calendar-date-header ${header.isToday ? 'today' : ''}">${header.text}</div>
          `;
          
          dayEvents.forEach(event => {
            const timeDisplay = formatEventTime(event.start, event.isAllDay);
            const locationHtml = event.location ? 
              `<div class="calendar-event-location">${event.location}</div>` : '';
            
            html += `
              <div class="calendar-event ${event.owner}-event">
                <div class="calendar-event-time ${event.isAllDay ? 'all-day' : ''}">${timeDisplay}</div>
                <div class="calendar-event-details">
                  <div class="calendar-event-title">${event.title}</div>
                  ${locationHtml}
                </div>
              </div>
            `;
          });
          
          html += '</div>';
        }
        
        html += '</div>';
        container.innerHTML = html;
        
      } catch (error) {
        console.error('Error rendering calendar:', error);
        container.innerHTML = `
          <div class="calendar-error">
            <p>Failed to load calendar</p>
            <button onclick="refreshCalendar()">Try Again</button>
          </div>
        `;
      }
    }

    // Toggle calendar filter
    function toggleCalendarFilter(owner) {
      calendarFilters[owner] = !calendarFilters[owner];
      
      // Make sure at least one filter is active
      if (!calendarFilters.emley && !calendarFilters.nate) {
        calendarFilters[owner] = true;
      }
      
      // Re-render calendar in both widget and fullscreen if open
      const widgetContainer = document.getElementById('custom-calendar-content');
      if (widgetContainer) {
        renderCustomCalendar(widgetContainer, false);
      }
      
      const fullscreenContainer = document.querySelector('.fullscreen-content .custom-calendar-container')?.parentElement;
      if (fullscreenContainer) {
        renderCustomCalendar(fullscreenContainer, true);
      }
    }

    // Refresh calendar (force fetch)
    async function refreshCalendar() {
      calendarLastFetch = null; // Clear cache
      
      const widgetContainer = document.getElementById('custom-calendar-content');
      if (widgetContainer) {
        await renderCustomCalendar(widgetContainer, false);
      }
    }

    // Initialize calendar on page load
    function initializeCustomCalendar() {
      const container = document.getElementById('custom-calendar-content');
      if (container) {
        renderCustomCalendar(container, false);
      }
    }

    // GitHub Sync Configuration
    const GITHUB_USERNAME = 'emleyholcombe'; // Your GitHub username
    let GIST_ID = localStorage.getItem('dashboardGistId') || null;
    const GIST_FILENAME = 'smart-dashboard-data.json';
    let GITHUB_TOKEN = localStorage.getItem('githubToken') || null; // Personal Access Token
    
    // GitHub API endpoints
    const GITHUB_API_BASE = 'https://api.github.com';
    const GISTS_API = `${GITHUB_API_BASE}/gists`;
    
    // Legacy JSONBin.io support (deprecated but kept for migration)
    let JSONBIN_ID = localStorage.getItem('dashboardJsonBinId') || null;
    const JSONBIN_API = 'https://api.jsonbin.io/v3/b';
    
    // Data storage
    let todoItems = [];
    let todoHistory = [];
    let groceryItems = [];
    let mealItems = [];
    let mealHistory = [];
    let medications = {
      earlyMorning: { taken: false, timestamp: null },
      morning: { taken: false, timestamp: null },
      evening: { taken: false, timestamp: null },
      lastReset: new Date().toDateString() // Reset daily
    };
    let medicationsHistory = []; // Array of { date, earlyMorning: {taken, timestamp}, morning: {taken, timestamp}, evening: {taken, timestamp} }
    let showingMedicationsHistory = false;
    let dishwasher = {
      status: 'dirty', // 'clean' or 'dirty'
      timestamp: new Date().toISOString(),
      lastUpdated: new Date().toISOString()
    };
    
    // Data sync status
    let isOnline = navigator.onLine;
    let syncInProgress = false;
    
    // JSONBin.io API functions (free, no auth required)
    async function createJsonBin(data) {
      try {
        console.log('ðŸ”„ Creating JSONBin with data:', data);
        console.log('ðŸ“¡ Sending to:', JSONBIN_API);
        
        const payload = {
          dashboardData: data,
          created: new Date().toISOString(),
          version: '1.0'
        };
        
        const response = await fetch(`${JSONBIN_API}`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-Bin-Private': 'false'
          },
          body: JSON.stringify(payload)
        });
        
        console.log('ðŸ“¡ Response status:', response.status, response.statusText);
        
        if (response.ok) {
          const result = await response.json();
          console.log('ðŸ“¦ Full response:', result);
          
          if (result.metadata && result.metadata.id) {
            JSONBIN_ID = result.metadata.id;
            localStorage.setItem('dashboardJsonBinId', JSONBIN_ID);
            console.log('âœ… Created new JSONBin:', JSONBIN_ID);
            return true;
          } else {
            console.error('âŒ Invalid response structure:', result);
            return false;
          }
        }
        
        const errorText = await response.text();
        console.error('âŒ JSONBin creation failed:', response.status, errorText);
        
        // Try alternative approach with a simpler request
        if (response.status === 401 || response.status === 403) {
          console.log('ðŸ”„ Trying alternative approach...');
          return await createSimpleStorage(data);
        }
        
        return false;
      } catch (error) {
        console.error('ðŸ’¥ Exception creating JSONBin:', error);
        console.log('ðŸ”„ Trying alternative approach...');
        return await createSimpleStorage(data);
      }
    }
    
    // Fallback storage using a simpler service
    async function createSimpleStorage(data) {
      try {
        // Use dpaste.org as fallback
        const formData = new FormData();
        formData.append('content', JSON.stringify(data, null, 2));
        formData.append('syntax', 'json');
        formData.append('expiry_days', '365');
        
        const response = await fetch('https://dpaste.org/api/', {
          method: 'POST',
          body: formData
        });
        
        if (response.ok) {
          const pasteUrl = await response.text();
          JSONBIN_ID = pasteUrl.trim().split('/').pop();
          localStorage.setItem('dashboardJsonBinId', JSONBIN_ID);
          localStorage.setItem('dashboardSyncType', 'dpaste');
          console.log('âœ… Created dpaste backup:', JSONBIN_ID);
          return true;
        }
        
        console.error('âŒ Fallback storage also failed');
        return false;
      } catch (error) {
        console.error('ðŸ’¥ Fallback storage failed:', error);
        return false;
      }
    }
    
    async function updateJsonBin(data) {
      if (!JSONBIN_ID) return false;
      
      try {
        const response = await fetch(`${JSONBIN_API}/${JSONBIN_ID}`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            dashboardData: data,
            updated: new Date().toISOString(),
            version: '1.0'
          })
        });
        
        if (response.ok) {
          console.log('âœ… Updated JSONBin successfully:', JSONBIN_ID);
          return true;
        }
        const errorText = await response.text();
        console.error('âŒ JSONBin update failed:', response.status, errorText);
        throw new Error(`HTTP ${response.status}: ${errorText}`);
      } catch (error) {
        console.error('Failed to update JSONBin:', error);
        return false;
      }
    }
    
    async function loadFromJsonBin() {
      if (!JSONBIN_ID) {
        console.log('âŒ No JSONBIN_ID found');
        return null;
      }
      
      try {
        const url = `${JSONBIN_API}/${JSONBIN_ID}/latest`;
        console.log('ðŸŒ Fetching from:', url);
        
        const response = await fetch(url);
        console.log('ðŸ“¡ Response status:', response.status, response.statusText);
        
        if (response.ok) {
          const result = await response.json();
          console.log('ðŸ“¦ Raw response:', result);
          
          if (result.record && result.record.dashboardData) {
            console.log('âœ… Successfully parsed JSONBin data');
            return result.record.dashboardData;
          } else {
            console.log('âŒ Invalid data structure in JSONBin response');
            console.log('Expected: result.record.dashboardData');
            console.log('Got:', Object.keys(result));
          }
        } else {
          const errorText = await response.text();
          console.error('âŒ JSONBin fetch failed:', response.status, errorText);
        }
        throw new Error(`HTTP ${response.status}`);
      } catch (error) {
        console.error('ðŸ’¥ Exception loading from JSONBin:', error);
        return null;
      }
    }
    
    // GitHub Gist API functions for master data storage
    async function createGithubGist(data) {
      if (!GITHUB_TOKEN) {
        console.log('âŒ No GitHub token found. Please set up authentication first.');
        return false;
      }
      
      try {
        console.log('ðŸ”„ Creating GitHub Gist with data:', data);
        
        const gistPayload = {
          description: "Smart Dashboard - Master Data Storage",
          public: false, // Private gist for security
          files: {
            [GIST_FILENAME]: {
              content: JSON.stringify({
                dashboardData: data,
                created: new Date().toISOString(),
                version: '2.0',
                device: navigator.userAgent.includes('Mobile') ? 'Mobile' : 'Desktop'
              }, null, 2)
            }
          }
        };
        
        const response = await fetch(GISTS_API, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${GITHUB_TOKEN}`,
            'Content-Type': 'application/json',
            'Accept': 'application/vnd.github.v3+json'
          },
          body: JSON.stringify(gistPayload)
        });
        
        console.log('ðŸ“¡ Response status:', response.status, response.statusText);
        
        if (response.ok) {
          const result = await response.json();
          console.log('ðŸ“¦ Gist created:', result.id);
          
          GIST_ID = result.id;
          localStorage.setItem('dashboardGistId', GIST_ID);
          console.log('âœ… Created new GitHub Gist:', GIST_ID);
          return true;
        } else {
          const errorText = await response.text();
          console.error('âŒ GitHub Gist creation failed:', response.status, errorText);
          return false;
        }
      } catch (error) {
        console.error('ðŸ’¥ Exception creating GitHub Gist:', error);
        return false;
      }
    }

    async function updateGithubGist(data) {
      if (!GIST_ID) return await createGithubGist(data);
      if (!GITHUB_TOKEN) {
        console.log('âŒ No GitHub token found. Please set up authentication first.');
        return false;
      }
      
      try {
        console.log('ðŸ”„ Updating GitHub Gist:', GIST_ID);
        
        const gistPayload = {
          description: "Smart Dashboard - Master Data Storage",
          files: {
            [GIST_FILENAME]: {
              content: JSON.stringify({
                dashboardData: data,
                updated: new Date().toISOString(),
                version: '2.0',
                device: navigator.userAgent.includes('Mobile') ? 'Mobile' : 'Desktop'
              }, null, 2)
            }
          }
        };
        
        const response = await fetch(`${GISTS_API}/${GIST_ID}`, {
          method: 'PATCH',
          headers: {
            'Authorization': `Bearer ${GITHUB_TOKEN}`,
            'Content-Type': 'application/json',
            'Accept': 'application/vnd.github.v3+json'
          },
          body: JSON.stringify(gistPayload)
        });
        
        if (response.ok) {
          const result = await response.json();
          const updatedAt = result.updated_at || new Date().toISOString();
          console.log('âœ… Updated GitHub Gist successfully');
          console.log('ðŸ“Š Gist updated at:', updatedAt);
          return true;
        } else {
          const errorText = await response.text();
          console.error('âŒ GitHub Gist update failed:', response.status, errorText);
          return false;
        }
      } catch (error) {
        console.error('ðŸ’¥ Exception updating GitHub Gist:', error);
        return false;
      }
    }
    
    async function loadFromGithubGist() {
      if (!GIST_ID) {
        console.log('âŒ No GIST_ID found');
        return null;
      }
      
      try {
        // Add cache-busting parameter to ensure fresh data
        const cacheBuster = Date.now();
        const url = `${GISTS_API}/${GIST_ID}?_=${cacheBuster}`;
        console.log('ðŸŒ Fetching from GitHub Gist:', url);
        
        const headers = {
          'Accept': 'application/vnd.github.v3+json'
        };
        
        // Add auth header if we have a token (for private gists)
        if (GITHUB_TOKEN) {
          headers['Authorization'] = `Bearer ${GITHUB_TOKEN}`;
        }
        
        const response = await fetch(url, { 
          headers,
          cache: 'no-store'
        });
        console.log('ðŸ“¡ Response status:', response.status, response.statusText);
        
        if (response.ok) {
          const result = await response.json();
          console.log('ðŸ“¦ Gist response received');
          
          if (result.files && result.files[GIST_FILENAME]) {
            const fileContent = result.files[GIST_FILENAME].content;
            const parsedData = JSON.parse(fileContent);
            
            if (parsedData.dashboardData) {
              console.log('âœ… Successfully parsed GitHub Gist data');
              console.log('ðŸ“Š Last updated:', parsedData.updated || parsedData.created);
              return parsedData.dashboardData;
            } else {
              console.log('âŒ Invalid data structure in Gist');
            }
          } else {
            console.log('âŒ Gist file not found:', GIST_FILENAME);
          }
        } else {
          const errorText = await response.text();
          console.error('âŒ GitHub Gist fetch failed:', response.status, errorText);
        }
        
        return null;
      } catch (error) {
        console.error('ðŸ’¥ Exception loading from GitHub Gist:', error);
        return null;
      }
    }
    
    // GitHub token setup function
    async function setupGithubAuth() {
      // Check if token already exists
      if (GITHUB_TOKEN) {
        const response = confirm(`
ðŸ” GitHub Authentication

You already have a GitHub token configured.

Current status: 
ðŸ™ GitHub Gist ID: ${GIST_ID || 'Not created yet'}
ðŸ”‘ Token: ${GITHUB_TOKEN.substring(0, 8)}...

Do you want to:
â€¢ OK = Exit without changes
â€¢ Cancel = Update token`);
        
        if (response) {
          // User clicked OK - exit without changes
          return false;
        }
        // User clicked Cancel - continue to update token
      }
      
      // Show instructions and collect token
      const instructions = `
ðŸ” GitHub Authentication Setup

To enable GitHub sync, you need a Personal Access Token.

STEP-BY-STEP INSTRUCTIONS:
1. Click OK to open GitHub settings
2. Click "Generate new token" â†’ "Tokens (classic)"
3. Add note: "Smart Dashboard Sync"
4. Set expiration: 1 year (or your preference)
5. Check ONLY the "gist" scope âœ…
6. Click "Generate token"
7. Copy the token (starts with ghp_...)
8. Come back here and paste it

Ready to continue?`;
      
      if (!confirm(instructions)) {
        return false;
      }
      
      // Open GitHub token page
      window.open('https://github.com/settings/tokens/new?scopes=gist&description=Smart%20Dashboard%20Sync', '_blank');
      
      // Wait a moment then ask for token
      setTimeout(() => {
        const token = prompt(`
ðŸ”‘ Paste your GitHub Personal Access Token:

The token should start with "ghp_" and be about 40 characters long.

Token:`);
        
        if (token && token.trim() && token.startsWith('ghp_')) {
          localStorage.setItem('githubToken', token.trim());
          GITHUB_TOKEN = token.trim();
          console.log('âœ… GitHub token saved!');
          updateSyncStatus();
          alert('âœ… GitHub authentication setup complete!\n\nðŸ™ Your data will now sync to your private GitHub gist.\nðŸ“± All your devices will stay in sync!');
          
          // Try to migrate existing data if available
          if (todoItems.length || groceryItems.length || mealItems.length) {
            saveAllData();
          }
          
          return true;
        } else if (token) {
          alert('âŒ Invalid token format. GitHub tokens start with "ghp_".\n\nClick the GitHub button again to retry.');
          return false;
        } else {
          alert('âŒ No token provided. GitHub sync will not work.');
          return false;
        }
      }, 2000);
    }
    
    // Unified data management
    function getCurrentData() {
      return {
        todoItems,
        todoHistory,
        groceryItems,
        mealItems,
        mealHistory,
        medications,
        medicationsHistory,
        dishwasher,
        lastUpdated: new Date().toISOString()
      };
    }
    
    function setCurrentData(data) {
      if (data.todoItems) {
        todoItems = data.todoItems;
        updateItemOrders(todoItems); // Ensure all items have order property
      }
      if (data.todoHistory) {
        todoHistory = data.todoHistory;
        updateItemOrders(todoHistory); // Ensure all items have order property
      }
      if (data.groceryItems) {
        groceryItems = data.groceryItems;
        updateItemOrders(groceryItems); // Ensure all items have order property
      }
      if (data.mealItems) {
        mealItems = data.mealItems;
        updateItemOrders(mealItems); // Ensure all items have order property
      }
      if (data.mealHistory) {
        mealHistory = data.mealHistory;
        updateItemOrders(mealHistory); // Ensure all items have order property
      }
      if (data.medications) {
        medications = data.medications;
        // Ensure earlyMorning exists for backward compatibility
        if (!medications.earlyMorning) {
          medications.earlyMorning = { taken: false, timestamp: null };
        }
        checkAndResetMedications(); // Ensure daily reset
      }
      if (data.medicationsHistory) {
        medicationsHistory = data.medicationsHistory;
      }
      if (data.dishwasher) {
        dishwasher = data.dishwasher;
      }
    }
    
    // Save to both localStorage and GitHub Gist (master storage)
    async function saveAllData() {
      if (syncInProgress) return;
      syncInProgress = true;
      updateSyncStatus();
      
      const data = getCurrentData();
      
      // Always save to localStorage as backup
      localStorage.setItem('todoItems', JSON.stringify(todoItems));
      localStorage.setItem('todoHistory', JSON.stringify(todoHistory));
      localStorage.setItem('groceryItems', JSON.stringify(groceryItems));
      localStorage.setItem('mealItems', JSON.stringify(mealItems));
      localStorage.setItem('mealHistory', JSON.stringify(mealHistory));
      localStorage.setItem('medications', JSON.stringify(medications));
      localStorage.setItem('medicationsHistory', JSON.stringify(medicationsHistory));
      localStorage.setItem('dishwasher', JSON.stringify(dishwasher));
      
      // Try to sync to GitHub Gist (master storage) if online
      if (isOnline) {
        let success = false;
        
        // If no GitHub token, ask user to set it up
        if (!GITHUB_TOKEN) {
          console.log('ðŸ” No GitHub token found - prompting user setup');
          const setupSuccess = await setupGithubAuth();
          if (!setupSuccess) {
            console.log('âŒ GitHub auth setup cancelled, data saved locally only');
            syncInProgress = false;
            updateSyncStatus();
            return;
          }
        }
        
        // Try GitHub Gist sync
        if (GIST_ID) {
          success = await updateGithubGist(data);
        } else {
          success = await createGithubGist(data);
        }
        
        if (success) {
          console.log('âœ… Data synced to GitHub master storage');
        } else {
          console.log('âŒ GitHub sync failed, falling back to JSONBin...');
          
          // Fallback to JSONBin for backward compatibility
          if (JSONBIN_ID) {
            success = await updateJsonBin(data);
          } else {
            success = await createJsonBin(data);
          }
          
          if (success) {
            console.log('âœ… Data synced to JSONBin fallback');
          } else {
            console.log('âŒ All cloud sync failed, data saved locally only');
          }
        }
      }
      
      syncInProgress = false;
      updateSyncStatus();
    }
    
    // Manual sync function for debugging
    async function manualSync() {
      console.log('ðŸ”„ Manual sync triggered...');
      console.log('Current data:', getCurrentData());
      console.log('JSONBIN_ID:', JSONBIN_ID);
      console.log('isOnline:', isOnline);
      
      if (!isOnline) {
        alert('âŒ Cannot sync: You are offline');
        return;
      }
      
      const data = getCurrentData();
      const totalItems = data.todoItems.length + data.groceryItems.length + data.mealItems.length + data.todoHistory.length + data.mealHistory.length;
      
      if (totalItems === 0) {
        alert('âš ï¸ No data to sync! Add some items first, then try syncing.');
        return;
      }
      
      console.log(`ðŸ”„ Syncing ${totalItems} items...`);
      
      try {
        syncInProgress = true;
        updateSyncStatus();
        
        await saveAllData();
        
        let syncStatus;
        if (GIST_ID && GITHUB_TOKEN) {
          syncStatus = `âœ… Synced to GitHub master storage!\nGist ID: ${GIST_ID}`;
        } else if (JSONBIN_ID) {
          syncStatus = `âœ… Synced to fallback storage!\nSync ID: ${JSONBIN_ID}`;
        } else {
          syncStatus = 'âŒ Sync failed - no cloud storage created';
        }
        
        const debugInfo = `
${syncStatus}

ðŸ“Š Synced data:
ðŸ“ ${data.todoItems.length} current todos
ðŸ“‹ ${data.todoHistory.length} todo history
ðŸ›’ ${data.groceryItems.length} grocery items  
ðŸ½ï¸ ${data.mealItems.length} current meals
ðŸ“š ${data.mealHistory.length} meal history
â° Last Updated: ${data.lastUpdated}

${(GIST_ID && GITHUB_TOKEN) || JSONBIN_ID ? 'âœ… Your data is now available on all devices!' : ''}
        `;
        
        alert(debugInfo);
        
      } catch (error) {
        console.error('Sync failed:', error);
        alert(`âŒ Sync failed: ${error.message}`);
      } finally {
        syncInProgress = false;
        updateSyncStatus();
      }
    }
    
    // Debug function to show current state
    async function showDebugInfo() {
      const data = getCurrentData();
      
      // GitHub Status
      const githubStatus = (GIST_ID && GITHUB_TOKEN) ? 
        `âœ… GitHub Gist: ${GIST_ID}` : 
        `âŒ GitHub: ${!GITHUB_TOKEN ? 'No token' : 'No gist ID'}`;
      
      // JSONBin Status  
      const jsonbinStatus = JSONBIN_ID ? `âœ… JSONBin ID: ${JSONBIN_ID}` : 'âŒ No JSONBin';
      
      // Try to fetch cloud data for comparison
      let cloudStatus = 'Not checked';
      if (GIST_ID && GITHUB_TOKEN) {
        try {
          const cloudData = await loadFromGithubGist();
          if (cloudData) {
            cloudStatus = `âœ… GitHub has ${cloudData.todoItems?.length || 0} todos, ${cloudData.groceryItems?.length || 0} groceries, ${cloudData.mealItems?.length || 0} meals`;
          } else {
            cloudStatus = 'âŒ Failed to load GitHub data';
          }
        } catch (error) {
          cloudStatus = `âŒ GitHub Error: ${error.message}`;
        }
      } else if (JSONBIN_ID) {
        try {
          const cloudData = await loadFromJsonBin();
          if (cloudData) {
            cloudStatus = `âœ… JSONBin has ${cloudData.todoItems?.length || 0} todos, ${cloudData.groceryItems?.length || 0} groceries, ${cloudData.mealItems?.length || 0} meals`;
          } else {
            cloudStatus = 'âŒ Failed to load JSONBin data';
          }
        } catch (error) {
          cloudStatus = `âŒ JSONBin Error: ${error.message}`;
        }
      }
      
      const debugInfo = `
ðŸ“Š Dashboard Debug Info:

ðŸ” Authentication:
ðŸ™ GitHub Token: ${GITHUB_TOKEN ? `${GITHUB_TOKEN.substring(0, 8)}...` : 'Not set'}
ðŸ™ ${githubStatus}
â˜ï¸ ${jsonbinStatus}

ðŸŒ Status:
Online: ${isOnline}
Sync: ${syncInProgress ? 'In Progress' : 'Idle'}
Cloud Status: ${cloudStatus}

ðŸ“± Local Data:
ðŸ“ Todo Items: ${data.todoItems.length}
ðŸ“‹ Todo History: ${data.todoHistory.length}
ðŸ›’ Grocery Items: ${data.groceryItems.length}
ðŸ½ï¸ Meal Items: ${data.mealItems.length}
ðŸ½ï¸ Meal History: ${data.mealHistory.length}
â° Last Updated: ${data.lastUpdated}

ðŸ”§ localStorage Check:
GitHub Token: ${localStorage.getItem('githubToken') ? 'Saved' : 'Missing'}
Gist ID: ${localStorage.getItem('dashboardGistId') ? 'Saved' : 'Missing'}
JSONBin ID: ${localStorage.getItem('dashboardJsonBinId') ? 'Saved' : 'Missing'}

ðŸ“‹ Current Sync Method: ${(GIST_ID && GITHUB_TOKEN) ? 'GitHub (Master)' : JSONBIN_ID ? 'JSONBin (Fallback)' : 'Local Only'}
      `;
      
      alert(debugInfo);
      
      // No more confusing options - just show the info
      return;
      
      // Remove old debug options code
      if (false) {
        // Prompt for sync ID
        const newSyncId = prompt('Enter sync ID from your other device:');
        if (newSyncId && newSyncId.trim()) {
          JSONBIN_ID = newSyncId.trim();
          localStorage.setItem('dashboardJsonBinId', JSONBIN_ID);
          console.log('ðŸ”§ Setting new sync ID:', JSONBIN_ID);
          
          try {
            alert('âœ… Sync ID saved! Loading data from cloud...\n\nCheck console for details.');
            console.log('ðŸ”„ Starting loadAllData...');
            await loadAllData();
            console.log('âœ… loadAllData completed');
            
            // Force re-render all lists
            renderTodoList();
            renderGroceryList();
            renderMealsList();
            console.log('âœ… All lists re-rendered');
            
            // Show final status
            const finalData = getCurrentData();
            const totalItems = finalData.todoItems.length + finalData.groceryItems.length + finalData.mealItems.length + finalData.todoHistory.length + finalData.mealHistory.length;
            
            if (totalItems > 0) {
              alert(`ðŸŽ‰ Success! Loaded ${totalItems} items:\nðŸ“ ${finalData.todoItems.length} todos\nðŸ“‹ ${finalData.todoHistory.length} todo history\nðŸ›’ ${finalData.groceryItems.length} groceries\nðŸ½ï¸ ${finalData.mealItems.length} meals\nðŸ“š ${finalData.mealHistory.length} meal history`);
            } else {
              alert('âš ï¸ No items loaded. Check console for errors or verify the sync ID is correct.');
            }
            
          } catch (error) {
            console.error('âŒ Error loading data:', error);
            alert(`âŒ Error loading data: ${error.message}\n\nCheck console for details.`);
          }
        }
      }
      
      console.log('Debug Info:', data);
    }
    
    // Update sync status indicator
    function updateSyncStatus() {
      const syncIcon = document.getElementById('sync-icon');
      const syncText = document.getElementById('sync-text');
      
      if (!syncIcon || !syncText) return;
      
      if (syncInProgress) {
        syncIcon.textContent = 'ðŸ”„';
        syncText.textContent = 'Syncing...';
      } else if (!isOnline) {
        syncIcon.textContent = 'ðŸ“±';
        syncText.textContent = 'Offline';
      } else if (GIST_ID && GITHUB_TOKEN) {
        syncIcon.textContent = 'ðŸ™';
        syncText.textContent = 'GitHub';
      } else if (JSONBIN_ID) {
        syncIcon.textContent = 'â˜ï¸';
        syncText.textContent = 'Cloud';
      } else {
        syncIcon.textContent = 'ðŸ’¾';
        syncText.textContent = 'Local';
      }
    }
    
    // Load data from GitHub Gist (master) -> JSONBin (fallback) -> localStorage
    async function loadAllData() {
      console.log('ðŸ”„ Loading dashboard data...');
      console.log('ðŸ“Š Initial state:', {
        isOnline,
        hasGistId: !!GIST_ID,
        hasJsonBinId: !!JSONBIN_ID,
        hasGithubToken: !!GITHUB_TOKEN,
        userAgent: navigator.userAgent.includes('Mobile') ? 'Mobile' : 'Desktop'
      });
      
      // First load from localStorage as baseline
      const localTodoItems = JSON.parse(localStorage.getItem('todoItems') || '[]');
      const localTodoHistory = JSON.parse(localStorage.getItem('todoHistory') || '[]');
      const localGroceryItems = JSON.parse(localStorage.getItem('groceryItems') || '[]');
      const localMealItems = JSON.parse(localStorage.getItem('mealItems') || '[]');
      const localMealHistory = JSON.parse(localStorage.getItem('mealHistory') || '[]');
      const localMedications = JSON.parse(localStorage.getItem('medications') || 'null');
      // Ensure earlyMorning exists for backward compatibility
      if (localMedications && !localMedications.earlyMorning) {
        localMedications.earlyMorning = { taken: false, timestamp: null };
      }
      const localMedicationsHistory = JSON.parse(localStorage.getItem('medicationsHistory') || '[]');
      const localDishwasher = JSON.parse(localStorage.getItem('dishwasher') || 'null');
      
      console.log('ðŸ“± Local storage data:', {
        todoItems: localTodoItems.length,
        todoHistory: localTodoHistory.length,
        groceryItems: localGroceryItems.length,
        mealItems: localMealItems.length,
        mealHistory: localMealHistory.length,
        medications: localMedications ? localMedications.lastReset : 'none',
        medicationsHistory: localMedicationsHistory.length,
        dishwasher: localDishwasher ? localDishwasher.status : 'none'
      });
      
      // If online, try to load from master storage (GitHub Gist)
      if (isOnline) {
        let cloudData = null;
        
        // Priority 1: GitHub Gist (master storage)
        if (GIST_ID && GITHUB_TOKEN) {
          console.log('ðŸ™ Attempting to load from GitHub Gist (master):', GIST_ID);
          cloudData = await loadFromGithubGist();
          if (cloudData) {
            setCurrentData(cloudData);
            
            // Update localStorage to match cloud data (prevents future conflicts)
            localStorage.setItem('todoItems', JSON.stringify(cloudData.todoItems || []));
            localStorage.setItem('todoHistory', JSON.stringify(cloudData.todoHistory || []));
            localStorage.setItem('groceryItems', JSON.stringify(cloudData.groceryItems || []));
            localStorage.setItem('mealItems', JSON.stringify(cloudData.mealItems || []));
            localStorage.setItem('mealHistory', JSON.stringify(cloudData.mealHistory || []));
            localStorage.setItem('medications', JSON.stringify(cloudData.medications || medications));
            localStorage.setItem('medicationsHistory', JSON.stringify(cloudData.medicationsHistory || []));
            localStorage.setItem('dishwasher', JSON.stringify(cloudData.dishwasher || dishwasher));
            
            console.log('âœ… Successfully loaded data from GitHub master storage:', {
              todoItems: todoItems.length,
              todoHistory: todoHistory.length,
              groceryItems: groceryItems.length,
              mealItems: mealItems.length,
              mealHistory: mealHistory.length,
              medications: medications.lastReset,
              medicationsHistory: medicationsHistory.length
            });
            return;
          } else {
            console.log('âŒ Failed to load from GitHub, trying fallback...');
          }
        }
        
        // Priority 2: JSONBin (fallback for migration)
        if (JSONBIN_ID) {
          console.log('ðŸŒ Attempting to load from JSONBin (fallback):', JSONBIN_ID);
          cloudData = await loadFromJsonBin();
          if (cloudData) {
            setCurrentData(cloudData);
            
            // Update localStorage to match cloud data (prevents future conflicts)
            localStorage.setItem('todoItems', JSON.stringify(cloudData.todoItems || []));
            localStorage.setItem('todoHistory', JSON.stringify(cloudData.todoHistory || []));
            localStorage.setItem('groceryItems', JSON.stringify(cloudData.groceryItems || []));
            localStorage.setItem('mealItems', JSON.stringify(cloudData.mealItems || []));
            localStorage.setItem('mealHistory', JSON.stringify(cloudData.mealHistory || []));
            localStorage.setItem('medications', JSON.stringify(cloudData.medications || medications));
            localStorage.setItem('medicationsHistory', JSON.stringify(cloudData.medicationsHistory || []));
            localStorage.setItem('dishwasher', JSON.stringify(cloudData.dishwasher || dishwasher));
            
            console.log('âœ… Successfully loaded data from JSONBin fallback');
            
            // Migrate to GitHub if we have the token
            if (GITHUB_TOKEN) {
              console.log('ðŸ”„ Migrating JSONBin data to GitHub master storage...');
              await saveAllData(); // This will create GitHub Gist
            }
            return;
          } else {
            console.log('âŒ Failed to load from JSONBin fallback');
          }
        }
        
        console.log('âš ï¸ No cloud storage available or failed to load');
      } else {
        console.log('ðŸ“± Offline mode - using local storage only');
      }
      
      // Fallback to localStorage
      todoItems = localTodoItems;
      todoHistory = localTodoHistory;
      groceryItems = localGroceryItems;
      mealItems = localMealItems;
      mealHistory = localMealHistory;
      if (localMedications) {
        medications = localMedications;
        checkAndResetMedications();
      }
      if (localMedicationsHistory) {
        medicationsHistory = localMedicationsHistory;
      }
      if (localDishwasher) {
        dishwasher = localDishwasher;
      }
      
      console.log('ðŸ“± Using local storage data:', {
        todoItems: todoItems.length,
        todoHistory: todoHistory.length,
        groceryItems: groceryItems.length,
        mealItems: mealItems.length,
        mealHistory: mealHistory.length,
        medications: medications.lastReset,
        medicationsHistory: medicationsHistory.length,
        dishwasher: dishwasher.status
      });
      
      // If we have local data but no cloud storage, offer to create master storage
      if (isOnline && !GIST_ID && (todoItems.length || groceryItems.length || mealItems.length)) {
        console.log('ðŸš€ Local data found but no master storage - will create on next save');
        // saveAllData() will be called when user adds/modifies data
      }
    }
    let showingMealHistory = false;
    let showingTodoHistory = false;
    let selectedAvatarFilters = []; // Array to track selected avatar filters ('emley', 'nate', 'family')

    // Initialize lists on page load
    document.addEventListener('DOMContentLoaded', async function() {
      console.log('DOMContentLoaded fired, initializing dashboard...');
      
      // Fire TV-specific customizations
      if (isFireTV) {
        console.log('ðŸ“º Fire TV detected - applying customizations');
        
        // Add CSS to hide keyboard
        const style = document.createElement('style');
        style.textContent = `
          input, textarea {
            -webkit-user-select: text !important;
            user-select: text !important;
          }
        `;
        document.head.appendChild(style);
        
        // Remove subtitle
        const subtitle = document.getElementById('landing-subtitle');
        if (subtitle) subtitle.style.display = 'none';
        
        // Center title with equal spacing above and below
        const title = document.getElementById('landing-title');
        if (title) {
          title.style.marginTop = '1.5rem'; // Move higher on screen
          title.style.marginBottom = '3rem'; // Match top spacing
          title.style.textAlign = 'center';
          title.style.fontSize = '4rem'; // Larger title size
          title.style.fontWeight = '700'; // Bold
        }
        
        // Adjust landing container for Fire TV
        const landingContainer = document.querySelector('.landing-container');
        if (landingContainer) {
          landingContainer.style.maxWidth = '100%';
          landingContainer.style.padding = '0 2rem';
          landingContainer.style.marginTop = '0'; // Remove container top margin
        }
        
        // Adjust landing page padding
        const landingPage = document.querySelector('.landing-page');
        if (landingPage) {
          landingPage.style.padding = '1rem';
        }
        
        // Change grid to 2 rows x 5 columns - FIXED equal sizes
        const navGrid = document.querySelector('.navigation-grid');
        if (navGrid) {
          navGrid.style.setProperty('grid-template-columns', 'repeat(5, 1fr)', 'important'); // Equal width columns
          navGrid.style.setProperty('grid-template-rows', 'repeat(2, 300px)', 'important'); // Fixed height rows - 300px
          navGrid.style.setProperty('max-width', '100%', 'important');
          navGrid.style.setProperty('gap', '1.5rem', 'important');
          navGrid.style.setProperty('margin', '0', 'important');
          navGrid.style.setProperty('width', '100%', 'important');
        }
        
        // Make all tiles EXACTLY the same size - FIXED width and height
        const navButtons = document.querySelectorAll('.nav-button');
        navButtons.forEach(button => {
          button.style.setProperty('width', '100%', 'important'); // Fill grid cell
          button.style.setProperty('height', '300px', 'important'); // FIXED height - 300px
          button.style.setProperty('min-height', '300px', 'important');
          button.style.setProperty('max-height', '300px', 'important');
          button.style.setProperty('min-width', '0', 'important'); // Allow grid to control width
          button.style.setProperty('padding', '2rem', 'important'); // Reduced padding for text space
          button.style.setProperty('display', 'flex', 'important');
          button.style.setProperty('flex-direction', 'column', 'important');
          button.style.setProperty('align-items', 'center', 'important');
          button.style.setProperty('justify-content', 'center', 'important');
          button.style.setProperty('gap', '1rem', 'important'); // Reduced gap
          button.style.setProperty('box-sizing', 'border-box', 'important');
          button.style.setProperty('overflow', 'hidden', 'important'); // Hide overflow text
        });
        
        // Make ALL icons exactly the same size - 5rem x 5rem square
        const navIcons = document.querySelectorAll('.nav-icon');
        navIcons.forEach(icon => {
          icon.style.setProperty('font-size', '5rem', 'important');
          icon.style.setProperty('width', '5rem', 'important');
          icon.style.setProperty('height', '5rem', 'important');
          icon.style.setProperty('min-width', '5rem', 'important');
          icon.style.setProperty('min-height', '5rem', 'important');
          icon.style.setProperty('max-width', '5rem', 'important');
          icon.style.setProperty('max-height', '5rem', 'important');
          icon.style.setProperty('display', 'flex', 'important');
          icon.style.setProperty('align-items', 'center', 'important');
          icon.style.setProperty('justify-content', 'center', 'important');
          icon.style.setProperty('transform', 'none', 'important');
          icon.style.setProperty('margin', '0', 'important');
          icon.style.setProperty('padding', '0', 'important');
          icon.style.setProperty('position', 'relative', 'important');
          icon.style.setProperty('overflow', 'hidden', 'important');
        });
        
        // Make icon images exactly 5rem x 5rem
        const navIconImages = document.querySelectorAll('.nav-icon img');
        navIconImages.forEach(img => {
          img.style.setProperty('width', '5rem', 'important');
          img.style.setProperty('height', '5rem', 'important');
          img.style.setProperty('min-width', '5rem', 'important');
          img.style.setProperty('min-height', '5rem', 'important');
          img.style.setProperty('max-width', '5rem', 'important');
          img.style.setProperty('max-height', '5rem', 'important');
          img.style.setProperty('object-fit', 'contain', 'important');
          img.style.setProperty('transform', 'none', 'important');
          img.style.setProperty('margin', '0', 'important');
          img.style.setProperty('padding', '0', 'important');
          img.style.setProperty('display', 'block', 'important');
        });
        
        // Make labels much larger and consistent with centered text
        const navLabels = document.querySelectorAll('.nav-label');
        navLabels.forEach(label => {
          label.style.setProperty('font-size', '2rem', 'important');
          label.style.setProperty('margin', '0', 'important');
          label.style.setProperty('padding', '0', 'important');
          label.style.setProperty('line-height', '1.2', 'important');
          label.style.setProperty('position', 'relative', 'important');
          label.style.setProperty('top', '0', 'important');
          label.style.setProperty('bottom', '0', 'important');
          label.style.setProperty('text-align', 'center', 'important'); // Center text horizontally
          label.style.setProperty('width', '100%', 'important'); // Full width for centering
        });
        
        // Style secondary labels (second line of text for multi-line titles)
        // Use absolute positioning so they don't affect layout
        const navSecondaryLabels = document.querySelectorAll('.nav-label-secondary');
        navSecondaryLabels.forEach(label => {
          label.style.setProperty('font-size', '2rem', 'important');
          label.style.setProperty('font-weight', '500', 'important'); // Match primary label weight
          label.style.setProperty('margin', '0', 'important');
          label.style.setProperty('padding', '0', 'important');
          label.style.setProperty('line-height', '1.2', 'important');
          label.style.setProperty('position', 'absolute', 'important');
          label.style.setProperty('text-align', 'center', 'important');
          label.style.setProperty('width', '100%', 'important');
          label.style.setProperty('left', '0', 'important');
          label.style.setProperty('bottom', '2.5rem', 'important'); // Position below primary label
        });
        
        // Hide dashboard title
        const dashboardTitle = document.getElementById('dashboard-title');
        if (dashboardTitle) dashboardTitle.style.display = 'none';
        
        // Change dishwasher icon to bubbles.png
        const dishwasherIcon = document.getElementById('dishwasher-icon');
        if (dishwasherIcon) {
          dishwasherIcon.innerHTML = '<img src="bubbles.png?v=' + new Date().getTime() + '" alt="Dishwasher" style="width: 5rem; height: 5rem; object-fit: contain; border-radius: 0; display: block;">';
        }
        
        
        // Disable on-screen keyboard for all text inputs (wireless keyboard is connected)
        const disableOnScreenKeyboard = () => {
          const allInputs = document.querySelectorAll('input[type="text"], input[type="date"], input[type="search"], textarea');
          allInputs.forEach(input => {
            // Set inputmode to none
            input.setAttribute('inputmode', 'none');
            
            // Make it readonly by default
            if (!input.hasAttribute('data-firetv-processed')) {
              input.setAttribute('readonly', 'true');
              input.setAttribute('data-firetv-processed', 'true');
              
              // On click, remove readonly temporarily so keyboard input works
              input.addEventListener('click', function(e) {
                this.removeAttribute('readonly');
                // Keep it editable for a while
                setTimeout(() => {
                  if (document.activeElement !== this) {
                    this.setAttribute('readonly', 'true');
                  }
                }, 100);
              });
              
              // When losing focus, make readonly again
              input.addEventListener('blur', function() {
                this.setAttribute('readonly', 'true');
              });
            }
          });
          console.log(`ðŸ“º Fire TV: Processed ${allInputs.length} inputs for keyboard suppression`);
        };
        
        // Run now and whenever new inputs are added
        disableOnScreenKeyboard();
        // Re-run after delays to catch dynamically created inputs
        setTimeout(disableOnScreenKeyboard, 500);
        setTimeout(disableOnScreenKeyboard, 1500);
        setTimeout(disableOnScreenKeyboard, 3000);
        
        // Create observer to handle dynamically added inputs
        const observer = new MutationObserver(() => {
          setTimeout(disableOnScreenKeyboard, 100);
        });
        observer.observe(document.body, { childList: true, subtree: true });
      }
      
      // PWA-specific initialization
      if (window.matchMedia && window.matchMedia('(display-mode: standalone)').matches) {
        console.log('ðŸš€ PWA Mode detected - ensuring proper data sync');
        
        // Add a small delay to ensure PWA context is fully loaded
        await new Promise(resolve => setTimeout(resolve, 200));
        
        // Debug PWA data loading
        console.log('ðŸ” PWA Debug Info Before Loading:');
        console.log('- GIST_ID from localStorage:', localStorage.getItem('dashboardGistId'));
        console.log('- GITHUB_TOKEN exists:', !!localStorage.getItem('githubToken'));
        console.log('- JSONBIN_ID from localStorage:', localStorage.getItem('dashboardJsonBinId'));
        console.log('- Navigator online:', navigator.onLine);
      }
      
      // Load data from cloud or localStorage
      await loadAllData();
      
      // One-time migration to fix legacy history items
      let needsSave = false;
      todoHistory.forEach(item => {
        if (item.completedAt && item.completed === undefined) {
          item.completed = true;
          needsSave = true;
        }
      });
      
      if (needsSave) {
        saveTodoHistory();
        console.log('Migrated legacy history items to include completed flag');
      }
      
      // Clean up old completed items first
      cleanupCompletedItems();
      
      console.log('About to render lists...');
      renderTodoList();
      renderGroceryList();
      renderMealsList();
      console.log('Lists rendered.');
      
      // Handle URL parameters AFTER data is loaded and lists are rendered
      console.log('ðŸ”— Handling URL parameters...');
      console.log('Current URL:', window.location.href);
      console.log('URL search params:', window.location.search);
      const urlParams = new URLSearchParams(window.location.search);
      console.log('View parameter:', urlParams.get('view'));
      
      // Handle URL parameters to restore view on refresh
      handleURLParameters();
      console.log('âœ… URL parameters handled - view restored');
      
      // Force re-render fullscreen views after URL navigation to ensure fresh data is displayed
      console.log('ðŸ”„ Re-rendering fullscreen views after URL navigation...');
      setTimeout(() => {
        renderTodoListFullscreen();
        renderGroceryListFullscreen();
        renderMealsListFullscreen();
        renderTodoCalendarFullscreen();
        console.log('âœ… Fullscreen views re-rendered with fresh data');
      }, 100); // Small delay to ensure navigation is complete
      
      // Monitor online status
      window.addEventListener('online', () => {
        isOnline = true;
        console.log('Back online - syncing data...');
        updateSyncStatus();
        saveAllData();
      });
      
      window.addEventListener('offline', () => {
        isOnline = false;
        console.log('Offline - data will sync when reconnected');
        updateSyncStatus();
      });
      
      // Initial sync status update
      updateSyncStatus();
      
      // Initialize header info
      updateDateTime();
      updateWeather();
      
      // Initialize custom calendar
      initializeCustomCalendar();
      
      // Update time every second
      setInterval(updateDateTime, 1000);
      
      // Update weather every 10 minutes
      setInterval(updateWeather, 10 * 60 * 1000);
      
      // Refresh calendar every 5 minutes
      setInterval(() => refreshCalendar(), 5 * 60 * 1000);
      
      // DISABLED: Auto-sync for debugging pull-to-refresh
      // Auto-sync: Check for cloud updates every 30 seconds
      // setInterval(async () => {
      //   if (isOnline && !syncInProgress && (GIST_ID || JSONBIN_ID)) {
      //     console.log('ðŸ”„ Auto-sync: Checking for cloud updates...');
      //     await loadAllData();
      //     
      //     // Re-render all lists (both dashboard and fullscreen views)
      //     renderTodoList();
      //     renderGroceryList();
      //     renderMealsList();
      //     
      //     // Also update fullscreen views if they're open
      //     if (document.getElementById('fullscreen-todo-list')) {
      //       renderTodoListFullscreen();
      //     }
      //     if (document.getElementById('fullscreen-grocery-list')) {
      //       renderGroceryListFullscreen();
      //     }
      //     if (document.getElementById('fullscreen-meals-list')) {
      //       renderMealsListFullscreen();
      //     }
      //     if (document.getElementById('fullscreen-todo-calendar-container')) {
      //       renderTodoCalendarFullscreen();
      //     }
      //     
      //     console.log('âœ… Auto-sync: Data refreshed from cloud');
      //   }
      // }, 30000); // Check every 30 seconds
      console.log('âš ï¸ Auto-sync DISABLED for debugging');
      
      // Add Enter key support for inputs
      document.getElementById('todo-input').addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
          addTodoItem();
        }
      });
      
      document.getElementById('grocery-input').addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
          addGroceryItem();
        }
      });
      
      document.getElementById('meals-input').addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
          addMealItem();
        }
      });

      // Set up automatic cleanup at midnight
      scheduleNextCleanup();
    });

    // Todo List Functions
    function addTodoItem() {
      const input = document.getElementById('todo-input');
      const dueDateInput = document.getElementById('todo-due-date');
      const text = input.value.trim();
      const dueDate = dueDateInput.value;
      
      if (text) {
        const item = {
          id: Date.now(),
          text: text,
          completed: false,
          createdAt: new Date().toISOString(),
          order: Date.now(), // Add order property for sorting
          dueDate: dueDate || null, // Add due date if provided
          assignedTo: 'family' // Auto-assign to family by default
        };
        
        todoItems.unshift(item); // Add to beginning of array
        updateItemOrders(todoItems); // Update all orders
        saveTodoItems();
        renderTodoList();
        input.value = '';
        dueDateInput.value = '';
      }
    }

    function toggleTodoItem(id) {
      const item = todoItems.find(item => item.id === id);
      if (item) {
        if (!item.completed) {
          // Item is being checked off - move to history immediately
          item.completedAt = new Date().toISOString();
          
          // If this was re-added from history, remove the old history entry
          if (item.originalHistoryId) {
            todoHistory = todoHistory.filter(h => h.id !== item.originalHistoryId);
          }
          
          // Add to history immediately when completed
          const historyItem = {
            id: Date.now() + Math.random(),
            text: item.text,
            completed: true, // Mark as completed in history
            completedAt: item.completedAt,
            originalId: item.id,
            order: Date.now(), // Add order property for sorting
            dueDate: item.dueDate // Preserve due date in history
          };
          todoHistory.unshift(historyItem);
          updateItemOrders(todoHistory); // Update all orders
          saveTodoHistory();
          
          // Remove from current list immediately
          todoItems = todoItems.filter(t => t.id !== id);
          
        } else {
          // This shouldn't happen with the new workflow, but keeping for safety
          item.completed = false;
          delete item.completedAt;
        }
        
        saveTodoItems();
        renderTodoList();
      }
    }

    function deleteTodoItem(id) {
      todoItems = todoItems.filter(item => item.id !== id);
      saveTodoItems();
      renderTodoList();
    }

    function editTodoItem(id) {
      const item = todoItems.find(item => item.id === id);
      if (item) {
        // Create a modal dialog for editing
        const modal = document.createElement('div');
        modal.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0, 0, 0, 0.5);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 10000;
        `;
        
        const dialog = document.createElement('div');
        dialog.style.cssText = `
          background: var(--bg-primary);
          padding: 24px;
          border-radius: 12px;
          box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
          max-width: 400px;
          width: 90%;
          border: 1px solid var(--border-color);
        `;
        
        dialog.innerHTML = `
          <h3 style="margin: 0 0 16px 0; color: var(--text-primary);">Edit Task</h3>
          <input type="text" id="edit-task-text" value="${escapeHtml(item.text)}" 
                 style="width: 100%; padding: 8px 12px; border: 1px solid var(--border-color); 
                        border-radius: 8px; background: var(--bg-secondary); color: var(--text-primary); 
                        font-size: 14px; margin-bottom: 12px; box-sizing: border-box;">
          <select id="edit-task-assigned-to" 
                  style="width: 100%; padding: 8px 12px; border: 1px solid var(--border-color); 
                         border-radius: 8px; background: var(--bg-secondary); color: var(--text-primary); 
                         font-size: 14px; margin-bottom: 12px; box-sizing: border-box;">
            <option value="emley" ${item.assignedTo === 'emley' ? 'selected' : ''}>Emley</option>
            <option value="nate" ${item.assignedTo === 'nate' ? 'selected' : ''}>Nate</option>
            <option value="family" ${item.assignedTo === 'family' ? 'selected' : ''}>Family</option>
          </select>
          <input type="date" id="edit-task-due-date" value="${item.dueDate || ''}" 
                 style="width: 100%; padding: 8px 12px; border: 1px solid var(--border-color); 
                        border-radius: 8px; background: var(--bg-secondary); color: var(--text-primary); 
                        font-size: 14px; margin-bottom: 16px; box-sizing: border-box;">
          <div style="display: flex; gap: 8px; justify-content: flex-end;">
            <button id="edit-cancel-btn" style="padding: 8px 16px; border: 1px solid var(--border-color); 
                    border-radius: 6px; background: var(--bg-secondary); color: var(--text-primary); 
                    cursor: pointer;">Cancel</button>
            <button id="edit-save-btn" style="padding: 8px 16px; border: none; border-radius: 6px; 
                    background: var(--primary-color); color: white; cursor: pointer;">Save</button>
          </div>
        `;
        
        modal.appendChild(dialog);
        document.body.appendChild(modal);
        
        // Focus on text input
        const textInput = document.getElementById('edit-task-text');
        textInput.focus();
        textInput.select();
        
        // Handle save
        const saveBtn = document.getElementById('edit-save-btn');
        const cancelBtn = document.getElementById('edit-cancel-btn');
        const dueDateInput = document.getElementById('edit-task-due-date');
        const assignedToInput = document.getElementById('edit-task-assigned-to');
        
        const handleSave = () => {
          const newText = textInput.value.trim();
          const newDueDate = dueDateInput.value;
          const newAssignedTo = assignedToInput.value;
          
          if (newText) {
            item.text = newText;
            item.dueDate = newDueDate || null;
            item.assignedTo = newAssignedTo || null;
          saveTodoItems();
            
            // Render the appropriate view (widget or fullscreen)
            if (document.getElementById('fullscreen-container')) {
              renderTodoListFullscreen();
            } else {
          renderTodoList();
        }
      }
          document.body.removeChild(modal);
        };
        
        const handleCancel = () => {
          document.body.removeChild(modal);
        };
        
        saveBtn.addEventListener('click', handleSave);
        cancelBtn.addEventListener('click', handleCancel);
        
        // Handle Enter key in text input
        textInput.addEventListener('keypress', (e) => {
          if (e.key === 'Enter') {
            handleSave();
          }
        });
        
        // Handle Enter key in date input
        dueDateInput.addEventListener('keypress', (e) => {
          if (e.key === 'Enter') {
            handleSave();
          }
        });
        
        // Handle Escape key
        modal.addEventListener('keydown', (e) => {
          if (e.key === 'Escape') {
            handleCancel();
          }
        });
        
        // Handle click outside dialog
        modal.addEventListener('click', (e) => {
          if (e.target === modal) {
            handleCancel();
          }
        });
      }
    }

    function renderTodoList() {
      const list = document.getElementById('todo-list');
      
      if (showingTodoHistory) {
        let filteredHistory = [...todoHistory];
        
        // Apply search filters
        if (currentTodoSearchTerm) {
          filteredHistory = fuzzySearchTodos(filteredHistory, currentTodoSearchTerm);
        }
        
        if (currentDateFrom || currentDateTo) {
          filteredHistory = filterTodosByDateRange(filteredHistory, currentDateFrom, currentDateTo);
        }
        
        // Apply avatar filters
        filteredHistory = filterTodosByAvatar(filteredHistory);
        
        if (filteredHistory.length === 0) {
          const emptyMessage = (currentTodoSearchTerm || currentDateFrom || currentDateTo || selectedAvatarFilters.length > 0) ? 
            'No tasks found matching your search criteria.' : 
            'No completed tasks yet.';
          list.innerHTML = `<li class="empty-state">${emptyMessage}</li>`;
          list.style.setProperty('margin-top', '3rem', 'important'); // Add spacing even for empty state
          return;
        }
        
        const groups = groupTodosByDate(filteredHistory);
        list.innerHTML = renderTodoHistoryGrouped(groups);
        
        // Add extra top margin when showing history to prevent overlap with avatar filters
        list.style.setProperty('margin-top', '3rem', 'important');
        
        // Set up drag and drop for history items (within date groups only)
        setTimeout(() => setupTodoHistoryDragAndDrop(list, groups), 0);
      } else {
        // Reset margin when not showing history
        list.style.removeProperty('margin-top');
        
        // Only show uncompleted items (completed items are immediately moved to history)
        let activeItems = todoItems.filter(item => !item.completed);
        
        // Apply avatar filters
        activeItems = filterTodosByAvatar(activeItems);
        
        if (activeItems.length === 0) {
          const emptyMessage = selectedAvatarFilters.length > 0 ? 
            'No tasks found for selected filters.' : 
            'No tasks yet. Add one above!';
          list.innerHTML = `<li class="empty-state">${emptyMessage}</li>`;
          return;
        }
        
        // Sort by order and ensure all items have order property
        updateItemOrders(activeItems);
        activeItems = sortItemsByOrder(activeItems);
        
        list.innerHTML = activeItems.map(item => {
          const dueDateDisplay = item.dueDate ? formatDueDate(item.dueDate) : '';
          const isOverdue = item.dueDate && isTaskOverdue(item.dueDate);
          const isDueToday = item.dueDate && isTaskDueToday(item.dueDate);
          const isDueTomorrow = item.dueDate && isTaskDueTomorrow(item.dueDate);
          
          let dueDateClass = '';
          let taskItemClass = '';
          
          if (isOverdue) {
            dueDateClass = 'overdue';
            taskItemClass = 'overdue';
          } else if (isDueToday) {
            dueDateClass = 'due-today';
            taskItemClass = 'due-today';
          } else if (isDueTomorrow) {
            dueDateClass = 'due-tomorrow';
            taskItemClass = 'due-tomorrow';
          }
          
          const assignedTo = item.assignedTo || 'family'; // Default to family if not assigned
          const avatarHtml = `<span class="person-avatar ${assignedTo}" onclick="editTodoAssignment(${item.id})" title="Click to change assignment - Currently: ${assignedTo === 'emley' ? 'Emley' : assignedTo === 'nate' ? 'Nate' : 'Family'}" style="cursor: pointer;">${assignedTo === 'emley' ? 'E' : assignedTo === 'nate' ? 'N' : 'F'}</span>`;
          
          return `
            <li class="task-item ${taskItemClass}">
            <span class="drag-handle">â˜°</span>
            <input type="checkbox" class="task-checkbox" 
                   onchange="toggleTodoItem(${item.id})">
            ${avatarHtml}
            <span class="task-text">${escapeHtml(item.text)}</span>
            ${dueDateDisplay ? `<span class="task-due-date ${dueDateClass}" onclick="editTodoDueDate(${item.id})" title="Click to edit due date">${dueDateDisplay}</span>` : ''}
            <div class="task-actions">
              <button class="edit-btn" onclick="editTodoItem(${item.id})" title="Edit">âœï¸</button>
              <button class="delete-btn" onclick="deleteTodoItem(${item.id})" title="Delete">ðŸ—‘ï¸</button>
            </div>
          </li>
          `;
        }).join('');
        
        // Set up drag and drop
        setTimeout(() => setupDragAndDrop(list, activeItems, 'todo'), 0);
      }
    }

    function saveTodoItems() {
      saveAllData();
    }

    function formatDueDate(dateString) {
      // Parse date as local date to avoid timezone issues
      const dateParts = dateString.split('-');
      const date = new Date(dateParts[0], dateParts[1] - 1, dateParts[2]); // Year, Month (0-indexed), Day
      
      const today = new Date();
      const tomorrow = new Date(today);
      tomorrow.setDate(today.getDate() + 1);
      
      // Reset time to compare dates only
      today.setHours(0, 0, 0, 0);
      tomorrow.setHours(0, 0, 0, 0);
      date.setHours(0, 0, 0, 0);
      
      if (date.getTime() === today.getTime()) {
        return 'Today';
      } else if (date.getTime() === tomorrow.getTime()) {
        return 'Tomorrow';
      } else {
        return date.toLocaleDateString('en-US', { 
          month: 'short', 
          day: 'numeric',
          year: date.getFullYear() !== today.getFullYear() ? 'numeric' : undefined
        });
      }
    }

    function isTaskOverdue(dateString) {
      // Parse date as local date to avoid timezone issues
      const dateParts = dateString.split('-');
      const dueDate = new Date(dateParts[0], dateParts[1] - 1, dateParts[2]); // Year, Month (0-indexed), Day
      
      const today = new Date();
      
      // Reset time to compare dates only
      today.setHours(0, 0, 0, 0);
      dueDate.setHours(0, 0, 0, 0);
      
      return dueDate.getTime() < today.getTime();
    }

    function isTaskDueToday(dateString) {
      // Parse date as local date to avoid timezone issues
      const dateParts = dateString.split('-');
      const dueDate = new Date(dateParts[0], dateParts[1] - 1, dateParts[2]); // Year, Month (0-indexed), Day
      
      const today = new Date();
      
      // Reset time to compare dates only
      today.setHours(0, 0, 0, 0);
      dueDate.setHours(0, 0, 0, 0);
      
      return dueDate.getTime() === today.getTime();
    }

    function isTaskDueTomorrow(dateString) {
      // Parse date as local date to avoid timezone issues
      const dateParts = dateString.split('-');
      const dueDate = new Date(dateParts[0], dateParts[1] - 1, dateParts[2]); // Year, Month (0-indexed), Day
      
      const today = new Date();
      const tomorrow = new Date(today);
      tomorrow.setDate(today.getDate() + 1);
      
      // Reset time to compare dates only
      tomorrow.setHours(0, 0, 0, 0);
      dueDate.setHours(0, 0, 0, 0);
      
      return dueDate.getTime() === tomorrow.getTime();
    }

    function editTodoAssignment(id) {
      const item = todoItems.find(item => item.id === id);
      if (!item) return;
      
      // Create a simple modal for assignment selection
      const modal = document.createElement('div');
      modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
      `;
      
      const dialog = document.createElement('div');
      dialog.style.cssText = `
        background: var(--bg-primary);
        padding: 24px;
        border-radius: 12px;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
        max-width: 300px;
        width: 90%;
        border: 1px solid var(--border-color);
      `;
      
      dialog.innerHTML = `
        <h3 style="margin: 0 0 16px 0; color: var(--text-primary);">Change Assignment</h3>
        <div style="display: flex; flex-direction: column; gap: 8px; margin-bottom: 16px;">
          <button onclick="updateAssignment(${id}, 'emley')" style="padding: 12px; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-secondary); color: var(--text-primary); cursor: pointer; text-align: left; display: flex; align-items: center; gap: 8px;">
            <span class="person-avatar emley" style="width: 16px; height: 16px; font-size: 10px;">E</span>
            Emley
          </button>
          <button onclick="updateAssignment(${id}, 'nate')" style="padding: 12px; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-secondary); color: var(--text-primary); cursor: pointer; text-align: left; display: flex; align-items: center; gap: 8px;">
            <span class="person-avatar nate" style="width: 16px; height: 16px; font-size: 10px;">N</span>
            Nate
          </button>
          <button onclick="updateAssignment(${id}, 'family')" style="padding: 12px; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-secondary); color: var(--text-primary); cursor: pointer; text-align: left; display: flex; align-items: center; gap: 8px;">
            <span class="person-avatar family" style="width: 16px; height: 16px; font-size: 10px;">F</span>
            Family
          </button>
        </div>
        <div style="display: flex; justify-content: flex-end;">
          <button onclick="closeAssignmentModal()" style="padding: 8px 16px; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-secondary); color: var(--text-primary); cursor: pointer;">Cancel</button>
        </div>
      `;
      
      modal.appendChild(dialog);
      document.body.appendChild(modal);
      
      // Store modal reference for closing
      window.currentAssignmentModal = modal;
      
      // Close on background click
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          closeAssignmentModal();
        }
      });
    }
    
    function updateAssignment(id, newAssignment) {
      const item = todoItems.find(item => item.id === id);
      if (item) {
        item.assignedTo = newAssignment || 'family'; // Default to family if somehow empty
        saveTodoItems();
        
        // Render the appropriate view
        if (document.getElementById('fullscreen-container')) {
          renderTodoListFullscreen();
        } else {
          renderTodoList();
        }
      }
      closeAssignmentModal();
    }
    
    function closeAssignmentModal() {
      if (window.currentAssignmentModal) {
        document.body.removeChild(window.currentAssignmentModal);
        window.currentAssignmentModal = null;
      }
    }

    function toggleAvatarFilter(avatar) {
      const index = selectedAvatarFilters.indexOf(avatar);
      if (index > -1) {
        // Remove filter if already selected
        selectedAvatarFilters.splice(index, 1);
      } else {
        // Add filter if not selected
        selectedAvatarFilters.push(avatar);
      }
      
      // Update filter button appearance
      updateAvatarFilterButtons();
      
      // Re-render the todo list with filters applied
      if (document.getElementById('fullscreen-container')) {
        renderTodoListFullscreen();
      } else {
        renderTodoList();
      }
    }

    function updateAvatarFilterButtons() {
      // Update widget filter buttons
      const widgetFilters = document.querySelectorAll('.avatar-filter');
      widgetFilters.forEach(button => {
        const avatar = button.dataset.avatar;
        if (selectedAvatarFilters.includes(avatar)) {
          button.classList.add('active');
        } else {
          button.classList.remove('active');
        }
      });
      
      // Update fullscreen filter buttons
      const fullscreenFilters = document.querySelectorAll('.fullscreen-avatar-filter');
      fullscreenFilters.forEach(button => {
        const avatar = button.dataset.avatar;
        if (selectedAvatarFilters.includes(avatar)) {
          button.classList.add('active');
        } else {
          button.classList.remove('active');
        }
      });
    }

    function filterTodosByAvatar(items) {
      // If no filters selected, show all items
      if (selectedAvatarFilters.length === 0) {
        return items;
      }
      
      // Filter items based on selected avatars
      return items.filter(item => {
        const assignedTo = item.assignedTo || 'family'; // Default to family if not assigned
        return selectedAvatarFilters.includes(assignedTo);
      });
    }

    function editTodoHistoryAssignment(id) {
      const item = todoHistory.find(item => item.id === id);
      if (!item) return;
      
      // Create a simple modal for assignment selection
      const modal = document.createElement('div');
      modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
      `;
      
      const dialog = document.createElement('div');
      dialog.style.cssText = `
        background: var(--bg-primary);
        padding: 24px;
        border-radius: 12px;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
        max-width: 300px;
        width: 90%;
        border: 1px solid var(--border-color);
      `;
      
      dialog.innerHTML = `
        <h3 style="margin: 0 0 16px 0; color: var(--text-primary);">Change Assignment</h3>
        <div style="display: flex; flex-direction: column; gap: 8px; margin-bottom: 16px;">
          <button onclick="updateHistoryAssignment(${id}, 'emley')" style="padding: 12px; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-secondary); color: var(--text-primary); cursor: pointer; text-align: left; display: flex; align-items: center; gap: 8px;">
            <span class="person-avatar emley" style="width: 16px; height: 16px; font-size: 10px;">E</span>
            Emley
          </button>
          <button onclick="updateHistoryAssignment(${id}, 'nate')" style="padding: 12px; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-secondary); color: var(--text-primary); cursor: pointer; text-align: left; display: flex; align-items: center; gap: 8px;">
            <span class="person-avatar nate" style="width: 16px; height: 16px; font-size: 10px;">N</span>
            Nate
          </button>
          <button onclick="updateHistoryAssignment(${id}, 'family')" style="padding: 12px; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-secondary); color: var(--text-primary); cursor: pointer; text-align: left; display: flex; align-items: center; gap: 8px;">
            <span class="person-avatar family" style="width: 16px; height: 16px; font-size: 10px;">F</span>
            Family
          </button>
        </div>
        <div style="display: flex; justify-content: flex-end;">
          <button onclick="closeAssignmentModal()" style="padding: 8px 16px; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-secondary); color: var(--text-primary); cursor: pointer;">Cancel</button>
        </div>
      `;
      
      modal.appendChild(dialog);
      document.body.appendChild(modal);
      
      // Store modal reference for closing
      window.currentAssignmentModal = modal;
      
      // Close on background click
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          closeAssignmentModal();
        }
      });
    }
    
    function updateHistoryAssignment(id, newAssignment) {
      const item = todoHistory.find(item => item.id === id);
      if (item) {
        item.assignedTo = newAssignment || 'family'; // Default to family if somehow empty
        saveTodoHistory();
        
        // Render the appropriate view
        if (document.getElementById('fullscreen-container')) {
          renderTodoListFullscreen();
        } else {
          renderTodoList();
        }
      }
      closeAssignmentModal();
    }

    function sortTodosByDueDate() {
      // Sort todos: overdue (most overdue first) â†’ today â†’ tomorrow â†’ future (closest first) â†’ no dates (A-Z)
      todoItems.sort((a, b) => {
        const aHasDueDate = a.dueDate && a.dueDate.trim() !== '';
        const bHasDueDate = b.dueDate && b.dueDate.trim() !== '';
        
        // If both have due dates, sort by priority: overdue â†’ today â†’ tomorrow â†’ future
        if (aHasDueDate && bHasDueDate) {
          const aDate = new Date(a.dueDate);
          const bDate = new Date(b.dueDate);
          const today = new Date();
          today.setHours(0, 0, 0, 0);
          
          const aIsOverdue = isTaskOverdue(a.dueDate);
          const bIsOverdue = isTaskOverdue(b.dueDate);
          const aIsToday = isTaskDueToday(a.dueDate);
          const bIsToday = isTaskDueToday(b.dueDate);
          const aIsTomorrow = isTaskDueTomorrow(a.dueDate);
          const bIsTomorrow = isTaskDueTomorrow(b.dueDate);
          
          // Both overdue - most overdue first (earliest date first)
          if (aIsOverdue && bIsOverdue) {
            return aDate - bDate;
          }
          
          // One overdue, one not - overdue comes first
          if (aIsOverdue && !bIsOverdue) return -1;
          if (!aIsOverdue && bIsOverdue) return 1;
          
          // Both due today - sort by date (shouldn't matter much, but consistent)
          if (aIsToday && bIsToday) {
            return aDate - bDate;
          }
          
          // One today, one not overdue - today comes first
          if (aIsToday && !bIsOverdue) return -1;
          if (bIsToday && !aIsOverdue) return 1;
          
          // Both due tomorrow - sort by date
          if (aIsTomorrow && bIsTomorrow) {
            return aDate - bDate;
          }
          
          // One tomorrow, one future - tomorrow comes first
          if (aIsTomorrow && !bIsOverdue && !bIsToday) return -1;
          if (bIsTomorrow && !aIsOverdue && !aIsToday) return 1;
          
          // Both future dates - closest first
          return aDate - bDate;
        }
        
        // If only one has a due date, prioritize the one with due date
        if (aHasDueDate && !bHasDueDate) return -1;
        if (!aHasDueDate && bHasDueDate) return 1;
        
        // If neither has a due date, sort alphabetically A-Z
        return a.text.toLowerCase().localeCompare(b.text.toLowerCase());
      });
      
      // Update order properties to reflect new sorting
      // Higher order values appear first in the list
      todoItems.forEach((item, index) => {
        item.order = Date.now() + (todoItems.length - index);
      });
      
      saveTodoItems();
      
      // Render the appropriate view (widget or fullscreen)
      if (document.getElementById('fullscreen-container')) {
        renderTodoListFullscreen();
      } else {
        renderTodoList();
      }
    }

    function editTodoDueDate(id) {
      const item = todoItems.find(item => item.id === id);
      if (item) {
        // Create a simple inline date picker
        const currentDate = item.dueDate || '';
        const newDate = prompt('Edit due date (YYYY-MM-DD format, or leave empty to remove):', currentDate);
        
        if (newDate !== null) {
          // Validate date format if not empty
          if (newDate === '' || /^\d{4}-\d{2}-\d{2}$/.test(newDate)) {
            item.dueDate = newDate || null;
            saveTodoItems();
            
            // Render the appropriate view (widget or fullscreen)
            if (document.getElementById('fullscreen-container')) {
              renderTodoListFullscreen();
            } else {
              renderTodoList();
            }
          } else {
            alert('Please enter a valid date in YYYY-MM-DD format (e.g., 2025-10-14) or leave empty to remove the due date.');
          }
        }
      }
    }

    function saveTodoHistory() {
      saveAllData();
    }

    function showTodoHistory() {
      showingTodoHistory = !showingTodoHistory;
      const historyButton = document.querySelector('.todo-widget .history-button');
      const headerTitle = document.querySelector('.todo-widget h2');
      const calendarButton = document.querySelector('.todo-widget .calendar-button');
      
      if (showingTodoHistory) {
        historyButton.textContent = 'Current';
        headerTitle.textContent = 'To-Do History';
        if (calendarButton) {
          calendarButton.onclick = () => showFullscreenTodoCalendar(); // fullscreen view always
        }
        
        // Update header onclick to open fullscreen history
        headerTitle.onclick = () => {
          showingTodoHistory = true;
          openFullscreen('todo');
        };
        
        // Replace add container with search interface
        const addContainer = document.getElementById('todo-add-container');
        const secondContainer = document.getElementById('todo-secondary-container');
        if (secondContainer) {
          secondContainer.style.display = 'none';
        }
        addContainer.innerHTML = `
          <div style="display: flex; flex-direction: column; gap: 0.8rem; margin-bottom: 2rem;">
            <div style="display: flex; gap: 0.5rem; align-items: center;">
              <input type="text" id="todo-search-input" placeholder="Search tasks..." maxlength="100" style="flex: 1;">
              <button onclick="clearTodoSearch()" title="Clear search" style="padding: 0.5rem; font-size: 0.9rem;">âœ•</button>
            </div>
            <div style="display: flex; gap: 0.5rem; font-size: 0.9rem;">
              <label style="font-weight: 500; color: var(--text-secondary); white-space: nowrap;">Date range:</label>
              <input type="date" id="todo-date-from" style="flex: 1; font-size: 0.85rem;" title="From date">
              <span style="color: var(--text-secondary); align-self: center;">to</span>
              <input type="date" id="todo-date-to" style="flex: 1; font-size: 0.85rem;" title="To date">
            </div>
            <div style="display: flex; justify-content: center; align-items: center; gap: 8px; margin-top: 0.5rem; margin-bottom: 1rem;">
              <span class="avatar-filter emley" data-avatar="emley" onclick="toggleAvatarFilter('emley')" title="Filter by Emley">E</span>
              <span class="avatar-filter nate" data-avatar="nate" onclick="toggleAvatarFilter('nate')" title="Filter by Nate">N</span>
              <span class="avatar-filter family" data-avatar="family" onclick="toggleAvatarFilter('family')" title="Filter by Family">F</span>
            </div>
          </div>
        `;
        
        // Add search functionality
        setTimeout(() => {
          const searchInput = document.getElementById('todo-search-input');
          const dateFromInput = document.getElementById('todo-date-from');
          const dateToInput = document.getElementById('todo-date-to');
          
          if (searchInput) {
            searchInput.addEventListener('input', filterTodoHistory);
          }
          if (dateFromInput) {
            dateFromInput.addEventListener('change', filterTodoHistory);
          }
          if (dateToInput) {
            dateToInput.addEventListener('change', filterTodoHistory);
          }
        }, 100);
      } else {
        historyButton.textContent = 'History';
        headerTitle.textContent = 'To-Do List';
        if (calendarButton) {
          calendarButton.onclick = () => showFullscreenTodoCalendar(); // fullscreen view always
        }
        
        // Restore original header onclick behavior
        headerTitle.onclick = () => openFullscreen('todo');
        
        // Restore original add container
        const addContainer = document.getElementById('todo-add-container');
        addContainer.innerHTML = `
          <input type="text" id="todo-input" placeholder="Add new task..." maxlength="100">
          <button onclick="addTodoItem()" id="add-todo-btn">Add</button>
        `;
        
        // Restore the second container for assignment and date
        const secondContainer = document.getElementById('todo-secondary-container');
        if (secondContainer) {
          secondContainer.innerHTML = `
            <input type="date" id="todo-due-date" title="Due date (optional)">
            <div class="avatar-filters-container">
              <span class="avatar-filter emley" data-avatar="emley" onclick="toggleAvatarFilter('emley')" title="Filter by Emley">E</span>
              <span class="avatar-filter nate" data-avatar="nate" onclick="toggleAvatarFilter('nate')" title="Filter by Nate">N</span>
              <span class="avatar-filter family" data-avatar="family" onclick="toggleAvatarFilter('family')" title="Filter by Family">F</span>
            </div>
          `;
          secondContainer.style.display = 'flex';
        }
        addContainer.style.display = 'flex';
        
        // Re-add Enter key support
        document.getElementById('todo-input').addEventListener('keypress', function(e) {
          if (e.key === 'Enter') {
            addTodoItem();
          }
        });
      }
      
      renderTodoList();
    }

    function groupTodosByDate(todos) {
      const groups = {};
      
      todos.forEach(item => {
        const date = new Date(item.completedAt);
        const dateKey = date.toLocaleDateString('en-US', { 
          weekday: 'long', 
          year: 'numeric', 
          month: 'long', 
          day: 'numeric' 
        });
        
        if (!groups[dateKey]) {
          groups[dateKey] = [];
        }
        groups[dateKey].push(item);
      });
      
      return groups;
    }

    function renderTodoHistoryGrouped(groups) {
      let html = '';
      
      // Sort dates (most recent first)
      const sortedDates = Object.keys(groups).sort((a, b) => {
        const dateA = new Date(groups[a][0].completedAt);
        const dateB = new Date(groups[b][0].completedAt);
        return dateB - dateA;
      });
      
      sortedDates.forEach(dateKey => {
        html += `<li class="date-header">${dateKey}</li>`;
        
        // Sort items within each date group by order
        const sortedItems = sortItemsByOrder([...groups[dateKey]]);
        
        sortedItems.forEach(item => {
          const assignedTo = item.assignedTo || 'family'; // Default to family if not assigned
          const avatarHtml = `<span class="person-avatar ${assignedTo}" onclick="editTodoHistoryAssignment(${item.id})" title="Click to change assignment - Currently: ${assignedTo === 'emley' ? 'Emley' : assignedTo === 'nate' ? 'Nate' : 'Family'}" style="cursor: pointer;">${assignedTo === 'emley' ? 'E' : assignedTo === 'nate' ? 'N' : 'F'}</span>`;
          
          html += `
            <li class="task-item history-item" data-date-group="${dateKey}" data-item-id="${item.id}">
              <span class="drag-handle">â˜°</span>
              ${avatarHtml}
              <span class="task-text">${escapeHtml(item.text)}</span>
              <div class="task-actions">
                <button class="edit-btn" onclick="reAddTodoFromHistory(${item.id})" title="Add back to current list">â†©ï¸</button>
                <button class="delete-btn" onclick="deleteTodoHistoryItem(${item.id})" title="Delete">ðŸ—‘ï¸</button>
              </div>
            </li>
          `;
        });
      });
      
      return html;
    }

    function deleteTodoHistoryItem(id) {
      todoHistory = todoHistory.filter(item => item.id !== id);
      saveTodoHistory();
      
      // Render the appropriate view (widget or fullscreen)
      if (document.getElementById('fullscreen-container')) {
        renderTodoListFullscreen();
      } else {
      renderTodoList();
      }
    }

    function reAddTodoFromHistory(historyId) {
      // Find the item in history
      const historyItem = todoHistory.find(item => item.id === historyId);
      if (!historyItem) return;
      
      // Create new todo item with a new ID and the original text
      const newTodoId = Date.now();
      const newTodoItem = {
        id: newTodoId,
        text: historyItem.text,
        completed: false,
        originalHistoryId: historyId, // Track which history item this came from
        dueDate: historyItem.dueDate // Restore due date from history
      };
      
      // Add to current todo list
      todoItems.unshift(newTodoItem);
      
      // Remove from history immediately
      todoHistory = todoHistory.filter(item => item.id !== historyId);
      
      saveTodoItems();
      saveTodoHistory();
      
      // Render the appropriate view (widget or fullscreen)
      if (document.getElementById('fullscreen-container')) {
        renderTodoListFullscreen();
      } else {
      renderTodoList();
      }
      
      console.log(`Re-added "${historyItem.text}" to current todo list and removed from history`);
    }

    // Todo search functionality
    let currentTodoSearchTerm = '';
    let currentDateFrom = '';
    let currentDateTo = '';

    function filterTodoHistory() {
      const searchInput = document.getElementById('todo-search-input');
      const dateFromInput = document.getElementById('todo-date-from');
      const dateToInput = document.getElementById('todo-date-to');
      
      currentTodoSearchTerm = searchInput ? searchInput.value.toLowerCase().trim() : '';
      currentDateFrom = dateFromInput ? dateFromInput.value : '';
      currentDateTo = dateToInput ? dateToInput.value : '';
      
      renderTodoList();
    }

    function clearTodoSearch() {
      const searchInput = document.getElementById('todo-search-input');
      const dateFromInput = document.getElementById('todo-date-from');
      const dateToInput = document.getElementById('todo-date-to');
      
      if (searchInput) searchInput.value = '';
      if (dateFromInput) dateFromInput.value = '';
      if (dateToInput) dateToInput.value = '';
      
      currentTodoSearchTerm = '';
      currentDateFrom = '';
      currentDateTo = '';
      
      // Clear avatar filters
      selectedAvatarFilters = [];
      updateAvatarFilterButtons();
      
      renderTodoList();
    }

    function fuzzySearchTodos(items, searchTerm) {
      if (!searchTerm) return items;
      
      return items.filter(item => {
        const text = item.text.toLowerCase();
        
        // Exact match gets highest priority
        if (text.includes(searchTerm)) {
          return true;
        }
        
        // Fuzzy matching - check if all characters of search term appear in order
        let searchIndex = 0;
        for (let i = 0; i < text.length && searchIndex < searchTerm.length; i++) {
          if (text[i] === searchTerm[searchIndex]) {
            searchIndex++;
          }
        }
        
        return searchIndex === searchTerm.length;
      });
    }

    function filterTodosByDateRange(items, fromDate, toDate) {
      if (!fromDate && !toDate) return items;
      
      return items.filter(item => {
        const itemDate = new Date(item.completedAt);
        const itemDateString = itemDate.toISOString().split('T')[0];
        
        if (fromDate && itemDateString < fromDate) return false;
        if (toDate && itemDateString > toDate) return false;
        
        return true;
      });
    }

    // Grocery categorization system
    const groceryCategories = {
      'Produce': {
        keywords: ['apple', 'banana', 'orange', 'lemon', 'lime', 'grape', 'berry', 'strawberry', 'blueberry', 'raspberry', 'blackberry', 'cherry', 'peach', 'pear', 'plum', 'mango', 'pineapple', 'kiwi', 'avocado', 'tomato', 'cucumber', 'lettuce', 'spinach', 'kale', 'arugula', 'cabbage', 'broccoli', 'cauliflower', 'carrot', 'celery', 'onion', 'garlic', 'ginger', 'potato', 'sweet potato', 'bell pepper', 'jalapeÃ±o', 'mushroom', 'zucchini', 'squash', 'eggplant', 'corn', 'peas', 'green beans', 'asparagus', 'herbs', 'basil', 'cilantro', 'parsley', 'thyme', 'rosemary', 'oregano', 'dill', 'mint', 'salad', 'greens', 'radish', 'turnip', 'beet', 'leek', 'scallion', 'green onion', 'chives']
      },
      'Bakery': {
        keywords: ['bread', 'baguette', 'roll', 'bagel', 'croissant', 'muffin', 'donut', 'cake', 'cookie', 'pastry', 'pie', 'tart', 'danish', 'scone', 'biscuit', 'pretzel', 'loaf', 'sourdough', 'whole wheat', 'rye bread', 'pita', 'naan', 'tortilla', 'wrap']
      },
      'Deli': {
        keywords: ['deli meat', 'ham', 'turkey', 'salami', 'prosciutto', 'pastrami', 'roast beef', 'bologna', 'pepperoni', 'deli cheese', 'sliced cheese', 'sandwich', 'prepared salad', 'potato salad', 'coleslaw', 'hummus', 'olives', 'pickles']
      },
      'Meat & Seafood': {
        keywords: ['chicken', 'beef', 'pork', 'lamb', 'turkey', 'duck', 'steak', 'ground beef', 'ground turkey', 'chicken breast', 'chicken thigh', 'pork chop', 'bacon', 'sausage', 'fish', 'salmon', 'tuna', 'cod', 'tilapia', 'shrimp', 'crab', 'lobster', 'scallops', 'mussels', 'clams', 'oysters', 'meat', 'poultry', 'seafood']
      },
      'Dairy': {
        keywords: ['milk', 'yogurt', 'cheese', 'butter', 'egg', 'eggs', 'cream', 'sour cream', 'cottage cheese', 'cream cheese', 'mozzarella', 'cheddar', 'swiss', 'parmesan', 'feta', 'goat cheese', 'ricotta', 'half and half', 'heavy cream', 'whipping cream', 'buttermilk', 'kefir']
      },
      'Canned & Packaged Goods': {
        keywords: ['canned', 'can of', 'soup', 'broth', 'stock', 'beans', 'chickpeas', 'lentils', 'tomatoes', 'tomato sauce', 'pasta sauce', 'marinara', 'salsa', 'diced tomatoes', 'tomato paste', 'coconut milk', 'canned fruit', 'canned vegetables', 'corn', 'green beans', 'peas', 'carrots', 'jar', 'bottle', 'packaged', 'boxed']
      },
      'Spices': {
        keywords: ['spices', 'seasoning', 'dried herbs', 'cinnamon', 'paprika', 'cumin', 'chili powder', 'garlic powder', 'onion powder', 'turmeric', 'garam masala', 'coriander', 'cardamom', 'black pepper', 'white pepper', 'cayenne', 'nutmeg', 'cloves', 'allspice', 'bay leaves', 'curry powder', 'italian seasoning', 'mustard seed', 'celery seed', 'fennel', 'star anise', 'saffron', 'vanilla bean', 'ground', 'dried']
      },
      'Dry Goods & Baking': {
        keywords: ['flour', 'sugar', 'brown sugar', 'powdered sugar', 'baking powder', 'baking soda', 'vanilla', 'extract', 'oil', 'olive oil', 'vegetable oil', 'coconut oil', 'vinegar', 'salt', 'baking mix', 'pancake mix', 'cake mix', 'cornstarch', 'cocoa powder', 'chocolate chips', 'nuts', 'almonds', 'walnuts', 'pecans', 'peanuts']
      },
      'Snacks & Candy': {
        keywords: ['chips', 'crackers', 'pretzels', 'popcorn', 'nuts', 'trail mix', 'granola bar', 'energy bar', 'protein bar', 'candy', 'chocolate', 'gum', 'mints', 'cookies', 'snacks', 'goldfish', 'cheez-its', 'oreos', 'graham crackers']
      },
      'Cereal & Breakfast': {
        keywords: ['cereal', 'oatmeal', 'granola', 'muesli', 'pancake mix', 'waffle mix', 'syrup', 'maple syrup', 'honey', 'jam', 'jelly', 'peanut butter', 'almond butter', 'nutella', 'breakfast', 'oats', 'quinoa flakes']
      },
      'Pasta, Rice & International Foods': {
        keywords: ['pasta', 'spaghetti', 'penne', 'fusilli', 'linguine', 'fettuccine', 'macaroni', 'lasagna', 'ravioli', 'rice', 'brown rice', 'white rice', 'jasmine rice', 'basmati rice', 'wild rice', 'quinoa', 'couscous', 'noodles', 'ramen', 'udon', 'soba', 'rice noodles', 'pad thai', 'curry', 'soy sauce', 'teriyaki', 'sriracha', 'hot sauce', 'salsa', 'tahini', 'miso', 'kimchi', 'international', 'ethnic']
      },
      'Frozen Foods': {
        keywords: ['frozen', 'ice cream', 'frozen yogurt', 'sorbet', 'frozen fruit', 'frozen vegetables', 'frozen dinner', 'frozen pizza', 'frozen burrito', 'frozen meal', 'frozen chicken', 'frozen fish', 'frozen shrimp', 'frozen berries', 'frozen peas', 'frozen corn', 'frozen broccoli', 'frozen spinach', 'popsicle', 'ice', 'frozen bread', 'frozen pastry']
      },
      'Beverages': {
        keywords: ['water', 'sparkling water', 'juice', 'orange juice', 'apple juice', 'cranberry juice', 'soda', 'cola', 'pepsi', 'coke', 'sprite', 'coffee', 'green tea', 'black tea', 'herbal tea', 'energy drink', 'sports drink', 'beer', 'wine', 'alcohol', 'vodka', 'whiskey', 'rum', 'gin', 'champagne', 'kombucha', 'smoothie', 'protein shake', 'almond milk', 'oat milk', 'soy milk', 'coconut milk', 'rice milk']
      },
      'Health & Beauty': {
        keywords: ['shampoo', 'conditioner', 'soap', 'body wash', 'lotion', 'moisturizer', 'sunscreen', 'toothpaste', 'toothbrush', 'mouthwash', 'deodorant', 'perfume', 'cologne', 'makeup', 'lipstick', 'mascara', 'foundation', 'vitamins', 'supplements', 'medicine', 'advil', 'tylenol', 'aspirin', 'bandaids', 'first aid', 'contact solution', 'razor', 'shaving cream']
      },
      'Cleaning & Household': {
        keywords: ['laundry', 'laundry detergent', 'fabric softener', 'bleach', 'clorox', 'dish soap', 'dishwasher detergent', 'all-purpose cleaner', 'glass cleaner', 'bathroom cleaner', 'toilet cleaner', 'toilet bowl cleaner', 'bowl cleaner', 'toilet paper', 'paper towels', 'napkins', 'tissues', 'trash bags', 'garbage bags', 'aluminum foil', 'plastic wrap', 'parchment paper', 'wax paper', 'sponges', 'scrubber', 'cleaning supplies', 'vacuum bags', 'air freshener', 'candles', 'light bulbs', 'batteries', 'disinfectant', 'sanitizer', 'wipes', 'cleaning wipes', 'stain', 'stain remover', 'command hook', 'command hooks', 'command strip', 'command strips']
      },
      'Pet Supplies': {
        keywords: ['dog food', 'cat food', 'pet food', 'dog treats', 'cat treats', 'pet treats', 'cat litter', 'dog toys', 'cat toys', 'pet toys', 'leash', 'collar', 'pet supplies', 'bird food', 'fish food', 'hamster food', 'guinea pig food']
      },
      'Floral Department': {
        keywords: ['flowers', 'bouquet', 'roses', 'tulips', 'daisies', 'carnations', 'lilies', 'plants', 'potted plant', 'succulent', 'orchid', 'floral', 'gift card', 'balloon', 'greeting card']
      },
      'Pharmacy': {
        keywords: ['prescription', 'medication', 'pharmacy', 'pills', 'capsules', 'tablets', 'insulin', 'inhaler', 'antibiotic', 'pain reliever', 'allergy medicine', 'cold medicine', 'cough syrup', 'eye drops', 'ear drops']
      }
    };

    function categorizeGroceryItem(itemText, manualCategory = null) {
      // If manual category is set, use it
      if (manualCategory) {
        return manualCategory;
      }
      
      const text = itemText.toLowerCase();
      
      // Priority rules - check these first before general keyword matching
      
      // 1. Canned/Packaged indicators override everything
      const canPackageIndicators = ['can of', 'canned', 'jar of', 'bottle of', 'packaged', 'boxed', '15-ounce can', '14-ounce can', 'oz can', 'fl oz'];
      if (canPackageIndicators.some(indicator => text.includes(indicator))) {
        return 'Canned & Packaged Goods';
      }
      
      // 2. Jarred/bottled garlic goes to Canned & Packaged Goods
      const jarredGarlicIndicators = [
        'garlic, from a jar', 'ready-minced garlic', 'bottled minced garlic', 
        'prepared garlic', 'jarred garlic', 'minced garlic in jar'
      ];
      const measurementPattern = /\b\d*\s*(teaspoon|tsp|tablespoon|tbsp)\s+minced garlic\b/;
      
      if (jarredGarlicIndicators.some(indicator => text.includes(indicator)) ||
          (text.includes('minced garlic') && 
           (text.includes('teaspoon') || text.includes('tsp') || text.includes('tablespoon') || text.includes('tbsp')) &&
           !text.includes('powder') && !text.includes('clove'))) {
        return 'Canned & Packaged Goods';
      }
      
      // 3. Fresh garlic cloves go to Produce (garlic cloves, fresh garlic, minced garlic cloves, etc.)
      const garlicCloveIndicators = [
        'garlic clove', 'garlic cloves', 'fresh garlic', 'minced garlic cloves', 
        'chopped garlic', 'crushed garlic', 'smashed garlic', 'whole clove garlic', 
        'whole cloves garlic', 'peeled garlic', 'clove garlic', 'cloves garlic'
      ];
      const clovePattern = /\b\d+\s+clove[s]?\b/; // Matches "1 clove", "2 cloves", "3 cloves", etc.
      
      if (garlicCloveIndicators.some(indicator => text.includes(indicator)) || 
          (text.includes('garlic') && clovePattern.test(text))) {
        return 'Produce';
      }
      
      // 4. Fresh herbs and spices go to Produce (fresh parsley, fresh ginger, etc.)
      const freshHerbKeywords = ['parsley', 'cilantro', 'basil', 'thyme', 'rosemary', 'oregano', 'dill', 'mint', 'sage', 'chives', 'ginger', 'garlic', 'onion'];
      if (text.includes('fresh') && freshHerbKeywords.some(herb => text.includes(herb))) {
        return 'Produce';
      }
      
      // 5. Spice measurements indicate Spices (but not fresh ones)
      const spiceMeasurements = ['teaspoon', 'tsp', 'tablespoon', 'tbsp', 'pinch of', 'dash of', 'ground ', 'dried '];
      const spiceKeywords = ['turmeric', 'garam masala', 'cumin', 'coriander', 'cardamom', 'cinnamon', 'paprika', 'chili powder', 'curry powder', 'oregano', 'basil', 'thyme', 'rosemary', 'sage', 'parsley', 'cilantro', 'dill', 'mint', 'garlic powder', 'onion powder', 'black pepper', 'white pepper', 'cayenne', 'nutmeg', 'cloves', 'allspice', 'bay leaves'];
      
      if ((spiceMeasurements.some(measurement => text.includes(measurement)) || 
          (spiceKeywords.some(spice => text.includes(spice)) && 
           (text.includes('ground') || text.includes('dried') || text.includes('powder') || text.includes('teaspoon') || text.includes('tablespoon')))) &&
          !text.includes('fresh')) {
        return 'Spices';
      }
      
      // 6. Frozen indicators
      if (text.includes('frozen')) {
        return 'Frozen Foods';
      }
      
      // 7. Fresh meat indicators
      const meatPreparations = ['boneless', 'skinless', 'ground', 'chopped', 'diced', 'sliced', 'whole', 'fresh'];
      const meatTypes = ['chicken', 'beef', 'pork', 'lamb', 'turkey', 'duck', 'fish', 'salmon', 'tuna'];
      if (meatTypes.some(meat => text.includes(meat)) && 
          (meatPreparations.some(prep => text.includes(prep)) || text.includes('lb') || text.includes('pound'))) {
        return 'Meat & Seafood';
      }
      
      // 8. Dairy with measurements
      if ((text.includes('cup') || text.includes('oz') || text.includes('pint') || text.includes('quart') || text.includes('gallon')) &&
          (text.includes('milk') || text.includes('cream') || text.includes('yogurt') || text.includes('butter'))) {
        return 'Dairy';
      }
      
      // 9. Cleaning products (check before baking measurements)
      const cleaningIndicators = ['cleaner', 'detergent', 'bleach', 'clorox', 'disinfectant', 'sanitizer', 'wipes', 'toilet', 'bathroom', 'kitchen cleaner', 'laundry', 'stain', 'command hook', 'command strip'];
      if (cleaningIndicators.some(indicator => text.includes(indicator))) {
        return 'Cleaning & Household';
      }
      
      // 10. Baking measurements
      const bakingMeasurements = ['cup', 'cups', 'lb', 'pound', 'ounce', 'oz'];
      const bakingIngredients = ['flour', 'sugar', 'brown sugar', 'powdered sugar', 'baking powder', 'baking soda', 'vanilla extract', 'oil'];
      if (bakingMeasurements.some(measurement => text.includes(measurement)) &&
          bakingIngredients.some(ingredient => text.includes(ingredient))) {
        return 'Dry Goods & Baking';
      }
      
      // Now do general keyword matching for remaining items
      for (const [category, data] of Object.entries(groceryCategories)) {
        for (const keyword of data.keywords) {
          if (text.includes(keyword)) {
            return category;
          }
        }
      }
      
      return 'Other'; // Default category for items that don't match
    }

    function groupGroceriesByCategory(items) {
      const grouped = {};
      
      items.forEach(item => {
        const category = categorizeGroceryItem(item.text, item.manualCategory);
        if (!grouped[category]) {
          grouped[category] = [];
        }
        grouped[category].push(item);
      });
      
      return grouped;
    }

    // Function to handle dropping grocery items into different categories
    function handleGroceryCategoryDrop(draggedItemId, targetCategory) {
      const item = groceryItems.find(item => item.id === draggedItemId);
      if (item && targetCategory) {
        item.manualCategory = targetCategory;
        saveGroceryItems();
        renderGroceryList();
        
        // Also update fullscreen view if it's open
        if (document.getElementById('fullscreen-grocery-list')) {
          renderGroceryListFullscreen();
        }
      }
    }

    // Enhanced drag-and-drop for categorized grocery lists
    let groceryDraggedItem = null;
    let groceryDraggedCategory = null;
    let groceryDraggedIndex = null;

    function setupGroceryDragAndDrop(listElement) {
      const listItems = listElement.querySelectorAll('.task-item');
      const categoryHeaders = listElement.querySelectorAll('.category-header');
      
      // Set up drag handles for grocery items
      listItems.forEach((item, globalIndex) => {
        const dragHandle = item.querySelector('.drag-handle');
        if (dragHandle) {
          dragHandle.title = 'Drag to reorder or move to different category';
          dragHandle.draggable = true;
          
          // Clear any existing event listeners by cloning the element
          const newDragHandle = dragHandle.cloneNode(true);
          dragHandle.parentNode.replaceChild(newDragHandle, dragHandle);
          const handle = newDragHandle;
          
          handle.addEventListener('dragstart', (e) => {
            const itemId = parseFloat(item.getAttribute('data-item-id'));
            
            if (itemId) {
              groceryDraggedItem = groceryItems.find(item => item.id === itemId);
              groceryDraggedCategory = categorizeGroceryItem(groceryDraggedItem.text, groceryDraggedItem.manualCategory);
              
              // Find index within the category
              const categoryItems = groceryItems.filter(item => 
                categorizeGroceryItem(item.text, item.manualCategory) === groceryDraggedCategory
              );
              groceryDraggedIndex = categoryItems.findIndex(item => item.id === itemId);
              
              item.classList.add('dragging');
              item.style.opacity = '0.5';
              e.dataTransfer.effectAllowed = 'move';
              e.dataTransfer.setData('text/plain', itemId.toString());
            }
          });
          
          handle.addEventListener('dragend', (e) => {
            item.classList.remove('dragging');
            item.style.opacity = '1';
            groceryDraggedItem = null;
            groceryDraggedCategory = null;
            groceryDraggedIndex = null;
            
            // Remove all drop indicators
            clearGroceryDropIndicators(listElement);
          });
          
          // Touch drag events for mobile
          let touchStartY = 0;
          let touchStartX = 0;
          let isDragging = false;
          let hasMoved = false;
          let placeholder = null;
          let initialRect = null;
          let lastUpdateTime = 0;
          let scrollOffset = 0; // Track cumulative scroll offset
          
          handle.addEventListener('touchstart', (e) => {
            e.preventDefault();
            
            touchStartY = e.touches[0].clientY;
            touchStartX = e.touches[0].clientX;
            isDragging = false;
            hasMoved = false;
            scrollOffset = 0;
            lastUpdateTime = 0;
            
            const itemId = parseFloat(item.getAttribute('data-item-id'));
            if (itemId) {
              groceryDraggedItem = groceryItems.find(item => item.id === itemId);
              groceryDraggedCategory = categorizeGroceryItem(groceryDraggedItem.text, groceryDraggedItem.manualCategory);
            }
          }, { passive: false });
          
          handle.addEventListener('touchmove', (e) => {
            e.preventDefault();
            
            const currentY = e.touches[0].clientY;
            const currentX = e.touches[0].clientX;
            const deltaY = currentY - touchStartY;
            const deltaX = currentX - touchStartX;
            
            if (!isDragging && (Math.abs(deltaY) > 3 || Math.abs(deltaX) > 3)) {
              isDragging = true;
              
              // Get rect BEFORE changing position
              initialRect = item.getBoundingClientRect();
              
              item.classList.add('dragging');
              item.style.opacity = '0'; // Hide dragged item, only show placeholder
              item.style.position = 'fixed';
              item.style.left = `${initialRect.left}px`;
              item.style.top = `${initialRect.top}px`;
              item.style.width = `${initialRect.width}px`;
              item.style.zIndex = '1000';
              
              // Create placeholder (but don't insert yet)
              placeholder = item.cloneNode(true);
              placeholder.style.pointerEvents = 'none';
              placeholder.classList.add('drag-placeholder');
              placeholder.classList.remove('dragging');
              placeholder.style.transform = '';
              placeholder.style.zIndex = '';
              placeholder.style.position = '';
              placeholder.style.left = '';
              placeholder.style.top = '';
              placeholder.style.width = '';
            }
            
            if (isDragging) {
              hasMoved = true;
              
              // Auto-scroll when near edges of viewport
              const scrollThreshold = 100; // pixels from edge to trigger scroll
              const scrollSpeed = 4; // pixels per frame (reduced for smoother control)
              
              // Find the scrollable container (could be window or a scrollable div)
              let scrollableElement = window;
              let scrollableContainer = document.documentElement;
              
              // Check if listElement itself or its parents are scrollable
              let parent = listElement;
              while (parent && parent !== document.body) {
                const style = window.getComputedStyle(parent);
                const overflowY = style.overflowY;
                const isScrollable = (overflowY === 'auto' || overflowY === 'scroll' || overflowY === 'overlay');
                const hasScroll = parent.scrollHeight > parent.clientHeight;
                
                console.log('ðŸ” Checking element:', {
                  tagName: parent.tagName,
                  id: parent.id,
                  overflowY,
                  isScrollable,
                  scrollHeight: parent.scrollHeight,
                  clientHeight: parent.clientHeight,
                  hasScroll
                });
                
                if (isScrollable && hasScroll) {
                  scrollableElement = parent;
                  scrollableContainer = parent;
                  console.log('âœ… Found scrollable container:', parent.tagName, parent.id);
                  break;
                }
                parent = parent.parentElement;
              }
              
              const currentScrollY = scrollableElement === window ? window.scrollY : scrollableContainer.scrollTop;
              const maxScrollY = scrollableContainer.scrollHeight - scrollableContainer.clientHeight;
              
              // Get container bounds for relative positioning
              const containerRect = scrollableElement === window ? 
                { top: 0, bottom: window.innerHeight } : 
                scrollableContainer.getBoundingClientRect();
              
              // Check if finger is near top/bottom of the scrollable container
              const nearContainerTop = currentY < containerRect.top + scrollThreshold;
              const nearContainerBottom = currentY > containerRect.bottom - scrollThreshold;
              
              if (nearContainerTop && currentScrollY > 0) {
                // Near top of container - scroll up
                if (scrollableElement === window) {
                  window.scrollBy(0, -scrollSpeed);
                } else {
                  scrollableContainer.scrollTop -= scrollSpeed;
                }
                scrollOffset -= scrollSpeed;
              } else if (nearContainerBottom && currentScrollY < maxScrollY) {
                // Near bottom of container - scroll down
                if (scrollableElement === window) {
                  window.scrollBy(0, scrollSpeed);
                } else {
                  scrollableContainer.scrollTop += scrollSpeed;
                }
                scrollOffset += scrollSpeed;
              }
              
              // ALWAYS update position (don't throttle this - it needs to be smooth)
              item.style.top = `${initialRect.top + (currentY - touchStartY) + scrollOffset}px`;
              
              // Throttle placeholder updates to every 32ms for smoother performance
              const now = Date.now();
              if (now - lastUpdateTime < 32) {
                return; // Skip placeholder update but keep item moving
              }
              lastUpdateTime = now;
              
              // Simple drop detection - just use standard getDragAfterElement
              // This allows cross-category moves and is much simpler/smoother
              const afterElement = getDragAfterElement(listElement, currentY);
              if (afterElement == null) {
                listElement.appendChild(placeholder);
              } else {
                listElement.insertBefore(placeholder, afterElement);
              }
            }
          }, { passive: false });
          
          handle.addEventListener('touchend', (e) => {
            e.preventDefault();
            
            if (!isDragging || !hasMoved) {
              groceryDraggedItem = null;
              groceryDraggedCategory = null;
              return;
            }
            
            item.classList.remove('dragging');
            
            const placeholderRect = placeholder.getBoundingClientRect();
            
            // Animate to placeholder position using top
            item.style.transition = 'top 0.15s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.15s ease';
            item.style.top = `${placeholderRect.top}px`;
            item.style.opacity = '1';
            
            setTimeout(() => {
              item.style.transition = '';
              item.style.transform = '';
              item.style.opacity = '';
              item.style.zIndex = '';
              item.style.position = '';
              item.style.left = '';
              item.style.top = '';
              item.style.width = '';
              
              if (placeholder && placeholder.parentNode) {
                placeholder.parentNode.insertBefore(item, placeholder);
                placeholder.parentNode.removeChild(placeholder);
              }
              
              if (groceryDraggedItem) {
                // Determine target category from placeholder position
                const placeholderPrevSibling = placeholder.previousElementSibling;
                const placeholderNextSibling = placeholder.nextElementSibling;
                
                let targetCategory = groceryDraggedCategory;
                
                // Check siblings to determine category
                if (placeholderNextSibling && placeholderNextSibling.classList.contains('task-item')) {
                  const nextId = parseFloat(placeholderNextSibling.getAttribute('data-item-id'));
                  const nextItem = groceryItems.find(i => i.id === nextId);
                  if (nextItem) {
                    targetCategory = categorizeGroceryItem(nextItem.text, nextItem.manualCategory);
                  }
                } else if (placeholderPrevSibling && placeholderPrevSibling.classList.contains('task-item')) {
                  const prevId = parseFloat(placeholderPrevSibling.getAttribute('data-item-id'));
                  const prevItem = groceryItems.find(i => i.id === prevId);
                  if (prevItem) {
                    targetCategory = categorizeGroceryItem(prevItem.text, prevItem.manualCategory);
                  }
                } else if (placeholderPrevSibling && placeholderPrevSibling.classList.contains('category-header')) {
                  targetCategory = placeholderPrevSibling.getAttribute('data-category');
                }
                
                // Update category if different
                if (targetCategory !== groceryDraggedCategory) {
                  groceryDraggedItem.manualCategory = targetCategory;
                }
                
                // Get all items in target category from DOM order
                const categoryElements = Array.from(listElement.querySelectorAll('.task-item')).filter(el => {
                  const id = parseFloat(el.getAttribute('data-item-id'));
                  const groceryItem = groceryItems.find(item => item.id === id);
                  return groceryItem && categorizeGroceryItem(groceryItem.text, groceryItem.manualCategory) === targetCategory;
                });
                
                // Update order values
                const baseOrder = Date.now();
                categoryElements.forEach((el, idx) => {
                  const id = parseFloat(el.getAttribute('data-item-id'));
                  const groceryItem = groceryItems.find(item => item.id === id);
                  if (groceryItem) {
                    groceryItem.order = baseOrder - idx;
                  }
                });
                
                saveGroceryItems();
              }
              
              groceryDraggedItem = null;
              groceryDraggedCategory = null;
              isDragging = false;
              hasMoved = false;
              placeholder = null;
            }, 150);
          }, { passive: false });
        }
        
        // Make sure only drag handle is draggable
        item.draggable = false;
        
        // Set up drop zones for reordering within categories
        item.addEventListener('dragenter', (e) => {
          e.preventDefault();
          if (groceryDraggedItem && groceryDraggedItem.id !== parseFloat(item.getAttribute('data-item-id'))) {
            updateGroceryDropIndicator(e, item, listElement);
          }
        });
        
        item.addEventListener('dragover', (e) => {
          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';
          if (groceryDraggedItem && groceryDraggedItem.id !== parseFloat(item.getAttribute('data-item-id'))) {
            updateGroceryDropIndicator(e, item, listElement);
          }
        });
        
        item.addEventListener('dragleave', (e) => {
          if (!item.contains(e.relatedTarget)) {
            clearGroceryDropIndicators(listElement);
          }
        });
        
        item.addEventListener('drop', (e) => {
          e.preventDefault();
          clearGroceryDropIndicators(listElement);
          
          if (groceryDraggedItem) {
            const targetItemId = parseFloat(item.getAttribute('data-item-id'));
            const targetItem = groceryItems.find(item => item.id === targetItemId);
            const draggedItemElement = listElement.querySelector(`[data-item-id="${groceryDraggedItem.id}"]`);
            
            if (targetItem && targetItem.id !== groceryDraggedItem.id && draggedItemElement) {
              const targetCategory = categorizeGroceryItem(targetItem.text, targetItem.manualCategory);
              const rect = item.getBoundingClientRect();
              const mouseY = e.clientY;
              const insertBefore = mouseY < rect.top + rect.height / 2;
              
              // Always update category if different
              if (targetCategory !== groceryDraggedCategory) {
                groceryDraggedItem.manualCategory = targetCategory;
              }
              
              // Insert in DOM at the correct position
              if (insertBefore) {
                item.parentNode.insertBefore(draggedItemElement, item);
              } else {
                if (item.nextSibling) {
                  item.parentNode.insertBefore(draggedItemElement, item.nextSibling);
                } else {
                  item.parentNode.appendChild(draggedItemElement);
                }
              }
              
              // Get all items in the target category from DOM order
              const categoryElements = Array.from(listElement.querySelectorAll('.task-item')).filter(el => {
                const id = parseFloat(el.getAttribute('data-item-id'));
                const groceryItem = groceryItems.find(item => item.id === id);
                return groceryItem && categorizeGroceryItem(groceryItem.text, groceryItem.manualCategory) === targetCategory;
              });
              
              // Update order values based on DOM position
              const baseOrder = Date.now();
              categoryElements.forEach((el, idx) => {
                const id = parseFloat(el.getAttribute('data-item-id'));
                const groceryItem = groceryItems.find(item => item.id === id);
                if (groceryItem) {
                  groceryItem.order = baseOrder - idx;
                }
              });
              
              saveGroceryItems();
            }
          }
        });
      });
      
      // Set up category headers as drop zones with improved reliability
      categoryHeaders.forEach(header => {
        // Make header draggable area larger
        header.style.cursor = 'pointer';
        header.style.minHeight = '40px';
        header.style.display = 'flex';
        header.style.alignItems = 'center';
        
        header.addEventListener('dragenter', (e) => {
          e.preventDefault();
          if (groceryDraggedItem) {
            header.style.background = '#e3f2fd';
            header.style.transform = 'scale(1.02)';
            header.style.boxShadow = '0 2px 8px rgba(102, 126, 234, 0.3)';
          }
        });
        
        header.addEventListener('dragover', (e) => {
          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';
          if (groceryDraggedItem) {
            header.style.background = '#e3f2fd';
          }
        });
        
        header.addEventListener('dragleave', (e) => {
          // Only reset if actually leaving (not entering child)
          if (!header.contains(e.relatedTarget)) {
            header.style.background = '#f8f9fa';
            header.style.transform = '';
            header.style.boxShadow = '';
          }
        });
        
        header.addEventListener('drop', (e) => {
          e.preventDefault();
          e.stopPropagation();
          header.style.background = '#f8f9fa';
          header.style.transform = '';
          header.style.boxShadow = '';
          
          if (groceryDraggedItem) {
            const targetCategory = header.getAttribute('data-category');
            if (targetCategory) {
              // Update category
              groceryDraggedItem.manualCategory = targetCategory;
              
              // Set order to be at the end of the category
              const categoryItems = groceryItems.filter(item => 
                categorizeGroceryItem(item.text, item.manualCategory) === targetCategory
              );
              const minOrder = Math.min(...categoryItems.map(item => item.order || 0), 0);
              groceryDraggedItem.order = minOrder - 1;
              
              saveGroceryItems();
              
              // Re-render appropriate view
              if (document.getElementById('fullscreen-grocery-list')) {
                renderGroceryListFullscreen();
              } else {
                renderGroceryList();
              }
            }
          }
        });
      });
    }

    function updateGroceryDropIndicator(event, targetItem, listElement) {
      clearGroceryDropIndicators(listElement);
      
      if (!groceryDraggedItem) return;
      
      const rect = targetItem.getBoundingClientRect();
      const mouseY = event.clientY;
      const itemMiddle = rect.top + rect.height / 2;
      
      if (mouseY < itemMiddle) {
        targetItem.classList.add('drop-target-above');
      } else {
        targetItem.classList.add('drop-target-below');
      }
    }

    function clearGroceryDropIndicators(listElement) {
      const listItems = listElement.querySelectorAll('.task-item');
      listItems.forEach(item => {
        item.classList.remove('drop-target-above', 'drop-target-below');
      });
    }

    function reorderGroceryItemsWithinCategory(draggedItem, targetItem, category) {
      // Get all items in this category (references to actual items, not copies)
      const categoryItems = groceryItems.filter(item => 
        categorizeGroceryItem(item.text, item.manualCategory) === category
      );
      
      // Find current positions
      const draggedIndex = categoryItems.findIndex(item => item.id === draggedItem.id);
      const targetIndex = categoryItems.findIndex(item => item.id === targetItem.id);
      
      if (draggedIndex !== -1 && targetIndex !== -1 && draggedIndex !== targetIndex) {
        // Determine if we're moving up or down
        const isMovingDown = draggedIndex < targetIndex;
        
        // Calculate new order value based on target position
        let newOrder;
        if (targetIndex === 0) {
          // Moving to first position
          newOrder = (categoryItems[0].order || 0) + 1;
        } else if (targetIndex === categoryItems.length - 1) {
          // Moving to last position
          newOrder = (categoryItems[categoryItems.length - 1].order || 0) - 1;
        } else {
          // Moving to middle position - place between target and next item
          const targetOrder = categoryItems[targetIndex].order || 0;
          const nextIndex = isMovingDown ? targetIndex + 1 : targetIndex - 1;
          const nextOrder = categoryItems[nextIndex].order || 0;
          newOrder = (targetOrder + nextOrder) / 2;
        }
        
        // Update the dragged item's order
        draggedItem.order = newOrder;
        
        // If orders get too close together, renumber the entire category
        const minOrderDiff = 0.001;
        const needsRenumbering = categoryItems.some((item, index) => {
          if (index === 0) return false;
          const prevOrder = categoryItems[index - 1].order || 0;
          const currOrder = item.order || 0;
          return Math.abs(prevOrder - currOrder) < minOrderDiff;
        });
        
        if (needsRenumbering) {
          // Sort items by order and renumber
          categoryItems.sort((a, b) => (b.order || 0) - (a.order || 0));
          const baseOrder = Date.now();
          categoryItems.forEach((item, index) => {
            item.order = baseOrder - index;
          });
        }
      }
    }

    // Grocery List Functions
    function addGroceryItem() {
      const input = document.getElementById('grocery-input');
      const text = input.value.trim();
      
      if (text) {
        const item = {
          id: Date.now(),
          text: text,
          completed: false,
          createdAt: new Date().toISOString(),
          order: Date.now() // Add order property for sorting
        };
        
        groceryItems.unshift(item); // Add to beginning of array
        updateItemOrders(groceryItems); // Update all orders
        saveGroceryItems();
        renderGroceryList();
        input.value = '';
      }
    }

    function toggleGroceryItem(id) {
      const item = groceryItems.find(item => item.id === id);
      if (item) {
        item.completed = !item.completed;
        if (item.completed) {
          item.completedAt = new Date().toISOString();
        } else {
          delete item.completedAt;
        }
        saveGroceryItems();
        renderGroceryList();
      }
    }

    function deleteGroceryItem(id) {
      groceryItems = groceryItems.filter(item => item.id !== id);
      saveGroceryItems();
      renderGroceryList();
    }

    function editGroceryItem(id) {
      const item = groceryItems.find(item => item.id === id);
      if (!item) return;

      // Create modal
      const modal = document.createElement('div');
      modal.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
        background: rgba(0,0,0,0.5); display: flex; align-items: center; 
        justify-content: center; z-index: 1000;
      `;

      const dialog = document.createElement('div');
      dialog.style.cssText = `
        background: white; padding: 24px; border-radius: 12px; 
        max-width: 400px; width: 90%; 
        box-shadow: 0 10px 25px rgba(0,0,0,0.2);
      `;

      dialog.innerHTML = `
        <h3 style="margin: 0 0 20px 0; color: #333;">Edit Grocery Item</h3>
        
        <div style="margin-bottom: 16px;">
          <label style="display: block; margin-bottom: 8px; font-weight: 500; color: #555;">Item:</label>
          <input type="text" id="edit-grocery-text" value="${escapeHtml(item.text)}" 
                 style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 6px; 
                        font-size: 14px; box-sizing: border-box;">
        </div>

        <div style="margin-bottom: 16px;">
          <label style="display: block; margin-bottom: 8px; font-weight: 500; color: #555;">Recipe Source:</label>
          <input type="text" id="edit-grocery-source" value="${escapeHtml(item.recipeSource || '')}" 
                 placeholder="e.g., Butter Chicken, Pasta Recipe..." 
                 style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 6px; 
                        font-size: 14px; box-sizing: border-box;">
        </div>

        <div style="margin-bottom: 16px;">
          <label style="display: block; margin-bottom: 8px; font-weight: 500; color: #555;">Category:</label>
          <select id="edit-grocery-category" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 6px; 
                         font-size: 14px; box-sizing: border-box; background: white;">
            <option value="">Auto-categorize</option>
            <option value="Produce" ${item.manualCategory === 'Produce' ? 'selected' : ''}>Produce</option>
            <option value="Bakery" ${item.manualCategory === 'Bakery' ? 'selected' : ''}>Bakery</option>
            <option value="Deli" ${item.manualCategory === 'Deli' ? 'selected' : ''}>Deli</option>
            <option value="Meat & Seafood" ${item.manualCategory === 'Meat & Seafood' ? 'selected' : ''}>Meat & Seafood</option>
            <option value="Dairy" ${item.manualCategory === 'Dairy' ? 'selected' : ''}>Dairy</option>
            <option value="Canned & Packaged Goods" ${item.manualCategory === 'Canned & Packaged Goods' ? 'selected' : ''}>Canned & Packaged Goods</option>
            <option value="Spices" ${item.manualCategory === 'Spices' ? 'selected' : ''}>Spices</option>
            <option value="Dry Goods & Baking" ${item.manualCategory === 'Dry Goods & Baking' ? 'selected' : ''}>Dry Goods & Baking</option>
            <option value="Snacks & Candy" ${item.manualCategory === 'Snacks & Candy' ? 'selected' : ''}>Snacks & Candy</option>
            <option value="Cereal & Breakfast" ${item.manualCategory === 'Cereal & Breakfast' ? 'selected' : ''}>Cereal & Breakfast</option>
            <option value="Pasta, Rice & International Foods" ${item.manualCategory === 'Pasta, Rice & International Foods' ? 'selected' : ''}>Pasta, Rice & International Foods</option>
            <option value="Frozen Foods" ${item.manualCategory === 'Frozen Foods' ? 'selected' : ''}>Frozen Foods</option>
            <option value="Beverages" ${item.manualCategory === 'Beverages' ? 'selected' : ''}>Beverages</option>
            <option value="Health & Beauty" ${item.manualCategory === 'Health & Beauty' ? 'selected' : ''}>Health & Beauty</option>
            <option value="Cleaning & Household" ${item.manualCategory === 'Cleaning & Household' ? 'selected' : ''}>Cleaning & Household</option>
            <option value="Pet Supplies" ${item.manualCategory === 'Pet Supplies' ? 'selected' : ''}>Pet Supplies</option>
            <option value="Floral Department" ${item.manualCategory === 'Floral Department' ? 'selected' : ''}>Floral Department</option>
            <option value="Pharmacy" ${item.manualCategory === 'Pharmacy' ? 'selected' : ''}>Pharmacy</option>
            <option value="Other" ${item.manualCategory === 'Other' ? 'selected' : ''}>Other</option>
          </select>
        </div>

        <div style="margin-bottom: 20px;">
          <label style="display: flex; align-items: center; gap: 8px; font-weight: 500; color: #555; cursor: pointer;">
            <input type="checkbox" id="edit-grocery-optional" ${item.isOptional ? 'checked' : ''} 
                   style="margin: 0;">
            Mark as optional ingredient
          </label>
        </div>

        <div style="display: flex; gap: 12px; justify-content: flex-end;">
          <button id="grocery-edit-cancel-btn" style="padding: 10px 20px; border: 1px solid #ddd; 
                  border-radius: 6px; background: white; cursor: pointer;">Cancel</button>
          <button id="grocery-edit-save-btn" style="padding: 10px 20px; border: none; border-radius: 6px; 
                  background: var(--primary-color); color: white; cursor: pointer;">Save</button>
        </div>
      `;

      modal.appendChild(dialog);
      document.body.appendChild(modal);

      // Get input elements
      const textInput = document.getElementById('edit-grocery-text');
      const sourceInput = document.getElementById('edit-grocery-source');
      const categorySelect = document.getElementById('edit-grocery-category');
      const optionalCheckbox = document.getElementById('edit-grocery-optional');
      const saveBtn = document.getElementById('grocery-edit-save-btn');
      const cancelBtn = document.getElementById('grocery-edit-cancel-btn');

      // Focus on text input
      textInput.focus();
      textInput.select();

      const handleSave = () => {
        const newText = textInput.value.trim();
        if (!newText) {
          textInput.focus();
          return;
        }

        const newSource = sourceInput.value.trim();
        const newCategory = categorySelect.value || null;
        const isOptional = optionalCheckbox.checked;
        
        // Update item
        item.text = newText;
        item.recipeSource = newSource || null;
        item.manualCategory = newCategory;
        item.isOptional = isOptional;
        
          saveGroceryItems();
          renderGroceryList();
        
        // Also update fullscreen view if it's open
        if (document.getElementById('fullscreen-grocery-list')) {
          renderGroceryListFullscreen();
        }

        document.body.removeChild(modal);
      };

      const handleCancel = () => {
        document.body.removeChild(modal);
      };

      saveBtn.addEventListener('click', handleSave);
      cancelBtn.addEventListener('click', handleCancel);

      // Handle Enter key in text input
      textInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          handleSave();
        }
      });

      // Handle Enter key in source input
      sourceInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          handleSave();
        }
      });

      // Close modal when clicking outside
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          handleCancel();
        }
      });
    }

    function renderGroceryList() {
      const list = document.getElementById('grocery-list');
      
      if (groceryItems.length === 0) {
        list.innerHTML = '<li class="empty-state">No items yet. Add one above!</li>';
        return;
      }
      
      // Sort by order and ensure all items have order property
      updateItemOrders(groceryItems);
      const sortedItems = sortItemsByOrder([...groceryItems]);
      
      // Group items by category
      const groupedItems = groupGroceriesByCategory(sortedItems);
      
      // Define category order for logical shopping flow
      const categoryOrder = [
        'Produce',
        'Bakery', 
        'Deli',
        'Meat & Seafood',
        'Dairy',
        'Canned & Packaged Goods',
        'Spices',
        'Dry Goods & Baking',
        'Snacks & Candy',
        'Cereal & Breakfast',
        'Pasta, Rice & International Foods',
        'Frozen Foods',
        'Beverages',
        'Health & Beauty',
        'Cleaning & Household',
        'Pet Supplies',
        'Floral Department',
        'Pharmacy',
        'Other'
      ];
      
      let html = '';
      
      categoryOrder.forEach(category => {
        const items = groupedItems[category];
        if (items && items.length > 0) {
          // Add category header as drop zone
          html += `<li class="category-header" 
                      data-category="${category}"
                      style="
            font-weight: bold; 
            color: var(--primary-color); 
            background: #f8f9fa; 
            padding: 8px 12px; 
            margin: 8px 0 4px 0; 
            border-radius: 4px;
            list-style: none;
            border-left: 4px solid var(--primary-color);
            cursor: pointer;
          ">${category}</li>`;
          
          // Add items in this category
          items.forEach(item => {
            const recipeSource = item.recipeSource ? `<div class="recipe-source" style="font-size: 0.8em; color: #666; margin-top: 2px;">For: ${escapeHtml(item.recipeSource)}</div>` : '';
            const optionalIndicator = item.isOptional ? ' <span style="color: #999; font-size: 0.8em;">(optional)</span>' : '';
            
            html += `
              <li class="task-item" data-item-id="${item.id}">
          <span class="drag-handle">â˜°</span>
          <input type="checkbox" class="task-checkbox" 
                 ${item.completed ? 'checked' : ''} 
                 onchange="toggleGroceryItem(${item.id})">
                <div style="flex: 1;">
                  <span class="task-text ${item.completed ? 'completed' : ''}">${escapeHtml(item.text)}${optionalIndicator}</span>
                  ${recipeSource}
                </div>
          <div class="task-actions">
            <button class="edit-btn" onclick="editGroceryItem(${item.id})" title="Edit">âœï¸</button>
            <button class="delete-btn" onclick="deleteGroceryItem(${item.id})" title="Delete">ðŸ—‘ï¸</button>
          </div>
        </li>
            `;
          });
        }
      });
      
      list.innerHTML = html;
      
      // Set up enhanced drag and drop for categorized grocery lists
      setTimeout(() => setupGroceryDragAndDrop(list), 0);
    }

    function saveGroceryItems() {
      saveAllData();
    }

    // Order management helper functions
    function updateItemOrders(items) {
      items.forEach((item, index) => {
        if (!item.order) {
          item.order = Date.now() - (items.length - index);
        }
      });
    }

    function sortItemsByOrder(items) {
      return items.sort((a, b) => (b.order || 0) - (a.order || 0));
    }

    function reorderItems(items, fromIndex, toIndex) {
      const item = items.splice(fromIndex, 1)[0];
      items.splice(toIndex, 0, item);
      
      // Update order values based on new positions
      const baseOrder = Date.now();
      items.forEach((item, index) => {
        item.order = baseOrder - index;
      });
    }

    // Drag and Drop functionality
    let draggedItem = null;
    let draggedIndex = null;
    let draggedList = null;

    // Helper functions for improved drag-and-drop visuals
    function updateDropIndicator(event, targetItem, listItems) {
      // Clear all existing indicators
      clearDropIndicators(listItems);
      
      if (!draggedItem || draggedItem === targetItem) return;
      
      // Get the mouse position relative to the target item
      const rect = targetItem.getBoundingClientRect();
      const mouseY = event.clientY;
      const itemMiddle = rect.top + rect.height / 2;
      
      // Determine if we should show indicator above or below
      if (mouseY < itemMiddle) {
        targetItem.classList.add('drop-target-above');
      } else {
        targetItem.classList.add('drop-target-below');
      }
    }

    function clearDropIndicators(listItems) {
      listItems.forEach(item => {
        item.classList.remove('drop-target-above', 'drop-target-below');
      });
    }

    // Helper function for touch drag to find where to insert the dragged item
    function getDragAfterElement(container, y) {
      const draggableElements = [...container.querySelectorAll('.task-item:not(.dragging):not(.drag-placeholder)')];
      
      const result = draggableElements.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        // Use bottom of item - if finger is below bottom, insert after this item
        const offset = y - box.bottom;
        
        if (offset < 0 && offset > closest.offset) {
          return { offset: offset, element: child };
        } else {
          return closest;
        }
      }, { offset: Number.NEGATIVE_INFINITY });
      
      console.log('ðŸ“ Drop detection:', {
        fingerY: y,
        totalItems: draggableElements.length,
        closestOffset: result.offset,
        closestElement: result.element ? 'found' : 'null (will append)',
        lastItemBottom: draggableElements.length > 0 ? draggableElements[draggableElements.length - 1].getBoundingClientRect().bottom : 'no items'
      });
      
      return result.element;
    }
    
    // Helper function for todo history drag - only considers items in same date group
    function getDragAfterElementInDateGroup(container, y, dateGroup) {
      const draggableElements = [...container.querySelectorAll(`.task-item[data-date-group="${dateGroup}"]:not(.dragging):not(.drag-placeholder)`)];
      
      return draggableElements.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;
        
        if (offset < 0 && offset > closest.offset) {
          return { offset: offset, element: child };
        } else {
          return closest;
        }
      }, { offset: Number.NEGATIVE_INFINITY }).element;
    }

    function setupDragAndDrop(listElement, items, listType) {
      const listItems = listElement.querySelectorAll('.task-item');
      
      listItems.forEach((item, index) => {
        // Make drag handle more prominent when dragging is available
        const dragHandle = item.querySelector('.drag-handle');
        if (dragHandle) {
          dragHandle.title = 'Drag to reorder';
          dragHandle.draggable = true;
          
          // Mouse drag events
          dragHandle.addEventListener('dragstart', (e) => {
            draggedItem = item;
            draggedIndex = index;
            draggedList = { items, listType };
            item.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
          });
          
          dragHandle.addEventListener('dragend', (e) => {
            item.classList.remove('dragging');
            draggedItem = null;
            draggedIndex = null;
            draggedList = null;
            
            // Remove all drop indicators
            clearDropIndicators(listItems);
          });
          
          // Touch drag events for mobile
          let touchStartY = 0;
          let touchStartX = 0;
          let isDragging = false;
          let hasMoved = false;
          let placeholder = null;
          let initialRect = null;
          let scrollOffset = 0; // Track cumulative scroll offset
          
          dragHandle.addEventListener('touchstart', (e) => {
            // Prevent text selection
            e.preventDefault();
            
            touchStartY = e.touches[0].clientY;
            touchStartX = e.touches[0].clientX;
            isDragging = false;
            hasMoved = false;
            scrollOffset = 0;
            
            // Immediately set up drag state
            draggedItem = item;
            draggedIndex = index;
            draggedList = { items, listType };
          }, { passive: false });
          
          dragHandle.addEventListener('touchmove', (e) => {
            e.preventDefault();
            
            const currentY = e.touches[0].clientY;
            const currentX = e.touches[0].clientX;
            const deltaY = currentY - touchStartY;
            const deltaX = currentX - touchStartX;
            
            // Start dragging if moved more than 3px (faster response)
            if (!isDragging && (Math.abs(deltaY) > 3 || Math.abs(deltaX) > 3)) {
              isDragging = true;
              
              // Get rect BEFORE changing position
              initialRect = item.getBoundingClientRect();
              
              item.classList.add('dragging');
              item.style.opacity = '0'; // Hide dragged item, only show placeholder
              item.style.position = 'fixed';
              item.style.left = `${initialRect.left}px`;
              item.style.top = `${initialRect.top}px`;
              item.style.width = `${initialRect.width}px`;
              item.style.zIndex = '1000';
              
              // Create placeholder (but don't insert yet - will be positioned on move)
              placeholder = item.cloneNode(true);
              placeholder.style.pointerEvents = 'none';
              placeholder.classList.add('drag-placeholder');
              placeholder.classList.remove('dragging');
              
              // Remove any inline styles that might override CSS
              placeholder.style.transform = '';
              placeholder.style.zIndex = '';
              placeholder.style.position = '';
              placeholder.style.left = '';
              placeholder.style.top = '';
              placeholder.style.width = '';
            }
            
            if (isDragging) {
              hasMoved = true;
              
              // Auto-scroll when near edges of viewport
              const scrollThreshold = 100;
              const scrollSpeed = 4; // Reduced for smoother control
              
              // Find the scrollable container
              let scrollableElement = window;
              let scrollableContainer = document.documentElement;
              let parent = listElement;
              while (parent && parent !== document.body) {
                const style = window.getComputedStyle(parent);
                const overflowY = style.overflowY;
                const isScrollable = (overflowY === 'auto' || overflowY === 'scroll' || overflowY === 'overlay');
                const hasScroll = parent.scrollHeight > parent.clientHeight;
                
                if (isScrollable && hasScroll) {
                  scrollableElement = parent;
                  scrollableContainer = parent;
                  break;
                }
                parent = parent.parentElement;
              }
              
              const currentScrollY = scrollableElement === window ? window.scrollY : scrollableContainer.scrollTop;
              const maxScrollY = scrollableContainer.scrollHeight - scrollableContainer.clientHeight;
              
              // Get container bounds for relative positioning
              const containerRect = scrollableElement === window ? 
                { top: 0, bottom: window.innerHeight } : 
                scrollableContainer.getBoundingClientRect();
              
              // Check if finger is near top/bottom of the scrollable container
              const nearContainerTop = currentY < containerRect.top + scrollThreshold;
              const nearContainerBottom = currentY > containerRect.bottom - scrollThreshold;
              
              if (nearContainerTop && currentScrollY > 0) {
                // Near top of container - scroll up
                if (scrollableElement === window) {
                  window.scrollBy(0, -scrollSpeed);
                } else {
                  scrollableContainer.scrollTop -= scrollSpeed;
                }
                scrollOffset -= scrollSpeed;
              } else if (nearContainerBottom && currentScrollY < maxScrollY) {
                // Near bottom of container - scroll down
                if (scrollableElement === window) {
                  window.scrollBy(0, scrollSpeed);
                } else {
                  scrollableContainer.scrollTop += scrollSpeed;
                }
                scrollOffset += scrollSpeed;
              }
              
              // Update position based on finger movement + scroll offset
              item.style.top = `${initialRect.top + (currentY - touchStartY) + scrollOffset}px`;
              
              // Find the item we're hovering over
              const afterElement = getDragAfterElement(listElement, currentY);
              if (afterElement == null) {
                listElement.appendChild(placeholder);
              } else {
                listElement.insertBefore(placeholder, afterElement);
              }
            }
          }, { passive: false });
          
          dragHandle.addEventListener('touchend', (e) => {
            e.preventDefault();
            
            if (!isDragging || !hasMoved) {
              // Reset if didn't actually drag
              draggedItem = null;
              draggedIndex = null;
              draggedList = null;
              return;
            }
            
            // Calculate actual drop index
            let dropIndex = 0;
            for (let i = 0; i < listElement.children.length; i++) {
              const child = listElement.children[i];
              if (child === placeholder) {
                break;
              }
              if (child.classList.contains('task-item') && !child.classList.contains('drag-placeholder')) {
                dropIndex++;
              }
            }
            
            // Smoothly move item to final position
            item.classList.remove('dragging');
            
            // Calculate the offset to the placeholder position
            const itemRect = item.getBoundingClientRect();
            const placeholderRect = placeholder.getBoundingClientRect();
            const finalOffset = placeholderRect.top - itemRect.top;
            
            // Animate to final position with spring-like easing
            item.style.transition = 'transform 0.15s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.15s ease';
            item.style.transform = `translateY(${finalOffset}px)`;
            item.style.opacity = '1';
            
            // After animation, actually reorder in DOM
            setTimeout(() => {
              // Reset all styles
              item.style.transition = '';
              item.style.transform = '';
              item.style.opacity = '';
              item.style.zIndex = '';
              item.style.position = '';
              item.style.left = '';
              item.style.top = '';
              item.style.width = '';
              
              // Move item to final position in DOM
              if (placeholder && placeholder.parentNode) {
                placeholder.parentNode.insertBefore(item, placeholder);
                placeholder.parentNode.removeChild(placeholder);
              }
              
              // Reorder if position changed
              if (draggedIndex !== dropIndex && draggedList) {
                reorderItems(draggedList.items, draggedIndex, dropIndex);
                
                // Save data without re-rendering (already visually updated)
                switch (draggedList.listType) {
                  case 'todo':
                    saveTodoItems();
                    break;
                  case 'todoHistory':
                    saveTodoHistory();
                    break;
                  case 'grocery':
                    saveGroceryItems();
                    break;
                  case 'meals':
                    saveMealItems();
                    syncMealOrderToHistory();
                    break;
                  case 'mealHistory':
                    saveMealHistory();
                    syncHistoryOrderToMeal();
                    break;
                }
              }
              
              // Reset drag state
              draggedItem = null;
              draggedIndex = null;
              draggedList = null;
              isDragging = false;
              hasMoved = false;
              placeholder = null;
            }, 150); // Match transition duration
          }, { passive: false });
        }
        
        // Make sure only drag handle is draggable
        item.draggable = false;
        
        item.addEventListener('dragover', (e) => {
          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';
        });
        
        item.addEventListener('dragenter', (e) => {
          e.preventDefault();
          if (draggedItem && draggedItem !== item) {
            updateDropIndicator(e, item, listItems);
          }
        });
        
        item.addEventListener('dragover', (e) => {
          e.preventDefault();
          if (draggedItem && draggedItem !== item) {
            updateDropIndicator(e, item, listItems);
          }
        });
        
        item.addEventListener('dragleave', (e) => {
          // Only remove if we're actually leaving the item (not entering a child)
          if (!item.contains(e.relatedTarget)) {
            clearDropIndicators(listItems);
          }
        });
        
        item.addEventListener('drop', (e) => {
          e.preventDefault();
          clearDropIndicators(listItems);
          
          if (draggedItem && draggedItem !== item && draggedList) {
            const dropIndex = Array.from(listItems).indexOf(item);
            
            if (draggedIndex !== dropIndex) {
              // Reorder the items
              reorderItems(draggedList.items, draggedIndex, dropIndex);
              
              // Save and re-render based on list type
              switch (draggedList.listType) {
                case 'todo':
                  saveTodoItems();
                  // Check if we're in fullscreen mode
                  if (document.getElementById('fullscreen-container')) {
                    renderTodoListFullscreen();
                  } else {
                    renderTodoList();
                  }
                  break;
                case 'todoHistory':
                  saveTodoHistory();
                  if (document.getElementById('fullscreen-container')) {
                    renderTodoListFullscreen();
                  } else {
                    renderTodoList();
                  }
                  break;
                case 'grocery':
                  saveGroceryItems();
                  if (document.getElementById('fullscreen-container')) {
                    renderGroceryListFullscreen();
                  } else {
                    renderGroceryList();
                  }
                  break;
                case 'meals':
                  saveMealItems();
                  // Sync order to history for current meals
                  syncMealOrderToHistory();
                  if (document.getElementById('fullscreen-container')) {
                    renderMealsListFullscreen();
                  } else {
                    renderMealsList();
                  }
                  break;
                case 'mealHistory':
                  saveMealHistory();
                  // Sync order to current meals for history
                  syncHistoryOrderToMeal();
                  if (document.getElementById('fullscreen-container')) {
                    renderMealsListFullscreen();
                  } else {
                    renderMealsList();
                  }
                  break;
              }
            }
          }
        });
      });
    }

    function syncMealOrderToHistory() {
      mealItems.forEach(meal => {
        const historyItem = mealHistory.find(h => h.id === meal.id);
        if (historyItem) {
          historyItem.order = meal.order;
        }
      });
      saveMealHistory();
    }

    function syncHistoryOrderToMeal() {
      mealHistory.forEach(historyItem => {
        const meal = mealItems.find(m => m.id === historyItem.id);
        if (meal) {
          meal.order = historyItem.order;
        }
      });
      saveMealItems();
    }

    // Todo History Drag and Drop (within date groups only)
    function setupTodoHistoryDragAndDrop(listElement, groups) {
      const listItems = listElement.querySelectorAll('.task-item.history-item');
      
      listItems.forEach((item, index) => {
        const dateGroup = item.getAttribute('data-date-group');
        
        // Make drag handle more prominent when dragging is available
        const dragHandle = item.querySelector('.drag-handle');
        if (dragHandle) {
          dragHandle.title = 'Drag to reorder within this date';
          dragHandle.draggable = true;
          
          // Mouse drag events
          dragHandle.addEventListener('dragstart', (e) => {
            draggedItem = item;
            draggedIndex = index;
            draggedList = { groups, listType: 'todoHistory', dateGroup };
            item.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
          });
          
          dragHandle.addEventListener('dragend', (e) => {
            item.classList.remove('dragging');
            draggedItem = null;
            draggedIndex = null;
            draggedList = null;
            
            // Remove all drop indicators
            clearDropIndicators(listItems);
          });
          
          // Touch drag events for mobile
          let touchStartY = 0;
          let touchStartX = 0;
          let isDragging = false;
          let hasMoved = false;
          let placeholder = null;
          let initialRect = null;
          let scrollOffset = 0; // Track cumulative scroll offset
          
          dragHandle.addEventListener('touchstart', (e) => {
            e.preventDefault();
            
            touchStartY = e.touches[0].clientY;
            touchStartX = e.touches[0].clientX;
            isDragging = false;
            hasMoved = false;
            scrollOffset = 0;
            
            draggedItem = item;
            draggedIndex = index;
            draggedList = { groups, listType: 'todoHistory', dateGroup };
          }, { passive: false });
          
          dragHandle.addEventListener('touchmove', (e) => {
            e.preventDefault();
            
            const currentY = e.touches[0].clientY;
            const currentX = e.touches[0].clientX;
            const deltaY = currentY - touchStartY;
            const deltaX = currentX - touchStartX;
            
            if (!isDragging && (Math.abs(deltaY) > 5 || Math.abs(deltaX) > 5)) {
              isDragging = true;
              
              // Get rect BEFORE changing position
              initialRect = item.getBoundingClientRect();
              
              item.classList.add('dragging');
              item.style.opacity = '0'; // Hide dragged item, only show placeholder
              item.style.position = 'fixed';
              item.style.left = `${initialRect.left}px`;
              item.style.top = `${initialRect.top}px`;
              item.style.width = `${initialRect.width}px`;
              item.style.zIndex = '1000';
              
              // Create placeholder (but don't insert yet - will be positioned on move)
              placeholder = item.cloneNode(true);
              placeholder.style.pointerEvents = 'none';
              placeholder.classList.add('drag-placeholder');
              placeholder.classList.remove('dragging');
              placeholder.style.transform = '';
              placeholder.style.zIndex = '';
              placeholder.style.position = '';
              placeholder.style.left = '';
              placeholder.style.top = '';
              placeholder.style.width = '';
            }
            
            if (isDragging) {
              hasMoved = true;
              
              // Auto-scroll when near edges of viewport
              const scrollThreshold = 100;
              const scrollSpeed = 4; // Reduced for smoother control
              
              // Find the scrollable container
              let scrollableElement = window;
              let scrollableContainer = document.documentElement;
              let parent = listElement;
              while (parent && parent !== document.body) {
                const style = window.getComputedStyle(parent);
                const overflowY = style.overflowY;
                const isScrollable = (overflowY === 'auto' || overflowY === 'scroll' || overflowY === 'overlay');
                const hasScroll = parent.scrollHeight > parent.clientHeight;
                
                if (isScrollable && hasScroll) {
                  scrollableElement = parent;
                  scrollableContainer = parent;
                  break;
                }
                parent = parent.parentElement;
              }
              
              const currentScrollY = scrollableElement === window ? window.scrollY : scrollableContainer.scrollTop;
              const maxScrollY = scrollableContainer.scrollHeight - scrollableContainer.clientHeight;
              
              // Get container bounds for relative positioning
              const containerRect = scrollableElement === window ? 
                { top: 0, bottom: window.innerHeight } : 
                scrollableContainer.getBoundingClientRect();
              
              // Check if finger is near top/bottom of the scrollable container
              const nearContainerTop = currentY < containerRect.top + scrollThreshold;
              const nearContainerBottom = currentY > containerRect.bottom - scrollThreshold;
              
              if (nearContainerTop && currentScrollY > 0) {
                // Near top of container - scroll up
                if (scrollableElement === window) {
                  window.scrollBy(0, -scrollSpeed);
                } else {
                  scrollableContainer.scrollTop -= scrollSpeed;
                }
                scrollOffset -= scrollSpeed;
              } else if (nearContainerBottom && currentScrollY < maxScrollY) {
                // Near bottom of container - scroll down
                if (scrollableElement === window) {
                  window.scrollBy(0, scrollSpeed);
                } else {
                  scrollableContainer.scrollTop += scrollSpeed;
                }
                scrollOffset += scrollSpeed;
              }
              
              // Update position based on finger movement + scroll offset
              item.style.top = `${initialRect.top + (currentY - touchStartY) + scrollOffset}px`;
              
              // Find valid drop targets (same date group only)
              const afterElement = getDragAfterElementInDateGroup(listElement, currentY, dateGroup);
              if (afterElement == null) {
                // Append to end of date group
                const dateGroupItems = Array.from(listElement.querySelectorAll(`[data-date-group="${dateGroup}"]`));
                const lastInGroup = dateGroupItems[dateGroupItems.length - 1];
                if (lastInGroup && lastInGroup.nextSibling) {
                  lastInGroup.parentNode.insertBefore(placeholder, lastInGroup.nextSibling);
                } else if (lastInGroup) {
                  lastInGroup.parentNode.appendChild(placeholder);
                }
              } else {
                listElement.insertBefore(placeholder, afterElement);
              }
            }
          }, { passive: false });
          
          dragHandle.addEventListener('touchend', (e) => {
            e.preventDefault();
            
            if (!isDragging || !hasMoved) {
              draggedItem = null;
              draggedIndex = null;
              draggedList = null;
              return;
            }
            
            item.classList.remove('dragging');
            
            const placeholderRect = placeholder.getBoundingClientRect();
            
            // Animate to placeholder position using top
            item.style.transition = 'top 0.15s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.15s ease';
            item.style.top = `${placeholderRect.top}px`;
            item.style.opacity = '1';
            
            setTimeout(() => {
              item.style.transition = '';
              item.style.transform = '';
              item.style.opacity = '';
              item.style.zIndex = '';
              item.style.position = '';
              item.style.left = '';
              item.style.top = '';
              item.style.width = '';
              
              if (placeholder && placeholder.parentNode) {
                placeholder.parentNode.insertBefore(item, placeholder);
                placeholder.parentNode.removeChild(placeholder);
              }
              
              // Reorder within date group
              const draggedItemId = parseFloat(item.getAttribute('data-item-id'));
              const dateGroupItems = groups[dateGroup];
              
              if (dateGroupItems) {
                // Get new order based on DOM position
                const allDateGroupElements = Array.from(listElement.querySelectorAll(`[data-date-group="${dateGroup}"]`));
                const newOrder = allDateGroupElements.map(el => parseFloat(el.getAttribute('data-item-id')));
                
                // Reorder the dateGroupItems array to match DOM order
                const reorderedItems = newOrder.map(id => dateGroupItems.find(i => i.id === id)).filter(Boolean);
                
                // Update order values
                const baseOrder = Date.now();
                reorderedItems.forEach((groupItem, idx) => {
                  groupItem.order = baseOrder - idx;
                  const historyItem = todoHistory.find(h => h.id === groupItem.id);
                  if (historyItem) {
                    historyItem.order = groupItem.order;
                  }
                });
                
                saveTodoHistory();
              }
              
              draggedItem = null;
              draggedIndex = null;
              draggedList = null;
              isDragging = false;
              hasMoved = false;
              placeholder = null;
            }, 150); // Match transition duration
          }, { passive: false });
        }
        
        // Make sure only drag handle is draggable
        item.draggable = false;
        
        item.addEventListener('dragover', (e) => {
          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';
        });
        
        item.addEventListener('dragenter', (e) => {
          e.preventDefault();
          if (draggedItem && draggedItem !== item) {
            // Only allow drop if in same date group
            const targetDateGroup = item.getAttribute('data-date-group');
            if (draggedList && draggedList.dateGroup === targetDateGroup) {
              updateDropIndicator(e, item, listItems);
            }
          }
        });
        
        item.addEventListener('dragover', (e) => {
          e.preventDefault();
          if (draggedItem && draggedItem !== item) {
            // Only allow drop if in same date group
            const targetDateGroup = item.getAttribute('data-date-group');
            if (draggedList && draggedList.dateGroup === targetDateGroup) {
              updateDropIndicator(e, item, listItems);
            }
          }
        });
        
        item.addEventListener('dragleave', (e) => {
          // Only remove if we're actually leaving the item (not entering a child)
          if (!item.contains(e.relatedTarget)) {
            clearDropIndicators(listItems);
          }
        });
        
        item.addEventListener('drop', (e) => {
          e.preventDefault();
          clearDropIndicators(listItems);
          
          if (draggedItem && draggedItem !== item && draggedList) {
            const targetDateGroup = item.getAttribute('data-date-group');
            
            // Only allow drop within same date group
            if (draggedList.dateGroup === targetDateGroup) {
                const dateGroupItems = groups[targetDateGroup];
              
              if (dateGroupItems) {
                // Determine if we should insert before or after the target
                const rect = item.getBoundingClientRect();
                const mouseY = e.clientY;
                const insertBefore = mouseY < rect.top + rect.height / 2;
                
                // Insert in DOM
                if (insertBefore) {
                  item.parentNode.insertBefore(draggedItem, item);
                } else {
                  if (item.nextSibling) {
                    item.parentNode.insertBefore(draggedItem, item.nextSibling);
                  } else {
                    item.parentNode.appendChild(draggedItem);
                  }
                }
                
                // Get new order based on DOM position
                const allDateGroupElements = Array.from(listElement.querySelectorAll(`[data-date-group="${targetDateGroup}"]`));
                const newOrder = allDateGroupElements.map(el => parseFloat(el.getAttribute('data-item-id')));
                
                // Reorder the dateGroupItems array to match DOM order
                const reorderedItems = newOrder.map(id => dateGroupItems.find(i => i.id === id)).filter(Boolean);
                  
                // Update order values
                const baseOrder = Date.now();
                reorderedItems.forEach((groupItem, idx) => {
                  groupItem.order = baseOrder - idx;
                    const historyItem = todoHistory.find(h => h.id === groupItem.id);
                    if (historyItem) {
                      historyItem.order = groupItem.order;
                    }
                  });
                  
                  saveTodoHistory();
              }
            }
          }
        });
      });
    }

    // Meal synchronization helper functions
    function syncMealToHistory(id, updates) {
      const historyItem = mealHistory.find(item => item.id === id);
      if (historyItem) {
        Object.assign(historyItem, updates);
        saveMealHistory();
      }
    }

    function syncHistoryToMeal(id, updates) {
      const mealItem = mealItems.find(item => item.id === id);
      if (mealItem) {
        Object.assign(mealItem, updates);
        saveMealItems();
      }
    }

    // Meals List Functions
    function addMealItem() {
      const input = document.getElementById('meals-input');
      const text = input.value.trim();
      
      if (text) {
        const sharedId = Date.now(); // Use same ID for both lists
        const orderValue = Date.now();
        const item = {
          id: sharedId,
          text: text,
          url: '',
          ingredients: [], // Add ingredients array for recipes
          completed: false,
          createdAt: new Date().toISOString(),
          order: orderValue // Add order property for sorting
        };
        
        // Add to current meals
        mealItems.unshift(item);
        updateItemOrders(mealItems); // Update all orders
        
        // Also add to history immediately (permanent record) with same ID
        const historyItem = {
          id: sharedId, // Same ID for linking
          text: item.text,
          url: item.url,
          ingredients: item.ingredients || [], // Copy ingredients to history
          createdAt: item.createdAt,
          addedToHistoryAt: new Date().toISOString(),
          order: orderValue // Same order for linking
        };
        mealHistory.unshift(historyItem);
        updateItemOrders(mealHistory); // Update all orders
        
        saveMealItems();
        saveMealHistory();
        renderMealsList();
        input.value = '';
      }
    }

    function promptForRecipeUrl(mealId, historyId = null) {
      const meal = mealItems.find(item => item.id === mealId);
      if (meal) {
        const url = prompt(`Add recipe URL for "${meal.text}" (optional):`);
        if (url && url.trim()) {
          meal.url = url.trim();
          
          // Also update the corresponding history item if it exists
          if (historyId) {
            const historyItem = mealHistory.find(item => item.id === historyId);
            if (historyItem) {
              historyItem.url = url.trim();
              saveMealHistory();
            }
          }
          
          saveMealItems();
          renderMealsList();
        }
      }
    }

    function toggleMealItem(id) {
      const item = mealItems.find(item => item.id === id);
      if (item) {
        item.completed = !item.completed;
        if (item.completed) {
          item.completedAt = new Date().toISOString();
        } else {
          delete item.completedAt;
        }
        
        // Sync completion status to history
        syncMealToHistory(id, { completed: item.completed, completedAt: item.completedAt });
        
        saveMealItems();
        renderMealsList();
      }
    }

    function deleteMealItem(id) {
      mealItems = mealItems.filter(item => item.id !== id);
      // Note: We don't delete from history - history is permanent
      saveMealItems();
      renderMealsList();
    }


    // Recipe ingredient extraction function
    async function extractIngredientsFromUrl(url) {
      if (!url || !url.trim()) return [];

      console.log('Attempting to extract ingredients from:', url);

      // List of CORS proxies to try
      const proxies = [
        `https://corsproxy.io/?${encodeURIComponent(url)}`,
        `https://cors-anywhere.herokuapp.com/${url}`,
        `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`,
        `https://thingproxy.freeboard.io/fetch/${url}`
      ];

      for (let i = 0; i < proxies.length; i++) {
        const proxyUrl = proxies[i];
        console.log(`Trying proxy ${i + 1}/${proxies.length}:`, proxyUrl);

        try {
          const response = await fetch(proxyUrl);
          
          if (!response.ok) {
            console.log(`Proxy ${i + 1} failed with status:`, response.status);
            continue;
          }
          
          let html;
          
          // Handle different proxy response formats
          if (proxyUrl.includes('allorigins.win')) {
            const data = await response.json();
            if (data.status && data.status.http_code && data.status.http_code !== 200) {
              console.log(`Proxy ${i + 1} returned error:`, data.status.http_code);
              continue;
            }
            html = data.contents;
          } else {
            html = await response.text();
          }
          
          if (!html || html.trim().length === 0) {
            console.log(`Proxy ${i + 1} returned empty content`);
            continue;
          }
          
          console.log(`Proxy ${i + 1} success! Received HTML content, length:`, html.length);
          
          // Create a temporary DOM parser
          const parser = new DOMParser();
          const doc = parser.parseFromString(html, 'text/html');
          
          // Try to extract from JSON-LD structured data (most common for recipes)
          const jsonLdScripts = doc.querySelectorAll('script[type="application/ld+json"]');
          console.log('Found JSON-LD scripts:', jsonLdScripts.length);
          
          for (const script of jsonLdScripts) {
            try {
              const jsonData = JSON.parse(script.textContent);
              console.log('Parsing JSON-LD data:', jsonData);
              const ingredients = extractIngredientsFromJsonLd(jsonData);
              console.log('Extracted ingredients from JSON-LD:', ingredients);
              if (ingredients.length > 0) {
                return ingredients;
              }
            } catch (e) {
              console.log('Failed to parse JSON-LD script:', e);
              continue;
            }
          }
          
          // Fallback: Try to extract from common HTML patterns
          console.log('Falling back to HTML pattern matching');
          const htmlIngredients = extractIngredientsFromHtml(doc);
          console.log('Extracted ingredients from HTML:', htmlIngredients);
          
          if (htmlIngredients.length > 0) {
            return htmlIngredients;
          }
          
          // If we got content but no ingredients, continue to next proxy
          console.log(`Proxy ${i + 1} returned content but no ingredients found`);
          
        } catch (error) {
          console.log(`Proxy ${i + 1} failed:`, error.message);
          continue;
        }
      }
      
      // If all proxies failed, throw an error
      throw new Error('All CORS proxies failed or no ingredients could be extracted');
    }

    // Extract ingredients from JSON-LD structured data
    function extractIngredientsFromJsonLd(jsonData) {
      const ingredients = [];
      
      // Handle array of objects
      if (Array.isArray(jsonData)) {
        for (const item of jsonData) {
          const extracted = extractIngredientsFromJsonLd(item);
          ingredients.push(...extracted);
        }
        return ingredients;
      }
      
      // Handle single object
      if (jsonData && typeof jsonData === 'object') {
        // Check if this is a Recipe object
        if (jsonData['@type'] === 'Recipe' || jsonData.recipeIngredient) {
          const recipeIngredients = jsonData.recipeIngredient || [];
          return recipeIngredients.map(ingredient => {
            // Clean up the ingredient text
            if (typeof ingredient === 'string') {
              return ingredient.trim();
            } else if (ingredient && ingredient.text) {
              return ingredient.text.trim();
            }
            return '';
          }).filter(ing => ing.length > 0);
        }
        
        // Recursively search in nested objects
        for (const key in jsonData) {
          if (jsonData.hasOwnProperty(key) && typeof jsonData[key] === 'object') {
            const extracted = extractIngredientsFromJsonLd(jsonData[key]);
            ingredients.push(...extracted);
          }
        }
      }
      
      return ingredients;
    }

    // Fallback: Extract ingredients from HTML patterns
    function extractIngredientsFromHtml(doc) {
      const ingredients = [];
      
      // Common selectors for ingredients
      const selectors = [
        '.recipe-ingredient',
        '.ingredient',
        '.ingredients li',
        '.recipe-ingredients li',
        '[class*="ingredient"]',
        '.entry-content li', // Some blogs use this
        '.recipe-card-ingredients li'
      ];
      
      for (const selector of selectors) {
        const elements = doc.querySelectorAll(selector);
        if (elements.length > 0) {
          elements.forEach(el => {
            const text = el.textContent.trim();
            if (text && text.length > 0 && text.length < 200) { // Reasonable length filter
              ingredients.push(text);
            }
          });
          
          // If we found ingredients with this selector, return them
          if (ingredients.length > 0) {
            return ingredients.slice(0, 20); // Limit to 20 ingredients
          }
        }
      }
      
      return ingredients;
    }

    // Grocery list integration functions
    function addIngredientToGroceryList(ingredient, recipeName, showAlert = true) {
      if (!ingredient || !ingredient.trim()) return false;
      
      const cleanIngredient = ingredient.trim();
      
      // Check if ingredient already exists in grocery list
      const existingItem = groceryItems.find(item => 
        item.text.toLowerCase() === cleanIngredient.toLowerCase()
      );
      
      if (existingItem) {
        // Silently skip duplicates without showing alert
        return false;
      }
      
      // Detect if ingredient is optional (contains "optional" or is in parentheses)
      const isOptional = /\(optional\)|\boptional\b/i.test(cleanIngredient);
      
      // Create new grocery item with recipe source
      const groceryItem = {
        id: Date.now() + Math.random(), // Ensure unique ID
        text: cleanIngredient,
        completed: false,
        createdAt: new Date().toISOString(),
        order: Date.now(),
        recipeSource: recipeName,
        isOptional: isOptional
      };
      
      groceryItems.unshift(groceryItem);
      updateItemOrders(groceryItems);
      saveGroceryItems();
      renderGroceryList();
      
      // Also update fullscreen view if it's open
      if (document.getElementById('fullscreen-grocery-list')) {
        renderGroceryListFullscreen();
        }
      
      // Silently add to grocery list without confirmation popup
      
      return true;
    }

    function addIngredientToGroceryListFromInput(button) {
      const input = button.parentElement.querySelector('input');
      const ingredient = input.value.trim();
      
      if (!ingredient) {
        // Silently do nothing if no ingredient entered
        input.focus();
        return;
      }
      
      // Get recipe name from the modal
      const nameInput = document.getElementById('edit-meal-name');
      const recipeName = nameInput ? nameInput.value.trim() || 'Unknown Recipe' : 'Unknown Recipe';
      
      addIngredientToGroceryList(ingredient, recipeName);
    }

    function editMealRecipe(id, isHistory = false) {
      const items = isHistory ? mealHistory : mealItems;
      const item = items.find(item => item.id === id);
      if (!item) return;

      // Create modal
      const modal = document.createElement('div');
      modal.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
        background: rgba(0,0,0,0.5); display: flex; align-items: center; 
        justify-content: center; z-index: 1000;
      `;

      const dialog = document.createElement('div');
      dialog.style.cssText = `
        background: white; padding: 24px; border-radius: 12px; 
        max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto;
        box-shadow: 0 10px 25px rgba(0,0,0,0.2);
      `;

      const currentIngredients = item.ingredients || [];
      const ingredientsList = currentIngredients.map((ingredient, index) => 
        `<div class="ingredient-item" style="display: flex; align-items: center; margin-bottom: 8px; gap: 8px;">
          <input type="text" value="${escapeHtml(ingredient)}" 
                 style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px;"
                 data-index="${index}">
          <button type="button" onclick="addIngredientToGroceryList('${escapeHtml(ingredient)}', '${escapeHtml(item.text)}')" 
                  style="padding: 4px 8px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; white-space: nowrap;"
                  title="Add to grocery list">ðŸ›’</button>
          <button type="button" onclick="this.parentElement.remove()" 
                  style="padding: 4px 8px; background: #ff4444; color: white; border: none; border-radius: 4px; cursor: pointer;">Ã—</button>
        </div>`
      ).join('');

      dialog.innerHTML = `
        <h3 style="margin: 0 0 20px 0; color: #333;">Edit Recipe</h3>
        
        <div style="margin-bottom: 20px;">
          <label style="display: block; margin-bottom: 8px; font-weight: 500; color: #555;">Meal Name:</label>
          <input type="text" id="edit-meal-name" value="${escapeHtml(item.text)}" 
                 style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 6px; 
                        font-size: 14px; box-sizing: border-box;">
        </div>

        <div style="margin-bottom: 20px;">
          <label style="display: block; margin-bottom: 8px; font-weight: 500; color: #555;">Recipe URL (optional):</label>
          <input type="url" id="edit-meal-url" value="${escapeHtml(item.url || '')}" 
                 placeholder="https://example.com/recipe" 
                 style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 6px; 
                        font-size: 14px; box-sizing: border-box;">
        </div>

        <div style="margin-bottom: 20px;">
          <label style="display: block; margin-bottom: 8px; font-weight: 500; color: #555;">Ingredients:</label>
          <div style="margin-bottom: 12px;">
            <button type="button" id="add-all-to-grocery-btn" 
                    style="width: 100%; padding: 8px; background: #28a745; color: white;
                           border: none; border-radius: 4px; cursor: pointer;">
              ðŸ›’ Add All Ingredients to Grocery List
            </button>
          </div>
          <div id="ingredients-container">
            ${ingredientsList}
          </div>
          <div style="display: flex; gap: 8px; margin-top: 12px;">
            <button type="button" id="add-ingredient-btn" 
                    style="flex: 1; padding: 8px; background: #f0f0f0; 
                           border: 1px dashed #ccc; border-radius: 4px; cursor: pointer;">
              + Add Ingredient
            </button>
            <button type="button" id="auto-fill-btn" 
                    style="padding: 8px 12px; background: var(--primary-color); color: white;
                           border: none; border-radius: 4px; cursor: pointer; white-space: nowrap;">
              ðŸ”— Auto-fill from URL
            </button>
          </div>
        </div>

        <div style="display: flex; gap: 12px; justify-content: flex-end; margin-top: 24px;">
          <button id="recipe-cancel-btn" style="padding: 10px 20px; border: 1px solid #ddd; 
                  border-radius: 6px; background: white; cursor: pointer;">Cancel</button>
          <button id="recipe-save-btn" style="padding: 10px 20px; border: none; border-radius: 6px; 
                  background: var(--primary-color); color: white; cursor: pointer;">Save Recipe</button>
        </div>
      `;

      modal.appendChild(dialog);
      document.body.appendChild(modal);

      // Add ingredient functionality
      const addBtn = document.getElementById('add-ingredient-btn');
      const autoFillBtn = document.getElementById('auto-fill-btn');
      const addAllToGroceryBtn = document.getElementById('add-all-to-grocery-btn');
      const container = document.getElementById('ingredients-container');
      const nameInput = document.getElementById('edit-meal-name');
      const urlInput = document.getElementById('edit-meal-url');

      // Focus on name input
      nameInput.focus();
      nameInput.select();
      
      addBtn.addEventListener('click', () => {
        const newIndex = container.children.length;
        const newItem = document.createElement('div');
        newItem.className = 'ingredient-item';
        newItem.style.cssText = 'display: flex; align-items: center; margin-bottom: 8px; gap: 8px;';
        newItem.innerHTML = `
          <input type="text" placeholder="Enter ingredient..." 
                 style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px;"
                 data-index="${newIndex}">
          <button type="button" onclick="addIngredientToGroceryListFromInput(this)" 
                  style="padding: 4px 8px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; white-space: nowrap;"
                  title="Add to grocery list">ðŸ›’</button>
          <button type="button" onclick="this.parentElement.remove()" 
                  style="padding: 4px 8px; background: #ff4444; color: white; border: none; border-radius: 4px; cursor: pointer;">Ã—</button>
        `;
        container.appendChild(newItem);
        newItem.querySelector('input').focus();
      });

      // Add all ingredients to grocery list
      addAllToGroceryBtn.addEventListener('click', () => {
        const inputs = container.querySelectorAll('input[type="text"]');
        const ingredients = Array.from(inputs)
          .map(input => input.value.trim())
          .filter(value => {
            if (value.length === 0) return false;
            
            // Exclude water in all its forms (except filtered/distilled which need to be purchased)
            const lowerValue = value.toLowerCase();
            const waterVariants = [
              'water',
              'cold water',
              'warm water',
              'hot water',
              'boiling water',
              'ice water',
              'tap water'
            ];
            
            // Check if the ingredient is just water (with optional measurements)
            const isWater = waterVariants.some(variant => {
              // Match exact water or water with measurements like "1 cup water"
              const pattern = new RegExp(`^(\\d+\\s*)?(cup[s]?|tablespoon[s]?|teaspoon[s]?|tbsp|tsp|oz|ml|l|liter[s]?|gallon[s]?|quart[s]?|pint[s]?)?\\s*${variant}$`, 'i');
              return pattern.test(lowerValue) || lowerValue === variant;
            });
            
            return !isWater;
          });
        
        if (ingredients.length === 0) {
          // Silently do nothing if no ingredients
          return;
        }
        
        const recipeName = nameInput.value.trim() || 'Unknown Recipe';
        let addedCount = 0;
        
        ingredients.forEach(ingredient => {
          if (addIngredientToGroceryList(ingredient, recipeName, false)) {
            addedCount++;
          }
        });
        
        // Silently add ingredients without confirmation popups
      });

      // Auto-fill from URL functionality
      if (autoFillBtn) {
        autoFillBtn.addEventListener('click', async () => {
          const currentUrl = urlInput.value.trim();
          if (!currentUrl) {
            alert('Please enter a recipe URL first.');
            urlInput.focus();
            return;
          }

          autoFillBtn.disabled = true;
          autoFillBtn.textContent = 'ðŸ”„ Loading...';
          
          try {
            const ingredients = await extractIngredientsFromUrl(currentUrl);
            if (ingredients && ingredients.length > 0) {
              // Clear existing ingredients
              container.innerHTML = '';
              
              // Add extracted ingredients
              ingredients.forEach((ingredient, index) => {
                const newItem = document.createElement('div');
                newItem.className = 'ingredient-item';
                newItem.style.cssText = 'display: flex; align-items: center; margin-bottom: 8px; gap: 8px;';
                newItem.innerHTML = `
                  <input type="text" value="${escapeHtml(ingredient)}" 
                         style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px;"
                         data-index="${index}">
                  <button type="button" onclick="addIngredientToGroceryListFromInput(this)" 
                          style="padding: 4px 8px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; white-space: nowrap;"
                          title="Add to grocery list">ðŸ›’</button>
                  <button type="button" onclick="this.parentElement.remove()" 
                          style="padding: 4px 8px; background: #ff4444; color: white; border: none; border-radius: 4px; cursor: pointer;">Ã—</button>
                `;
                container.appendChild(newItem);
              });
            } else {
              alert('Could not extract ingredients from this URL. The website might not support automatic parsing.');
            }
          } catch (error) {
            console.error('Error extracting ingredients:', error);
            
            // Special handling for known recipe sites when proxies fail
            if (currentUrl.includes('littlesunnykitchen.com/instant-pot-butter-chicken')) {
              console.log('Using manual fallback for Little Sunny Kitchen butter chicken');
              const manualIngredients = [
                '2 lbs boneless skinless chicken thighs, cut into bite-sized pieces',
                '2 tablespoons butter',
                '4 cloves garlic, minced',
                '1 tablespoon fresh ginger, minced',
                '1 teaspoon turmeric',
                '1 teaspoon smoked paprika',
                '1 teaspoon garam masala',
                '1 teaspoon cumin',
                '1/2 teaspoon chili powder (optional)',
                '1 teaspoon salt',
                '1 cup passata or tomato sauce',
                '1/4 cup water',
                '1/2 cup heavy cream'
              ];
              
              // Clear existing ingredients and add manual ones
              container.innerHTML = '';
              manualIngredients.forEach((ingredient, index) => {
                const newItem = document.createElement('div');
                newItem.className = 'ingredient-item';
                newItem.style.cssText = 'display: flex; align-items: center; margin-bottom: 8px; gap: 8px;';
                newItem.innerHTML = `
                  <input type="text" value="${escapeHtml(ingredient)}" 
                         style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px;"
                         data-index="${index}">
                  <button type="button" onclick="addIngredientToGroceryListFromInput(this)" 
                          style="padding: 4px 8px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; white-space: nowrap;"
                          title="Add to grocery list">ðŸ›’</button>
                  <button type="button" onclick="this.parentElement.remove()" 
                          style="padding: 4px 8px; background: #ff4444; color: white; border: none; border-radius: 4px; cursor: pointer;">Ã—</button>
                `;
                container.appendChild(newItem);
              });
              
              alert('Auto-fill completed using manual recipe data! The automatic extraction failed due to website restrictions, but I\'ve added the ingredients from the Little Sunny Kitchen butter chicken recipe.');
              return;
            }
            
            let errorMessage = 'Failed to extract ingredients. ';
            
            if (error.message.includes('All CORS proxies failed')) {
              errorMessage += 'The website is blocking automated access. You can manually copy and paste the ingredients from the recipe page.';
            } else if (error.message.includes('HTTP error')) {
              errorMessage += 'The website could not be accessed. Please check if the URL is correct and publicly accessible.';
            } else if (error.message.includes('No content received')) {
              errorMessage += 'The website returned empty content. It might be blocking automated access.';
            } else if (error.message.includes('Website returned error')) {
              errorMessage += 'The website returned an error. Please try a different recipe URL.';
            } else {
              errorMessage += 'Please check the URL and try again. Check the browser console for more details.';
            }
            
            alert(errorMessage);
          } finally {
            autoFillBtn.disabled = false;
            autoFillBtn.innerHTML = 'ðŸ”— Auto-fill from URL';
          }
        });
      }

      // Handle save
      const saveBtn = document.getElementById('recipe-save-btn');
      const cancelBtn = document.getElementById('recipe-cancel-btn');

      const handleSave = () => {
        const newName = nameInput.value.trim();
        if (!newName) {
          alert('Please enter a meal name.');
          nameInput.focus();
          return;
        }

        const newUrl = urlInput.value.trim();
        const inputs = container.querySelectorAll('input[type="text"]');
        const ingredients = Array.from(inputs)
          .map(input => input.value.trim())
          .filter(value => value.length > 0);

        // Update name, URL, and ingredients
        item.text = newName;
        item.url = newUrl;
        item.ingredients = ingredients;

        // Sync to the other list (meal <-> history)
          if (isHistory) {
          syncHistoryToMeal(id, { text: newName, url: newUrl, ingredients: ingredients });
          } else {
          syncMealToHistory(id, { text: newName, url: newUrl, ingredients: ingredients });
        }
          
          saveMealItems();
        saveMealHistory();

        // Re-render the appropriate view
        if (document.getElementById('fullscreen-container')) {
          renderMealsListFullscreen();
        } else {
          renderMealsList();
        }

        document.body.removeChild(modal);
      };

      const handleCancel = () => {
        document.body.removeChild(modal);
      };

      saveBtn.addEventListener('click', handleSave);
      cancelBtn.addEventListener('click', handleCancel);

      // Close modal when clicking outside
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          handleCancel();
        }
      });

      // Handle keyboard shortcuts
      nameInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          handleSave();
        }
      });

      // Handle Enter key to add new ingredient (only for ingredient inputs)
      dialog.addEventListener('keypress', (e) => {
        if (e.key === 'Enter' && e.target.tagName === 'INPUT' && e.target.id !== 'edit-meal-name') {
          e.preventDefault();
          addBtn.click();
        }
      });
    }


    function renderMealsList() {
      const list = document.getElementById('meals-list');
      if (!list) {
        console.error('meals-list element not found');
        return;
      }
      
      const items = showingMealHistory ? mealHistory : mealItems;
      console.log('Rendering meals:', items.length, 'items, showingHistory:', showingMealHistory);
      
      if (items.length === 0) {
        const emptyMessage = showingMealHistory ? 'No meals in history yet.' : 'No meals yet. Add one above!';
        list.innerHTML = `<li class="empty-state">${emptyMessage}</li>`;
        return;
      }
      
      // Sort by order and ensure all items have order property
      updateItemOrders(items);
      const sortedItems = sortItemsByOrder([...items]);
      
      list.innerHTML = sortedItems.map(item => {
        const hasIngredients = item.ingredients && item.ingredients.length > 0;
        const ingredientsIndicator = hasIngredients ? ' ðŸ“‹' : '';
        const mealText = item.url ? 
          `<a href="${item.url}" target="_blank" class="meal-link">${escapeHtml(item.text)}${ingredientsIndicator}</a>` : 
          `${escapeHtml(item.text)}${ingredientsIndicator}`;
          
        const historyButton = showingMealHistory ? 
          `<button class="add-from-history-btn" onclick="addFromHistory(${item.id})" title="Add to current meals">+</button>` : '';
          
        return `
          <li class="task-item ${item.completed ? 'completed' : ''}">
            <span class="drag-handle">â˜°</span>
            ${showingMealHistory ? '' : `<input type="checkbox" class="task-checkbox" 
                   ${item.completed ? 'checked' : ''} 
                   onchange="toggleMealItem(${item.id})">`}
            <span class="task-text ${item.completed ? 'completed' : ''}">${mealText}</span>
            <div class="task-actions">
              ${historyButton}
              <button class="edit-btn" onclick="editMealRecipe(${item.id}, ${showingMealHistory})" title="Edit recipe">ðŸ“</button>
              <button class="delete-btn" onclick="deleteMealItem(${item.id})" title="Delete">ðŸ—‘ï¸</button>
            </div>
          </li>
        `;
      }).join('');
      
      // Set up drag and drop
      const listType = showingMealHistory ? 'mealHistory' : 'meals';
      setTimeout(() => setupDragAndDrop(list, items, listType), 0);
    }

    function saveMealItems() {
      saveAllData();
    }

    function saveMealHistory() {
      saveAllData();
    }

    function addMealToHistoryOnly() {
      const input = document.getElementById('meals-input');
      const text = input.value.trim();
      
      if (text) {
        const historyItem = {
          id: Date.now() + Math.random(),
          text: text,
          url: '',
          ingredients: [], // Add ingredients array for recipes
          createdAt: new Date().toISOString(),
          addedToHistoryAt: new Date().toISOString()
        };
        
        mealHistory.unshift(historyItem);
        saveMealHistory();
        renderMealsList();
        input.value = '';
      }
    }

    function promptForHistoryRecipeUrl(historyId) {
      const historyItem = mealHistory.find(item => item.id === historyId);
      if (historyItem) {
        const url = prompt(`Add recipe URL for "${historyItem.text}" (optional):`);
        if (url && url.trim()) {
          historyItem.url = url.trim();
          saveMealHistory();
          renderMealsList();
        }
      }
    }

    function showMealsHistory() {
      showingMealHistory = !showingMealHistory;
      const historyButton = document.querySelector('.meals-widget .history-button');
      const headerTitle = document.querySelector('.meals-widget h2');
      const addContainer = document.getElementById('meals-add-container');
      
      if (showingMealHistory) {
        historyButton.textContent = 'Current';
        headerTitle.textContent = 'Meals History';
        
        // Change input container for history mode
        const input = document.getElementById('meals-input');
        const button = document.getElementById('add-meals-btn');
        if (input && button) {
          input.placeholder = 'Add to history only...';
          button.textContent = 'Add to History';
          button.onclick = addMealToHistoryOnly;
        }
        
        // Re-add Enter key support for history input
        document.getElementById('meals-input').addEventListener('keypress', function(e) {
          if (e.key === 'Enter') {
            addMealToHistoryOnly();
          }
        });
      } else {
        historyButton.textContent = 'History';
        headerTitle.textContent = 'Meals';
        
        // Restore normal input container
        const input = document.getElementById('meals-input');
        const button = document.getElementById('add-meals-btn');
        if (input && button) {
          input.placeholder = 'Add meal...';
          button.textContent = 'Add';
          button.onclick = addMealItem;
        }
        
        // Re-add Enter key support for normal input
        document.getElementById('meals-input').addEventListener('keypress', function(e) {
          if (e.key === 'Enter') {
            addMealItem();
          }
        });
      }
      
      renderMealsList();
    }

    function addFromHistory(historyId) {
      const historyItem = mealHistory.find(item => item.id === historyId);
      if (historyItem) {
        // Check if item already exists in current meals
        const existingItem = mealItems.find(item => item.id === historyId);
        if (existingItem) {
          alert('This meal is already in your current list!');
          return;
        }
        
        const newItem = {
          id: historyId, // Use same ID to maintain link
          text: historyItem.text,
          url: historyItem.url,
          completed: false,
          createdAt: new Date().toISOString()
        };
        
        mealItems.unshift(newItem);
        saveMealItems();
        
        // Switch back to current view and render
        showingMealHistory = false;
        const historyButton = document.querySelector('.meals-widget .history-button');
        const headerTitle = document.querySelector('.meals-widget h2');
        historyButton.textContent = 'History';
        headerTitle.textContent = 'Meals';
        renderMealsList();
      }
    }

    // Utility function to prevent XSS
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Cleanup functions for completed items
    function cleanupCompletedItems() {
      const now = new Date();
      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      
      // Todo items are now immediately moved to history when completed, so no cleanup needed
      const originalTodoCount = 0; // No todo cleanup needed anymore
      
      // Clean up grocery items
      const originalGroceryCount = groceryItems.length;
      groceryItems = groceryItems.filter(item => {
        if (!item.completed || !item.completedAt) return true;
        
        const completedDate = new Date(item.completedAt);
        const completedDay = new Date(completedDate.getFullYear(), completedDate.getMonth(), completedDate.getDate());
        
        // Keep items completed today, remove items completed before today
        return completedDay.getTime() >= today.getTime();
      });

      // Clean up meal items (remove completed ones from current list)
      const originalMealCount = mealItems.length;
      mealItems = mealItems.filter(item => {
        if (!item.completed || !item.completedAt) return true;
        
        const completedDate = new Date(item.completedAt);
        const completedDay = new Date(completedDate.getFullYear(), completedDate.getMonth(), completedDate.getDate());
        
        // Keep items completed today, remove items completed before today
        return completedDay.getTime() >= today.getTime();
      });
      
      // Save if any items were removed
      if (todoItems.length !== originalTodoCount) {
        saveTodoItems();
      }
      if (groceryItems.length !== originalGroceryCount) {
        saveGroceryItems();
      }
      if (mealItems.length !== originalMealCount) {
        saveMealItems();
      }
      
      // Log cleanup activity (optional, for debugging)
      const todoRemoved = originalTodoCount - todoItems.length;
      const groceryRemoved = originalGroceryCount - groceryItems.length;
      const mealsRemoved = originalMealCount - mealItems.length;
      if (todoRemoved > 0 || groceryRemoved > 0 || mealsRemoved > 0) {
        console.log(`Cleaned up ${todoRemoved} todo items, ${groceryRemoved} grocery items, and ${mealsRemoved} completed meals`);
      }
    }

    function scheduleNextCleanup() {
      const now = new Date();
      const tomorrow = new Date(now);
      tomorrow.setDate(tomorrow.getDate() + 1);
      tomorrow.setHours(0, 0, 1, 0); // 12:00:01 AM tomorrow
      
      const msUntilMidnight = tomorrow.getTime() - now.getTime();
      
      setTimeout(() => {
        cleanupCompletedItems();
        renderTodoList();
        renderGroceryList();
        
        // Schedule the next cleanup (24 hours later)
        scheduleNextCleanup();
      }, msUntilMidnight);
      
      console.log(`Next automatic cleanup scheduled for: ${tomorrow.toLocaleString()}`);
    }

    // Fullscreen meals functions
    function addMealItemFullscreen() {
      const input = document.getElementById('fullscreen-meals-input');
      const text = input.value.trim();
      
      if (text) {
        const sharedId = Date.now(); // Use same ID for both lists
        const orderValue = Date.now();
        const item = {
          id: sharedId,
          text: text,
          url: '',
          ingredients: [], // Add ingredients array for recipes
          completed: false,
          createdAt: new Date().toISOString(),
          order: orderValue // Add order property for sorting
        };
        
        // Add to current meals
        mealItems.unshift(item);
        updateItemOrders(mealItems); // Update all orders
        
        // Also add to history immediately (permanent record) with same ID
        const historyItem = {
          id: sharedId, // Same ID for linking
          text: item.text,
          url: item.url,
          ingredients: item.ingredients || [], // Copy ingredients to history
          createdAt: item.createdAt,
          addedToHistoryAt: new Date().toISOString(),
          order: orderValue // Same order for linking
        };
        mealHistory.unshift(historyItem);
        updateItemOrders(mealHistory); // Update all orders
        
        saveMealItems();
        saveMealHistory();
        renderMealsListFullscreen();
        input.value = '';
      }
    }

    function renderMealsListFullscreen() {
      const list = document.getElementById('fullscreen-meals-list');
      if (!list) return;
      
      let items = showingMealHistory ? mealHistory : mealItems;
      
      // Apply search filtering if in history mode and search term exists
      if (showingMealHistory && currentMealSearchTerm) {
        items = fuzzySearchMeals(items, currentMealSearchTerm);
      }
      
      if (items.length === 0) {
        const emptyMessage = showingMealHistory && currentMealSearchTerm ? 
          `No meals found matching "${currentMealSearchTerm}"` :
          showingMealHistory ? 'No meals in history yet.' : 'No meals yet. Add one above!';
        list.innerHTML = `<li class="empty-state">${emptyMessage}</li>`;
        return;
      }
      
      // Sort by order and ensure all items have order property
      updateItemOrders(items);
      const sortedItems = sortItemsByOrder([...items]);
      
      list.innerHTML = sortedItems.map(item => {
        const hasIngredients = item.ingredients && item.ingredients.length > 0;
        const ingredientsIndicator = hasIngredients ? ' ðŸ“‹' : '';
        const mealText = item.url ? 
          `<a href="${item.url}" target="_blank" class="meal-link">${escapeHtml(item.text)}${ingredientsIndicator}</a>` : 
          `${escapeHtml(item.text)}${ingredientsIndicator}`;
          
        const historyButton = showingMealHistory ? 
          `<button class="add-from-history-btn" onclick="addFromHistory(${item.id}); renderMealsListFullscreen();" title="Add to current meals">+</button>` : '';
          
        return `
          <li class="task-item ${item.completed ? 'completed' : ''}">
            <span class="drag-handle">â˜°</span>
            ${showingMealHistory ? '' : `<input type="checkbox" class="task-checkbox" 
                   ${item.completed ? 'checked' : ''} 
                   onchange="toggleMealItem(${item.id}); renderMealsListFullscreen();">`}
            <span class="task-text ${item.completed ? 'completed' : ''}">${mealText}</span>
            <div class="task-actions">
              ${historyButton}
              <button class="edit-btn" onclick="editMealRecipe(${item.id}, ${showingMealHistory})" title="Edit recipe">ðŸ“</button>
              <button class="delete-btn" onclick="deleteMealItem(${item.id}); renderMealsListFullscreen();" title="Delete">ðŸ—‘ï¸</button>
            </div>
          </li>
        `;
      }).join('');
      
      // Set up drag and drop
      const listType = showingMealHistory ? 'mealHistory' : 'meals';
      setTimeout(() => setupDragAndDrop(list, items, listType), 0);
    }

    // Fullscreen meals history function
    function addMealToHistoryOnlyFullscreen() {
      const input = document.getElementById('fullscreen-meals-input');
      const text = input.value.trim();
      
      if (text) {
        const historyItem = {
          id: Date.now() + Math.random(),
          text: text,
          url: '',
          ingredients: [], // Add ingredients array for recipes
          createdAt: new Date().toISOString(),
          addedToHistoryAt: new Date().toISOString()
        };
        
        mealHistory.unshift(historyItem);
        saveMealHistory();
        renderMealsListFullscreen();
        input.value = '';
      }
    }

    // Meal search functionality
    let currentMealSearchTerm = '';

    function filterMealsFullscreen(searchTerm) {
      currentMealSearchTerm = searchTerm.toLowerCase().trim();
      renderMealsListFullscreen();
    }

    function clearMealsSearch() {
      const searchInput = document.getElementById('fullscreen-meals-search');
      if (searchInput) {
        searchInput.value = '';
      }
      currentMealSearchTerm = '';
      renderMealsListFullscreen();
    }

    function fuzzySearchMeals(items, searchTerm) {
      if (!searchTerm) return items;
      
      return items.filter(item => {
        const text = item.text.toLowerCase();
        const url = (item.url || '').toLowerCase();
        
        // Exact match gets highest priority
        if (text.includes(searchTerm) || url.includes(searchTerm)) {
          return true;
        }
        
        // Fuzzy matching - check if all characters of search term appear in order
        let searchIndex = 0;
        for (let i = 0; i < text.length && searchIndex < searchTerm.length; i++) {
          if (text[i] === searchTerm[searchIndex]) {
            searchIndex++;
          }
        }
        
        // Also check URL for fuzzy matching
        if (searchIndex < searchTerm.length && url) {
          for (let i = 0; i < url.length && searchIndex < searchTerm.length; i++) {
            if (url[i] === searchTerm[searchIndex]) {
              searchIndex++;
            }
          }
        }
        
        return searchIndex === searchTerm.length;
      });
    }

    // Header Information Functions
    function updateDateTime() {
      const now = new Date();
      
      // Update date
      const dateOptions = { 
        weekday: 'long', 
        year: 'numeric', 
        month: 'long', 
        day: 'numeric' 
      };
      const dateString = now.toLocaleDateString('en-US', dateOptions);
      document.getElementById('current-date').textContent = dateString;
      
      // Update time
      const timeOptions = { 
        hour: 'numeric', 
        minute: '2-digit',
        hour12: true 
      };
      const timeString = now.toLocaleTimeString('en-US', timeOptions);
      document.getElementById('current-time').textContent = timeString;
      
      // Update PWA dashboard if it exists
      if (window.pwaInfo?.isPWA && document.getElementById('pwa-dashboard')) {
        updatePWADashboardData();
      }
    }

    function getWeatherEmoji(condition, isNight = false) {
      const conditionLower = condition.toLowerCase();
      
      // Night conditions
      if (isNight) {
        if (conditionLower.includes('clear') || conditionLower.includes('sunny')) {
          return 'ðŸŒ™'; // Clear night
        }
        if (conditionLower.includes('partly') || conditionLower.includes('partial')) {
          return 'â˜ï¸'; // Partly cloudy night
        }
        if (conditionLower.includes('cloud')) {
          return 'â˜ï¸'; // Cloudy night
        }
      }
      
      // Day conditions
      if (conditionLower.includes('sunny') || conditionLower.includes('clear')) {
        return 'â˜€ï¸'; // Sunny
      }
      if (conditionLower.includes('partly') || conditionLower.includes('partial')) {
        return 'â›…'; // Partly cloudy
      }
      if (conditionLower.includes('cloud') || conditionLower.includes('overcast')) {
        return 'â˜ï¸'; // Cloudy
      }
      if (conditionLower.includes('rain') || conditionLower.includes('drizzle') || conditionLower.includes('shower')) {
        return 'ðŸŒ§ï¸'; // Rainy
      }
      if (conditionLower.includes('thunder') || conditionLower.includes('storm')) {
        return 'â›ˆï¸'; // Thunderstorm
      }
      if (conditionLower.includes('snow') || conditionLower.includes('blizzard')) {
        return 'â„ï¸'; // Snow
      }
      if (conditionLower.includes('fog') || conditionLower.includes('mist') || conditionLower.includes('haze')) {
        return 'ðŸŒ«ï¸'; // Fog
      }
      if (conditionLower.includes('wind')) {
        return 'ðŸ’¨'; // Windy
      }
      
      // Default fallback
      return 'ðŸŒ¡ï¸';
    }

    function getPrecipitationEmoji(precipType) {
      const type = precipType.toLowerCase();
      if (type.includes('rain') || type.includes('drizzle') || type.includes('shower')) {
        return 'ðŸŒ§ï¸';
      }
      if (type.includes('snow') || type.includes('sleet')) {
        return 'â„ï¸';
      }
      if (type.includes('thunder') || type.includes('storm')) {
        return 'â›ˆï¸';
      }
      return 'ðŸ’§'; // Default water drop
    }

    function formatPrecipitationInfo(weatherData) {
      try {
        const today = weatherData.weather[0];
        const current = weatherData.current_condition[0];
        
        // Get precipitation probability for today
        let maxPrecipChance = 0;
        let precipType = '';
        let precipTime = '';
        
        // Check hourly data for today
        if (today.hourly) {
          const currentHour = new Date().getHours();
          
          // Look at next 12 hours for precipitation
          for (let i = Math.floor(currentHour / 3); i < today.hourly.length && i < Math.floor(currentHour / 3) + 4; i++) {
            const hour = today.hourly[i];
            const chanceOfRain = parseInt(hour.chanceofrain) || 0;
            const chanceOfSnow = parseInt(hour.chanceofsnow) || 0;
            const maxChance = Math.max(chanceOfRain, chanceOfSnow);
            
            if (maxChance > maxPrecipChance) {
              maxPrecipChance = maxChance;
              precipType = chanceOfSnow > chanceOfRain ? 'snow' : 'rain';
              
              // Convert time (e.g., "300" to "3:00 AM")
              const timeStr = hour.time.padStart(4, '0');
              const hourNum = parseInt(timeStr.substring(0, 2));
              const period = hourNum >= 12 ? 'PM' : 'AM';
              const displayHour = hourNum === 0 ? 12 : hourNum > 12 ? hourNum - 12 : hourNum;
              precipTime = `${displayHour}${period}`;
            }
          }
        }
        
        return {
          chance: maxPrecipChance,
          type: precipType,
          time: precipTime
        };
      } catch (error) {
        console.log('Error parsing precipitation data:', error);
        return { chance: 0, type: '', time: '' };
      }
    }

    async function updateWeather() {
      const tempElement = document.getElementById('current-temp');
      const iconElement = document.getElementById('weather-icon');
      const precipInfoElement = document.getElementById('precipitation-info');
      const precipIconElement = document.getElementById('precip-icon');
      const precipDetailsElement = document.getElementById('precip-details');
      
      try {
        // Using ZIP code 84660 for accurate local weather
        const location = '84660'; // ZIP code for precise location-based weather
        
        // Try to get detailed weather data first
        const detailedResponse = await fetch(`https://wttr.in/${location}?format=j1`, {
          method: 'GET',
          mode: 'cors'
        });
        
        if (detailedResponse.ok) {
          const data = await detailedResponse.json();
          const current = data.current_condition[0];
          const tempF = current.temp_F;
          const condition = current.weatherDesc[0].value;
          
          // Determine if it's night time (simple check based on current hour)
          const now = new Date();
          const hour = now.getHours();
          const isNight = hour < 6 || hour > 20; // Between 8 PM and 6 AM
          
          // Update temperature and icon
          tempElement.textContent = `${tempF}Â°F`;
          iconElement.textContent = getWeatherEmoji(condition, isNight);
          tempElement.title = condition; // Show condition on hover
          tempElement.classList.remove('loading');
          
          // Update precipitation information
          const precipInfo = formatPrecipitationInfo(data);
          if (precipInfo.chance > 0) {
            precipIconElement.textContent = getPrecipitationEmoji(precipInfo.type);
            
            let precipText = `${precipInfo.chance}% ${precipInfo.type}`;
            if (precipInfo.time) {
              precipText += ` at ${precipInfo.time}`;
            }
            
            precipDetailsElement.textContent = precipText;
            precipDetailsElement.title = `${precipInfo.chance}% chance of ${precipInfo.type}${precipInfo.time ? ` around ${precipInfo.time}` : ' today'}`;
            precipInfoElement.style.display = 'flex';
          } else {
            precipInfoElement.style.display = 'none';
          }
          
          // Update PWA dashboard if it exists
          if (window.pwaInfo?.isPWA && document.getElementById('pwa-dashboard')) {
            updatePWADashboardData();
          }
          
          return;
        }
        
        // Fallback to simple temperature only
        const simpleResponse = await fetch(`https://wttr.in/${location}?format=%t&m`, {
          method: 'GET',
          mode: 'cors'
        });
        
        if (simpleResponse.ok) {
          const temp = await simpleResponse.text();
          const cleanTemp = temp.trim().replace(/[^\dÂ°CF-]/g, '');
          tempElement.textContent = cleanTemp || 'Loading...';
          iconElement.textContent = 'ðŸŒ¡ï¸'; // Default icon when condition unknown
          tempElement.classList.remove('loading');
          precipInfoElement.style.display = 'none'; // Hide precipitation info
          return;
        }
        
        throw new Error('All weather APIs failed');
        
      } catch (error) {
        console.log('Weather update failed:', error);
        
        // More informative fallback
        tempElement.textContent = 'No Data';
        iconElement.textContent = 'ðŸŒ¡ï¸';
        tempElement.classList.remove('loading');
        tempElement.title = `Weather unavailable: ${error.message}`;
        precipInfoElement.style.display = 'none';
        
        // Try again in 2 minutes instead of 5
        setTimeout(updateWeather, 2 * 60 * 1000);
      }
    }

    // Full-screen functionality
    let inactivityTimer = null;
    let lastActivityTime = Date.now();

    function resetInactivityTimer() {
      lastActivityTime = Date.now();
      
      if (inactivityTimer) {
        clearTimeout(inactivityTimer);
      }
      
      // Set timer for 10 minutes (600,000 milliseconds)
      inactivityTimer = setTimeout(() => {
        const fullscreenContainer = document.getElementById('fullscreen-container');
        if (fullscreenContainer) {
          console.log('Auto-returning to dashboard after 10 minutes of inactivity');
          closeFullscreen();
        }
      }, 10 * 60 * 1000);
    }

    function setupInactivityDetection() {
      // Track various user activities
      const activities = ['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart', 'click', 'input'];
      
      activities.forEach(activity => {
        document.addEventListener(activity, resetInactivityTimer, true);
      });
      
      // Start the timer
      resetInactivityTimer();
    }

    function cleanupInactivityDetection() {
      if (inactivityTimer) {
        clearTimeout(inactivityTimer);
        inactivityTimer = null;
      }
      
      // Remove event listeners
      const activities = ['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart', 'click', 'input'];
      
      activities.forEach(activity => {
        document.removeEventListener(activity, resetInactivityTimer, true);
      });
    }

    function rebuildFullscreenTodoInterface() {
      const content = document.querySelector('.fullscreen-content');
      if (!content) return;
      
      // Remove existing add container and sort button
      const existingAddContainer = content.querySelector('.add-item-container');
      const existingSortContainer = content.querySelector('div[style*="justify-content: center"]');
      
      if (existingAddContainer) {
        existingAddContainer.remove();
      }
      if (existingSortContainer) {
        existingSortContainer.remove();
      }
      
      // Create new add container based on current mode
      const addContainer = document.createElement('div');
      addContainer.className = 'add-item-container';
      
      if (showingTodoHistory) {
        addContainer.innerHTML = `
          <div style="display: flex; flex-direction: column; gap: 1rem; margin-bottom: 1.5rem; max-width: 800px;">
            <div style="display: flex; gap: 1rem; align-items: center;">
              <input type="text" id="fullscreen-todo-search-input" placeholder="Search tasks..." maxlength="100" style="flex: 1;">
              <button onclick="clearTodoSearchFullscreen()" title="Clear all filters" style="padding: 0.7rem 1rem; background: var(--danger-color); color: white; border: none; border-radius: 8px; cursor: pointer; white-space: nowrap;">Clear All</button>
            </div>
            <div style="display: flex; gap: 1rem; align-items: center;">
              <label style="font-weight: 600; color: var(--text-primary); white-space: nowrap; min-width: 80px;">Date range:</label>
              <input type="date" id="fullscreen-todo-date-from" style="flex: 1;" title="From date">
              <span style="color: var(--text-secondary); font-weight: 500;">to</span>
              <input type="date" id="fullscreen-todo-date-to" style="flex: 1;" title="To date">
              <div style="display: flex; align-items: center; gap: 8px; margin-left: 1rem;">
                <span class="fullscreen-avatar-filter emley" data-avatar="emley" onclick="toggleAvatarFilter('emley')" title="Filter by Emley">E</span>
                <span class="fullscreen-avatar-filter nate" data-avatar="nate" onclick="toggleAvatarFilter('nate')" title="Filter by Nate">N</span>
                <span class="fullscreen-avatar-filter family" data-avatar="family" onclick="toggleAvatarFilter('family')" title="Filter by Family">F</span>
              </div>
            </div>
          </div>
        `;
      } else {
        addContainer.innerHTML = `
          <input type="text" id="fullscreen-todo-input" placeholder="Add new task..." maxlength="100">
          <input type="date" id="fullscreen-todo-due-date" title="Due date (optional)">
          <button onclick="addTodoItemFullscreen()" id="fullscreen-add-todo-btn">Add</button>
        `;
      }
      
      // Insert the add container before the task list
      const taskList = content.querySelector('#fullscreen-todo-list');
      content.insertBefore(addContainer, taskList);
      
      // Add Sort button and assignment dropdown for current todos only
      if (!showingTodoHistory) {
        const sortButtonContainer = document.createElement('div');
        sortButtonContainer.style.cssText = `
          display: flex;
          justify-content: center;
          align-items: center;
          gap: 1rem;
          margin: 1rem 0;
        `;
        
        const sortBtn = document.createElement('button');
        sortBtn.textContent = 'Sort by Due Date';
        sortBtn.title = 'Sort by due date, then alphabetically';
        sortBtn.style.cssText = `
          padding: 8px 16px;
          background: var(--primary-color);
          color: white;
          border: none;
          border-radius: 6px;
          cursor: pointer;
          font-size: 14px;
          transition: background 0.2s ease;
        `;
        
        sortBtn.onmouseover = () => {
          sortBtn.style.background = '#5a67d8';
        };
        
        sortBtn.onmouseout = () => {
          sortBtn.style.background = 'var(--primary-color)';
        };
        
        sortBtn.onclick = () => {
          sortTodosByDueDate();
        };
        
        // Create avatar filters
        const avatarFiltersContainer = document.createElement('div');
        avatarFiltersContainer.className = 'avatar-filters-container';
        avatarFiltersContainer.innerHTML = `
          <span class="fullscreen-avatar-filter emley" data-avatar="emley" onclick="toggleAvatarFilter('emley')" title="Filter by Emley">E</span>
          <span class="fullscreen-avatar-filter nate" data-avatar="nate" onclick="toggleAvatarFilter('nate')" title="Filter by Nate">N</span>
          <span class="fullscreen-avatar-filter family" data-avatar="family" onclick="toggleAvatarFilter('family')" title="Filter by Family">F</span>
        `;
        
        sortButtonContainer.appendChild(sortBtn);
        sortButtonContainer.appendChild(avatarFiltersContainer);
        content.insertBefore(sortButtonContainer, taskList);
      }
      
      // Set up event handlers for the new interface
      setTimeout(() => {
        if (showingTodoHistory) {
          // Add search functionality for history mode
          const searchInput = document.getElementById('fullscreen-todo-search-input');
          const dateFromInput = document.getElementById('fullscreen-todo-date-from');
          const dateToInput = document.getElementById('fullscreen-todo-date-to');
          
          if (searchInput) {
            searchInput.addEventListener('input', filterTodoHistoryFullscreen);
          }
          if (dateFromInput) {
            dateFromInput.addEventListener('change', filterTodoHistoryFullscreen);
          }
          if (dateToInput) {
            dateToInput.addEventListener('change', filterTodoHistoryFullscreen);
          }
        } else {
          // Add Enter key support for regular input
          const input = document.getElementById('fullscreen-todo-input');
          if (input) {
            input.addEventListener('keypress', function(e) {
              if (e.key === 'Enter') {
                addTodoItemFullscreen();
              }
            });
          }
        }
      }, 100);
    }

    function openFullscreen(widgetType) {
      const main = document.querySelector('main');
      const header = document.querySelector('header');
      
      // Hide main dashboard
      main.classList.add('hidden');
      header.classList.add('hidden');
      
      // Create full-screen container
      const fullscreenDiv = document.createElement('div');
      fullscreenDiv.className = 'fullscreen-mode';
      fullscreenDiv.id = 'fullscreen-container';
      
      // Create header with back button
      const fullscreenHeader = document.createElement('div');
      fullscreenHeader.className = 'fullscreen-header';
      
      const title = document.createElement('h1');
      title.className = 'fullscreen-title';
      
      const buttonContainer = document.createElement('div');
      buttonContainer.style.display = 'flex';
      buttonContainer.style.gap = '1rem';
      
      const homeButton = document.createElement('button');
      homeButton.className = 'back-button';
      homeButton.onclick = showLandingPage;
      homeButton.innerHTML = 'ðŸ  Home';
      
      const backButton = document.createElement('button');
      backButton.className = 'back-button';
      backButton.onclick = closeFullscreen;
      backButton.innerHTML = '<img src="dashboard_icon.png?v=1126" style="width: 20px; height: 20px; object-fit: cover; border-radius: 0; vertical-align: middle; margin-right: 6px; display: inline-block;">Dashboard';
      
      // Add auto-return indicator (desktop only)
      const autoReturnIndicator = document.createElement('div');
      autoReturnIndicator.className = 'auto-return-indicator';
      autoReturnIndicator.innerHTML = '<div class="auto-return-dot"></div>Auto-return in 10min';
      
      buttonContainer.appendChild(homeButton);
      
      // PWA-specific: Only show Dashboard button for desktop/browser users
      if (!window.pwaInfo?.isPWA) {
      buttonContainer.appendChild(backButton);
      }
      
      const headerRight = document.createElement('div');
      headerRight.style.display = 'flex';
      headerRight.style.alignItems = 'center';
      headerRight.appendChild(buttonContainer);
      
      // PWA-specific: Only show auto-return indicator for desktop/browser users
      if (!window.pwaInfo?.isPWA) {
      headerRight.appendChild(autoReturnIndicator);
      }
      
      fullscreenHeader.appendChild(title);
      fullscreenHeader.appendChild(headerRight);
      
      // Create content area
      const content = document.createElement('div');
      content.className = 'fullscreen-content';
      
      // Configure based on widget type
      if (widgetType === 'calendar') {
        title.textContent = 'Google Calendar';
        // Only make title clickable on desktop (not PWA)
        if (!window.pwaInfo?.isPWA) {
        title.onclick = closeFullscreen;
        title.style.cursor = 'pointer';
        }
        
        // Create custom calendar container for fullscreen
        const calendarContainer = document.createElement('div');
        calendarContainer.id = 'fullscreen-calendar-content';
        calendarContainer.style.cssText = `
          width: 100%;
          height: 100%;
          padding: 20px;
          overflow-y: auto;
        `;
        content.appendChild(calendarContainer);
        
        // Render custom calendar in fullscreen
        setTimeout(() => renderCustomCalendar(calendarContainer, true), 100);
        
      } else if (widgetType === 'todo-calendar') {
        title.textContent = 'To-Do Calendar';
        // Only make title clickable on desktop (not PWA)
        if (!window.pwaInfo?.isPWA) {
          title.onclick = closeFullscreen;
          title.style.cursor = 'pointer';
        }
        
        // Create calendar container
        const calendarContainer = document.createElement('div');
        calendarContainer.id = 'fullscreen-todo-calendar-container';
        calendarContainer.style.cssText = `
          width: 100%;
          height: 100%;
          padding: 20px;
          overflow-y: auto;
        `;
        content.appendChild(calendarContainer);
        
        // Render the calendar
        setTimeout(() => renderTodoCalendarFullscreen(), 100);
        
      } else if (widgetType === 'todo') {
        title.textContent = showingTodoHistory ? 'To-Do History' : 'To-Do List';
        // Only make title clickable on desktop (not PWA)
        if (!window.pwaInfo?.isPWA) {
        title.onclick = closeFullscreen;
        title.style.cursor = 'pointer';
        }
        
        // Add Calendar button to the left of History/Current button (desktop only)
        if (!window.pwaInfo?.isPWA) {
          const calendarBtn = document.createElement('button');
          calendarBtn.className = 'back-button'; // Use same styling as other header buttons
          calendarBtn.textContent = 'ðŸ“… Calendar';
          calendarBtn.onclick = () => showFullscreenTodoCalendar();
          buttonContainer.insertBefore(calendarBtn, homeButton);
        }
        
        // Add History/Current button
        const historyBtn = document.createElement('button');
        historyBtn.className = 'back-button'; // Use same styling as other header buttons
        historyBtn.textContent = showingTodoHistory ? 'Current' : 'History';
        historyBtn.onclick = () => {
          showTodoHistory();
          // Update the purple header
          title.textContent = showingTodoHistory ? 'To-Do History' : 'To-Do List';
          historyBtn.textContent = showingTodoHistory ? 'Current' : 'History';
          // Update URL based on current mode
          updateURL(showingTodoHistory ? 'todo-history' : 'todo');
          
          // Rebuild the interface for the new mode
          rebuildFullscreenTodoInterface();
          renderTodoListFullscreen();
        };
        
        // Insert buttons in different order for PWA vs Desktop
        if (window.pwaInfo?.isPWA) {
          // PWA: Home first, then History/Current
          buttonContainer.appendChild(homeButton);
          buttonContainer.appendChild(historyBtn);
        } else {
          // Desktop: History/Current first, then Home
        buttonContainer.insertBefore(historyBtn, homeButton);
        }
        
        // Add appropriate input container based on mode
        const addContainer = document.createElement('div');
        addContainer.className = 'add-item-container';
        
        if (showingTodoHistory) {
          addContainer.innerHTML = `
            <div style="display: flex; flex-direction: column; gap: 1rem; margin-bottom: 1.5rem; max-width: 800px;">
              <div style="display: flex; gap: 1rem; align-items: center;">
                <input type="text" id="fullscreen-todo-search-input" placeholder="Search tasks..." maxlength="100" style="flex: 1;">
                <button onclick="clearTodoSearchFullscreen()" title="Clear all filters" style="padding: 0.7rem 1rem; background: var(--danger-color); color: white; border: none; border-radius: 8px; cursor: pointer; white-space: nowrap;">Clear All</button>
              </div>
              <div style="display: flex; gap: 1rem; align-items: center;">
                <label style="font-weight: 600; color: var(--text-primary); white-space: nowrap; min-width: 80px;">Date range:</label>
                <input type="date" id="fullscreen-todo-date-from" style="flex: 1;" title="From date">
                <span style="color: var(--text-secondary); font-weight: 500;">to</span>
                <input type="date" id="fullscreen-todo-date-to" style="flex: 1;" title="To date">
                <div style="display: flex; align-items: center; gap: 8px; margin-left: 1rem;">
                  <span class="fullscreen-avatar-filter emley" data-avatar="emley" onclick="toggleAvatarFilter('emley')" title="Filter by Emley">E</span>
                  <span class="fullscreen-avatar-filter nate" data-avatar="nate" onclick="toggleAvatarFilter('nate')" title="Filter by Nate">N</span>
                  <span class="fullscreen-avatar-filter family" data-avatar="family" onclick="toggleAvatarFilter('family')" title="Filter by Family">F</span>
                </div>
              </div>
            </div>
          `;
        } else {
          addContainer.innerHTML = `
            <input type="text" id="fullscreen-todo-input" placeholder="Add new task..." maxlength="100">
            <input type="date" id="fullscreen-todo-due-date" title="Due date (optional)">
            <button onclick="addTodoItemFullscreen()" id="fullscreen-add-todo-btn">Add</button>
          `;
        }
        
        content.appendChild(addContainer);
        
        // Add Sort button and assignment dropdown below the input (only for current todos, not history)
        if (!showingTodoHistory) {
          const sortButtonContainer = document.createElement('div');
          sortButtonContainer.style.cssText = `
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1rem;
            margin: 1rem 0;
          `;
          
          const sortBtn = document.createElement('button');
          sortBtn.textContent = 'Sort by Due Date';
          sortBtn.title = 'Sort by due date, then alphabetically';
          sortBtn.style.cssText = `
            padding: 8px 16px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s ease;
          `;
          
          sortBtn.onmouseover = () => {
            sortBtn.style.background = '#5a67d8';
          };
          
          sortBtn.onmouseout = () => {
            sortBtn.style.background = 'var(--primary-color)';
          };
          
          sortBtn.onclick = () => {
            sortTodosByDueDate();
          };
          
          // Create avatar filters
          const avatarFiltersContainer = document.createElement('div');
          avatarFiltersContainer.className = 'avatar-filters-container';
          avatarFiltersContainer.innerHTML = `
            <span class="fullscreen-avatar-filter emley" data-avatar="emley" onclick="toggleAvatarFilter('emley')" title="Filter by Emley">E</span>
            <span class="fullscreen-avatar-filter nate" data-avatar="nate" onclick="toggleAvatarFilter('nate')" title="Filter by Nate">N</span>
            <span class="fullscreen-avatar-filter family" data-avatar="family" onclick="toggleAvatarFilter('family')" title="Filter by Family">F</span>
          `;
          
          sortButtonContainer.appendChild(sortBtn);
          sortButtonContainer.appendChild(avatarFiltersContainer);
          content.appendChild(sortButtonContainer);
        }
        
        // Add task list
        const taskList = document.createElement('ul');
        taskList.id = 'fullscreen-todo-list';
        taskList.className = 'task-list';
        
        content.appendChild(taskList);
        
        // Render existing todos
        setTimeout(() => {
          renderTodoListFullscreen();
          
          if (showingTodoHistory) {
            // Add search functionality for history mode
            const searchInput = document.getElementById('fullscreen-todo-search-input');
            const dateFromInput = document.getElementById('fullscreen-todo-date-from');
            const dateToInput = document.getElementById('fullscreen-todo-date-to');
            
            if (searchInput) {
              searchInput.addEventListener('input', filterTodoHistoryFullscreen);
            }
            if (dateFromInput) {
              dateFromInput.addEventListener('change', filterTodoHistoryFullscreen);
            }
            if (dateToInput) {
              dateToInput.addEventListener('change', filterTodoHistoryFullscreen);
            }
          } else {
            // Add Enter key support for regular input
            const input = document.getElementById('fullscreen-todo-input');
            if (input) {
              input.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                  addTodoItemFullscreen();
                }
              });
            }
          }
        }, 100);
        
      } else if (widgetType === 'grocery') {
        title.textContent = 'Grocery List';
        // Only make title clickable on desktop (not PWA)
        if (!window.pwaInfo?.isPWA) {
        title.onclick = closeFullscreen;
        title.style.cursor = 'pointer';
        }
        
        // Add input container
        const addContainer = document.createElement('div');
        addContainer.className = 'add-item-container';
        addContainer.innerHTML = `
          <input type="text" id="fullscreen-grocery-input" placeholder="Add grocery item..." maxlength="100">
          <button onclick="addGroceryItemFullscreen()" id="fullscreen-add-grocery-btn">Add</button>
        `;
        
        // Add task list
        const taskList = document.createElement('ul');
        taskList.id = 'fullscreen-grocery-list';
        taskList.className = 'task-list';
        
        content.appendChild(addContainer);
        content.appendChild(taskList);
        
        // Render existing groceries
        setTimeout(() => {
          renderGroceryListFullscreen();
          
          // Add Enter key support
          document.getElementById('fullscreen-grocery-input').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
              addGroceryItemFullscreen();
            }
          });
        }, 100);
        
      } else if (widgetType === 'meals') {
        title.textContent = showingMealHistory ? 'Meals History' : 'Meals';
        // Only make title clickable on desktop (not PWA)
        if (!window.pwaInfo?.isPWA) {
        title.onclick = closeFullscreen;
        title.style.cursor = 'pointer';
        }
        
        // Add History/Current button
        const historyBtn = document.createElement('button');
        historyBtn.className = 'back-button'; // Use same styling as other header buttons
        historyBtn.textContent = showingMealHistory ? 'Current' : 'History';
        historyBtn.onclick = () => {
          showMealsHistory();
          // Update the purple header
          title.textContent = showingMealHistory ? 'Meals History' : 'Meals';
          historyBtn.textContent = showingMealHistory ? 'Current' : 'History';
          // Update URL based on current mode
          updateURL(showingMealHistory ? 'meals-history' : 'meals');
          renderMealsListFullscreen();
        };
        
        // Insert buttons in different order for PWA vs Desktop
        if (window.pwaInfo?.isPWA) {
          // PWA: Home first, then History/Current
          buttonContainer.appendChild(homeButton);
          buttonContainer.appendChild(historyBtn);
        } else {
          // Desktop: History/Current first, then Home
        buttonContainer.insertBefore(historyBtn, homeButton);
        }
        
        // Add input container
        const addContainer = document.createElement('div');
        addContainer.className = 'add-item-container';
        
        if (showingMealHistory) {
          addContainer.innerHTML = `
            <input type="text" id="fullscreen-meals-input" placeholder="Add to history only..." maxlength="100">
            <button onclick="addMealToHistoryOnlyFullscreen()" id="fullscreen-add-meals-btn">Add to History</button>
          `;
        } else {
          addContainer.innerHTML = `
            <input type="text" id="fullscreen-meals-input" placeholder="Add meal..." maxlength="100">
            <button onclick="addMealItemFullscreen()" id="fullscreen-add-meals-btn">Add</button>
          `;
        }
        content.appendChild(addContainer);
        
        // Add task list
        const taskList = document.createElement('ul');
        taskList.id = 'fullscreen-meals-list';
        taskList.className = 'task-list';
        content.appendChild(taskList);
        
        // Render existing meals
        setTimeout(() => {
          renderMealsListFullscreen();
          
          // Add Enter key support
          const input = document.getElementById('fullscreen-meals-input');
          if (input) {
            input.addEventListener('keypress', function(e) {
              if (e.key === 'Enter') {
                if (showingMealHistory) {
                  addMealToHistoryOnlyFullscreen();
                } else {
                  addMealItemFullscreen();
                }
              }
            });
          }
        }, 100);
      }
      
      fullscreenDiv.appendChild(fullscreenHeader);
      fullscreenDiv.appendChild(content);
      document.body.appendChild(fullscreenDiv);
      
      // Update URL based on widget type and current mode
      if (widgetType === 'todo') {
        updateURL(showingTodoHistory ? 'todo-history' : 'todo');
      } else if (widgetType === 'meals') {
        updateURL(showingMealHistory ? 'meals-history' : 'meals');
      } else {
        updateURL(widgetType); // grocery, calendar, etc.
      }
      
      // Start inactivity detection (desktop only)
      if (!window.pwaInfo?.isPWA) {
      setupInactivityDetection();
      }
    }

    function closeFullscreen() {
      const fullscreenContainer = document.getElementById('fullscreen-container');
      const main = document.querySelector('main');
      const header = document.querySelector('header');
      
      // Clean up inactivity detection
      cleanupInactivityDetection();
      
      if (fullscreenContainer) {
        fullscreenContainer.remove();
      }
      
      // Show main dashboard
      main.classList.remove('hidden');
      header.classList.remove('hidden');
      
      // Update URL to dashboard view
      updateURL('dashboard');
      
      // Re-render lists to sync any changes made in fullscreen
      renderTodoList();
      renderGroceryList();
      renderMealsList();
    }

    // Fullscreen todo functions
    function addTodoItemFullscreen() {
      const input = document.getElementById('fullscreen-todo-input');
      const dueDateInput = document.getElementById('fullscreen-todo-due-date');
      const text = input.value.trim();
      const dueDate = dueDateInput ? dueDateInput.value : null;
      
      if (text) {
        const item = {
          id: Date.now(),
          text: text,
          completed: false,
          createdAt: new Date().toISOString(),
          order: Date.now(),
          dueDate: dueDate || null,
          assignedTo: 'family' // Auto-assign to family by default
        };
        
        todoItems.unshift(item);
        updateItemOrders(todoItems);
        saveTodoItems();
        renderTodoListFullscreen();
        input.value = '';
        if (dueDateInput) dueDateInput.value = '';
      }
    }

    function renderTodoListFullscreen() {
      const list = document.getElementById('fullscreen-todo-list');
      if (!list) return;
      
      if (showingTodoHistory) {
        let filteredHistory = [...todoHistory];
        
        // Apply search filters
        if (currentTodoSearchTerm) {
          filteredHistory = fuzzySearchTodos(filteredHistory, currentTodoSearchTerm);
        }
        
        if (currentDateFrom || currentDateTo) {
          filteredHistory = filterTodosByDateRange(filteredHistory, currentDateFrom, currentDateTo);
        }
        
        // Apply avatar filters
        filteredHistory = filterTodosByAvatar(filteredHistory);
        
        if (filteredHistory.length === 0) {
          const emptyMessage = (currentTodoSearchTerm || currentDateFrom || currentDateTo || selectedAvatarFilters.length > 0) ? 
            'No tasks found matching your search criteria.' : 
            'No completed tasks yet.';
          list.innerHTML = `<li class="empty-state">${emptyMessage}</li>`;
          return;
        }
        
        const groups = groupTodosByDate(filteredHistory);
        list.innerHTML = renderTodoHistoryGrouped(groups);
        
        // Set up drag and drop for history items (within date groups only)
        setTimeout(() => setupTodoHistoryDragAndDrop(list, groups), 0);
      } else {
        // Only show uncompleted items (completed items are immediately moved to history)
        let activeItems = todoItems.filter(item => !item.completed);
        
        // Apply avatar filters
        activeItems = filterTodosByAvatar(activeItems);
        
        if (activeItems.length === 0) {
          const emptyMessage = selectedAvatarFilters.length > 0 ? 
            'No tasks found for selected filters.' : 
            'No tasks yet. Add one above!';
          list.innerHTML = `<li class="empty-state">${emptyMessage}</li>`;
          return;
        }
        
        // Sort by order and ensure all items have order property
        updateItemOrders(activeItems);
        activeItems = sortItemsByOrder(activeItems);
        
        list.innerHTML = activeItems.map(item => {
          const dueDateDisplay = item.dueDate ? formatDueDate(item.dueDate) : '';
          const isOverdue = item.dueDate && isTaskOverdue(item.dueDate);
          const isDueToday = item.dueDate && isTaskDueToday(item.dueDate);
          const isDueTomorrow = item.dueDate && isTaskDueTomorrow(item.dueDate);
          
          let dueDateClass = '';
          let taskItemClass = '';
          
          if (isOverdue) {
            dueDateClass = 'overdue';
            taskItemClass = 'overdue';
          } else if (isDueToday) {
            dueDateClass = 'due-today';
            taskItemClass = 'due-today';
          } else if (isDueTomorrow) {
            dueDateClass = 'due-tomorrow';
            taskItemClass = 'due-tomorrow';
          }
          
          const assignedTo = item.assignedTo || 'family'; // Default to family if not assigned
          const avatarHtml = `<span class="person-avatar ${assignedTo}" onclick="editTodoAssignment(${item.id})" title="Click to change assignment - Currently: ${assignedTo === 'emley' ? 'Emley' : assignedTo === 'nate' ? 'Nate' : 'Family'}" style="cursor: pointer;">${assignedTo === 'emley' ? 'E' : assignedTo === 'nate' ? 'N' : 'F'}</span>`;
          
          return `
            <li class="task-item ${taskItemClass}">
            <span class="drag-handle">â˜°</span>
            <input type="checkbox" class="task-checkbox" 
                   onchange="toggleTodoItem(${item.id}); renderTodoListFullscreen();">
              ${avatarHtml}
            <span class="task-text">${escapeHtml(item.text)}</span>
              ${dueDateDisplay ? `<span class="task-due-date ${dueDateClass}" onclick="editTodoDueDate(${item.id})" title="Click to edit due date">${dueDateDisplay}</span>` : ''}
            <div class="task-actions">
              <button class="edit-btn" onclick="editTodoItem(${item.id}); renderTodoListFullscreen();" title="Edit">âœï¸</button>
              <button class="delete-btn" onclick="deleteTodoItem(${item.id}); renderTodoListFullscreen();" title="Delete">ðŸ—‘ï¸</button>
            </div>
          </li>
          `;
        }).join('');
        
        // Set up drag and drop
        setTimeout(() => setupDragAndDrop(list, activeItems, 'todo'), 0);
      }
    }

    function filterTodoHistoryFullscreen() {
      const searchInput = document.getElementById('fullscreen-todo-search-input');
      const dateFromInput = document.getElementById('fullscreen-todo-date-from');
      const dateToInput = document.getElementById('fullscreen-todo-date-to');
      
      currentTodoSearchTerm = searchInput ? searchInput.value.toLowerCase().trim() : '';
      currentDateFrom = dateFromInput ? dateFromInput.value : '';
      currentDateTo = dateToInput ? dateToInput.value : '';
      
      renderTodoListFullscreen();
    }

    function clearTodoSearchFullscreen() {
      const searchInput = document.getElementById('fullscreen-todo-search-input');
      const dateFromInput = document.getElementById('fullscreen-todo-date-from');
      const dateToInput = document.getElementById('fullscreen-todo-date-to');
      
      if (searchInput) searchInput.value = '';
      if (dateFromInput) dateFromInput.value = '';
      if (dateToInput) dateToInput.value = '';
      
      currentTodoSearchTerm = '';
      currentDateFrom = '';
      currentDateTo = '';
      
      // Clear avatar filters
      selectedAvatarFilters = [];
      updateAvatarFilterButtons();
      
      renderTodoListFullscreen();
    }

    // Todo Calendar Functions (now handled by fullscreen system)

    function renderCalendarMonth(year, month, monthName, todosByDate) {
      const firstDay = new Date(year, month, 1);
      const lastDay = new Date(year, month + 1, 0);
      const startDate = new Date(firstDay);
      startDate.setDate(startDate.getDate() - firstDay.getDay()); // Start from Sunday
      
      const today = new Date().toISOString().split('T')[0];
      
      let monthHTML = `
        <div style="border: 1px solid #ddd; border-radius: 8px; overflow: hidden;">
          <div style="background: var(--primary-color); color: white; padding: 12px; text-align: center; font-weight: bold;">
            ${monthName}
          </div>
          <div style="display: grid; grid-template-columns: repeat(7, 1fr);">
      `;
      
      // Day headers
      const dayHeaders = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
      dayHeaders.forEach(day => {
        monthHTML += `<div style="padding: 8px; text-align: center; font-weight: bold; background: #f8f9fa; border-bottom: 1px solid #ddd;">${day}</div>`;
      });
      
      // Calendar days
      const currentDate = new Date(startDate);
      for (let week = 0; week < 6; week++) {
        for (let day = 0; day < 7; day++) {
          const dateStr = currentDate.toISOString().split('T')[0];
          const isCurrentMonth = currentDate.getMonth() === month;
          const isToday = dateStr === today;
          const todosForDate = todosByDate[dateStr] || [];
          
          let dayClass = 'calendar-day';
          let dayStyle = `
            padding: 8px 4px;
            min-height: 60px;
            border-bottom: 1px solid #eee;
            border-right: 1px solid #eee;
            position: relative;
            font-size: 12px;
          `;
          
          if (!isCurrentMonth) {
            dayStyle += 'color: #ccc; background: #f9f9f9;';
          } else if (isToday) {
            dayStyle += 'background: #e3f2fd; font-weight: bold;';
          }
          
          monthHTML += `<div class="${dayClass}" style="${dayStyle}">`;
          monthHTML += `<div style="font-weight: ${isToday ? 'bold' : 'normal'};">${currentDate.getDate()}</div>`;
          
          // Add todos for this date
          todosForDate.forEach(todo => {
            let todoStyle, todoIcon, tooltipSuffix;
            
            if (todo.type === 'completed') {
              // Completed tasks: Green
              todoStyle = 'background: #4caf50; color: white;';
              todoIcon = 'âœ“';
              tooltipSuffix = '(Completed)';
            } else {
              // Due tasks: Check if overdue
              const taskDate = dateStr;
              const isOverdue = taskDate < today;
              
              if (isOverdue) {
                // Overdue tasks: Red
                todoStyle = 'background: #f44336; color: white;';
                todoIcon = '!';
                tooltipSuffix = '(Overdue)';
              } else {
                // Current/future due tasks: No special color (neutral gray)
                todoStyle = 'background: #757575; color: white;';
                todoIcon = 'â€¢';
                tooltipSuffix = '(Due)';
              }
            }
            
            // Determine the appropriate edit function based on todo type
            const editFunction = todo.type === 'completed' 
              ? `editTodoFromCalendar(${todo.id}, true)` // true for history item
              : `editTodoFromCalendar(${todo.id}, false)`; // false for current item
            
            monthHTML += `
              <div style="${todoStyle} padding: 2px 4px; margin: 1px 0; border-radius: 3px; font-size: 10px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; cursor: pointer;" 
                   title="Click to edit: ${escapeHtml(todo.text)} ${tooltipSuffix}"
                   onclick="${editFunction}">
                ${todoIcon} ${escapeHtml(todo.text.substring(0, 15))}${todo.text.length > 15 ? '...' : ''}
              </div>
            `;
          });
          
          monthHTML += '</div>';
          currentDate.setDate(currentDate.getDate() + 1);
        }
        
        // Break if we've gone past the current month
        if (currentDate.getMonth() !== month && week >= 4) break;
      }
      
      monthHTML += '</div></div>';
      return monthHTML;
    }

    // Calendar navigation state
    let calendarViewDate = new Date();

    function renderTodoCalendarFullscreen() {
      const container = document.getElementById('fullscreen-todo-calendar-container');
      if (!container) return;
      
      // Use the calendar view date (defaults to current date)
      const viewYear = calendarViewDate.getFullYear();
      const viewMonth = calendarViewDate.getMonth();
      
      // Show only the selected month
      const months = [{
        year: viewYear,
        month: viewMonth,
        name: calendarViewDate.toLocaleString('default', { month: 'long', year: 'numeric' })
      }];
      
      // Group todos by date - combine ALL data for comprehensive view
      const todosByDate = {};
      
      // Add completed todos from history on their completion date
      let filteredHistory = todoHistory.filter(todo => todo.completedAt);
      filteredHistory = filterCalendarTodosByAvatar(filteredHistory);
      
      filteredHistory.forEach(todo => {
        const completedDate = new Date(todo.completedAt).toISOString().split('T')[0];
        if (!todosByDate[completedDate]) todosByDate[completedDate] = [];
        todosByDate[completedDate].push({...todo, completed: true, type: 'completed'});
      });
      
      // Add uncompleted todos from current list with due dates on their due date
      let filteredCurrent = todoItems.filter(todo => !todo.completed && todo.dueDate);
      filteredCurrent = filterCalendarTodosByAvatar(filteredCurrent);
      
      filteredCurrent.forEach(todo => {
        if (!todosByDate[todo.dueDate]) todosByDate[todo.dueDate] = [];
        todosByDate[todo.dueDate].push({...todo, type: 'due'});
      });
      
        // Add navigation controls
        let calendarHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding: 0 10px;">
            <button onclick="navigateCalendar(-1)" style="
              background: var(--primary-color); 
              color: white; 
              border: none; 
              border-radius: 6px; 
              padding: 8px 16px; 
              cursor: pointer; 
              font-size: 14px;
              display: flex;
              align-items: center;
              gap: 5px;
            ">
              â† Previous Month
            </button>
            
            <div style="display: flex; align-items: center; gap: 10px;">
              <button onclick="navigateCalendar(0)" style="
                background: #6c757d; 
                color: white; 
                border: none; 
                border-radius: 6px; 
                padding: 8px 16px; 
                cursor: pointer; 
                font-size: 14px;
              ">
                Today
              </button>
              
              <div class="calendar-avatar-filters" style="display: flex; gap: 5px; margin-left: 10px;">
                <span class="calendar-avatar-filter emley" data-avatar="emley" onclick="toggleCalendarAvatarFilter('emley')" title="Filter by Emley" style="
                  width: 28px; height: 28px; border-radius: 50%; display: flex; align-items: center; justify-content: center; 
                  cursor: pointer; font-weight: bold; font-size: 12px; border: 2px solid transparent; transition: all 0.2s;
                  background: #e3f2fd; color: #1976d2;
                ">E</span>
                <span class="calendar-avatar-filter nate" data-avatar="nate" onclick="toggleCalendarAvatarFilter('nate')" title="Filter by Nate" style="
                  width: 28px; height: 28px; border-radius: 50%; display: flex; align-items: center; justify-content: center; 
                  cursor: pointer; font-weight: bold; font-size: 12px; border: 2px solid transparent; transition: all 0.2s;
                  background: #f3e5f5; color: #7b1fa2;
                ">N</span>
                <span class="calendar-avatar-filter family" data-avatar="family" onclick="toggleCalendarAvatarFilter('family')" title="Filter by Family" style="
                  width: 28px; height: 28px; border-radius: 50%; display: flex; align-items: center; justify-content: center; 
                  cursor: pointer; font-weight: bold; font-size: 12px; border: 2px solid transparent; transition: all 0.2s;
                  background: #e8f5e8; color: #388e3c;
                ">F</span>
              </div>
            </div>
            
            <button onclick="navigateCalendar(1)" style="
              background: var(--primary-color); 
              color: white; 
              border: none; 
              border-radius: 6px; 
              padding: 8px 16px; 
              cursor: pointer; 
              font-size: 14px;
              display: flex;
              align-items: center;
              gap: 5px;
            ">
              Next Month â†’
            </button>
          </div>
        `;
        
        // Render calendar month
        calendarHTML += '<div style="display: grid; grid-template-columns: 1fr; gap: 20px;">';
        
        months.forEach(monthInfo => {
          calendarHTML += renderCalendarMonth(monthInfo.year, monthInfo.month, monthInfo.name, todosByDate);
        });
        
        calendarHTML += '</div>';
        container.innerHTML = calendarHTML;
        
        // Update filter button appearance after rendering
        setTimeout(() => updateCalendarAvatarFilterButtons(), 0);
    }

    function navigateCalendar(direction) {
      if (direction === 0) {
        // Reset to current month
        calendarViewDate = new Date();
      } else {
        // Navigate to previous (-1) or next (1) month
        calendarViewDate.setMonth(calendarViewDate.getMonth() + direction);
      }
      
      // Re-render the calendar with the new date
      renderTodoCalendarFullscreen();
    }

    function editTodoFromCalendar(todoId, isHistoryItem) {
      if (isHistoryItem) {
        // For completed tasks, we need to re-add them to current list first
        // Find the history item
        const historyItem = todoHistory.find(item => item.id === todoId);
        if (!historyItem) {
          console.error('History item not found:', todoId);
          return;
        }
        
        // Re-add to current list (this will remove from history)
        reAddTodoFromHistory(todoId);
        
        // Find the newly created item in current list (it will have a new ID)
        // We need to find it by text since the ID changes
        const newItem = todoItems.find(item => 
          item.text === historyItem.text && 
          item.originalHistoryId === todoId
        );
        
        if (newItem) {
          // Open edit modal for the new current item
          setTimeout(() => editTodoItem(newItem.id), 100);
        }
      } else {
        // For current tasks, directly open the edit modal
        editTodoItem(todoId);
      }
    }

    // Calendar-specific avatar filtering
    let selectedCalendarAvatarFilters = [];

    function toggleCalendarAvatarFilter(avatar) {
      const index = selectedCalendarAvatarFilters.indexOf(avatar);
      if (index > -1) {
        // Remove filter if already selected
        selectedCalendarAvatarFilters.splice(index, 1);
      } else {
        // Add filter if not selected
        selectedCalendarAvatarFilters.push(avatar);
      }
      
      // Update filter button appearance
      updateCalendarAvatarFilterButtons();
      
      // Re-render the calendar with filters applied
      renderTodoCalendarFullscreen();
    }

    function updateCalendarAvatarFilterButtons() {
      const calendarFilters = document.querySelectorAll('.calendar-avatar-filter');
      calendarFilters.forEach(button => {
        const avatar = button.dataset.avatar;
        if (selectedCalendarAvatarFilters.includes(avatar)) {
          button.style.border = '2px solid var(--primary-color)';
          button.style.transform = 'scale(1.1)';
        } else {
          button.style.border = '2px solid transparent';
          button.style.transform = 'scale(1)';
        }
      });
    }

    function filterCalendarTodosByAvatar(items) {
      // If no filters selected, show all items
      if (selectedCalendarAvatarFilters.length === 0) {
        return items;
      }
      
      // Filter items based on selected avatars
      return items.filter(item => {
        const assignedTo = item.assignedTo || 'family'; // Default to family if not assigned
        return selectedCalendarAvatarFilters.includes(assignedTo);
      });
    }

    // Fullscreen grocery functions
    function addGroceryItemFullscreen() {
      const input = document.getElementById('fullscreen-grocery-input');
      const text = input.value.trim();
      
      if (text) {
        const item = {
          id: Date.now(),
          text: text,
          completed: false,
          createdAt: new Date().toISOString(),
          order: Date.now() // Add order property for sorting
        };
        
        groceryItems.unshift(item);
        updateItemOrders(groceryItems); // Update all orders
        saveGroceryItems();
        renderGroceryListFullscreen();
        input.value = '';
      }
    }

    function renderGroceryListFullscreen() {
      const list = document.getElementById('fullscreen-grocery-list');
      if (!list) return;
      
      if (groceryItems.length === 0) {
        list.innerHTML = '<li class="empty-state">No items yet. Add one above!</li>';
        return;
      }
      
      // Sort by order and ensure all items have order property
      updateItemOrders(groceryItems);
      const sortedItems = sortItemsByOrder([...groceryItems]);
      
      // Group items by category
      const groupedItems = groupGroceriesByCategory(sortedItems);
      
      // Define category order for logical shopping flow
      const categoryOrder = [
        'Produce',
        'Bakery', 
        'Deli',
        'Meat & Seafood',
        'Dairy',
        'Canned & Packaged Goods',
        'Spices',
        'Dry Goods & Baking',
        'Snacks & Candy',
        'Cereal & Breakfast',
        'Pasta, Rice & International Foods',
        'Frozen Foods',
        'Beverages',
        'Health & Beauty',
        'Cleaning & Household',
        'Pet Supplies',
        'Floral Department',
        'Pharmacy',
        'Other'
      ];
      
      let html = '';
      
      categoryOrder.forEach(category => {
        const items = groupedItems[category];
        if (items && items.length > 0) {
          // Add category header as drop zone
          html += `<li class="category-header" 
                      data-category="${category}"
                      style="
            font-weight: bold; 
            color: var(--primary-color); 
            background: #f8f9fa; 
            padding: 8px 12px; 
            margin: 8px 0 4px 0; 
            border-radius: 4px;
            list-style: none;
            border-left: 4px solid var(--primary-color);
            cursor: pointer;
          ">${category}</li>`;
          
          // Add items in this category
          items.forEach(item => {
            const recipeSource = item.recipeSource ? `<div class="recipe-source" style="font-size: 0.8em; color: #666; margin-top: 2px;">For: ${escapeHtml(item.recipeSource)}</div>` : '';
            const optionalIndicator = item.isOptional ? ' <span style="color: #999; font-size: 0.8em;">(optional)</span>' : '';
            
            html += `
              <li class="task-item" data-item-id="${item.id}">
          <span class="drag-handle">â˜°</span>
          <input type="checkbox" class="task-checkbox" 
                 ${item.completed ? 'checked' : ''} 
                 onchange="toggleGroceryItem(${item.id}); renderGroceryListFullscreen();">
                <div style="flex: 1;">
                  <span class="task-text ${item.completed ? 'completed' : ''}">${escapeHtml(item.text)}${optionalIndicator}</span>
                  ${recipeSource}
                </div>
          <div class="task-actions">
            <button class="edit-btn" onclick="editGroceryItem(${item.id}); renderGroceryListFullscreen();" title="Edit">âœï¸</button>
            <button class="delete-btn" onclick="deleteGroceryItem(${item.id}); renderGroceryListFullscreen();" title="Delete">ðŸ—‘ï¸</button>
          </div>
        </li>
            `;
          });
        }
      });
      
      list.innerHTML = html;
      
      // Set up enhanced drag and drop for categorized grocery lists
      setTimeout(() => setupGroceryDragAndDrop(list), 0);
    }

    // Optional: Auto-save feature and data export/import for sharing between devices
    function exportData() {
      const data = {
        todoItems: todoItems,
        groceryItems: groceryItems,
        exportDate: new Date().toISOString()
      };
      
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'smart-dashboard-lists.json';
      a.click();
      URL.revokeObjectURL(url);
    }

    function importData(event) {
      const file = event.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = function(e) {
          try {
            const data = JSON.parse(e.target.result);
            if (data.todoItems && data.groceryItems) {
              todoItems = data.todoItems;
              groceryItems = data.groceryItems;
              saveTodoItems();
              saveGroceryItems();
              renderTodoList();
              renderGroceryList();
              alert('Data imported successfully!');
            }
          } catch (err) {
            alert('Error importing data. Please check the file format.');
          }
        };
        reader.readAsText(file);
      }
    }
    // URL Management Functions
    function updateURL(view) {
      const url = new URL(window.location);
      if (view === 'home') {
        url.searchParams.delete('view');
      } else {
        url.searchParams.set('view', view);
      }
      window.history.pushState({}, '', url);
    }

    // Navigation Functions
    function showLandingPage() {
      document.getElementById('landing-page').style.display = 'flex';
      document.getElementById('dashboard').style.display = 'none';
      
      // Show version indicator on home view
      const versionIndicator = document.getElementById('pwa-version-indicator');
      if (versionIndicator) {
        versionIndicator.style.display = 'block';
      }
      
      closeFullscreen();
      updateURL('home');
    }

    function showDashboard() {
      document.getElementById('landing-page').style.display = 'none';
      document.getElementById('dashboard').style.display = 'block';
      
      // Hide version indicator on dashboard
      const versionIndicator = document.getElementById('pwa-version-indicator');
      if (versionIndicator) {
        versionIndicator.style.display = 'none';
      }
      
      // Apply PWA-specific dashboard layout if in PWA mode
      if (window.pwaInfo?.isPWA) {
        applyPWADashboardLayout();
      }
      
      updateURL('dashboard');
    }

    function showFullscreenCalendar() {
      document.getElementById('landing-page').style.display = 'none';
      document.getElementById('dashboard').style.display = 'block';
      openFullscreen('calendar');
      updateURL('calendar');
    }

    function showFullscreenTodo() {
      document.getElementById('landing-page').style.display = 'none';
      document.getElementById('dashboard').style.display = 'block';
      showingTodoHistory = false; // Always show current todos when clicking from home
      openFullscreen('todo');
      updateURL('todo');
    }

    function showFullscreenTodoHistory() {
      document.getElementById('landing-page').style.display = 'none';
      document.getElementById('dashboard').style.display = 'block';
      showingTodoHistory = true;
      openFullscreen('todo');
      updateURL('todo-history');
    }

    function showFullscreenTodoCalendar() {
      // Reset calendar to current month when opening
      calendarViewDate = new Date();
      document.getElementById('landing-page').style.display = 'none';
      document.getElementById('dashboard').style.display = 'block';
      openFullscreen('todo-calendar');
      updateURL('todo-calendar');
    }

    function showFullscreenGrocery() {
      document.getElementById('landing-page').style.display = 'none';
      document.getElementById('dashboard').style.display = 'block';
      openFullscreen('grocery');
      updateURL('grocery');
    }

    function showFullscreenMeals() {
      document.getElementById('landing-page').style.display = 'none';
      document.getElementById('dashboard').style.display = 'block';
      showingMealHistory = false; // Always show current meals when clicking from home
      openFullscreen('meals');
      updateURL('meals');
    }

    function showFullscreenMealsHistory() {
      document.getElementById('landing-page').style.display = 'none';
      document.getElementById('dashboard').style.display = 'block';
      showingMealHistory = true;
      
      // Update button text to reflect current state
      updateMealsButtonState();
      
      openFullscreen('meals');
      updateURL('meals-history');
    }

    function updateMealsButtonState() {
      const historyButton = document.querySelector('.meals-widget .history-button');
      const headerTitle = document.querySelector('.meals-widget h2');
      
      if (historyButton && headerTitle) {
        historyButton.textContent = showingMealHistory ? 'Current' : 'History';
        headerTitle.textContent = showingMealHistory ? 'Meals History' : 'Meals';
      }
    }

    // Medications functions
    function showFullscreenMedications() {
      document.getElementById('landing-page').style.display = 'none';
      document.getElementById('dashboard').style.display = 'block';
      openFullscreenMedications();
      updateURL('medications');
    }

    function openFullscreenMedications() {
      // Check if PWA mode (define early so it can be used throughout)
      const isPWA = window.matchMedia && window.matchMedia('(display-mode: standalone)').matches;
      
      const main = document.querySelector('main');
      const header = document.querySelector('header');
      
      // Hide main dashboard
      main.classList.add('hidden');
      header.classList.add('hidden');
      
      // Create full-screen container
      const fullscreenDiv = document.createElement('div');
      fullscreenDiv.className = 'fullscreen-mode';
      fullscreenDiv.id = 'fullscreen-container';
      
      // Create header with back button
      const fullscreenHeader = document.createElement('div');
      fullscreenHeader.className = 'fullscreen-header';
      
      const title = document.createElement('h1');
      title.className = 'fullscreen-title';
      title.textContent = showingMedicationsHistory ? 'Medications History' : 'Medications';
      
      // Make title clickable on desktop (not PWA)
      if (!isPWA) {
        title.onclick = closeFullscreen;
        title.style.cursor = 'pointer';
      }
      
      const buttonContainer = document.createElement('div');
      buttonContainer.style.display = 'flex';
      buttonContainer.style.gap = '1rem';
      
      const homeButton = document.createElement('button');
      homeButton.className = 'back-button';
      homeButton.onclick = showLandingPage;
      homeButton.innerHTML = 'ðŸ  Home';
      
      const backButton = document.createElement('button');
      backButton.className = 'back-button';
      backButton.onclick = closeFullscreen;
      backButton.innerHTML = '<img src="dashboard_icon.png?v=1126" style="width: 20px; height: 20px; object-fit: cover; border-radius: 0; vertical-align: middle; margin-right: 6px; display: inline-block;">Dashboard';
      
      const historyButton = document.createElement('button');
      historyButton.className = 'back-button';
      historyButton.onclick = toggleMedicationsHistory;
      historyButton.innerHTML = showingMedicationsHistory ? 'Current' : 'History';
      historyButton.style.background = 'var(--primary-color)';
      
      fullscreenHeader.appendChild(title);
      
      if (isPWA) {
        // PWA: Home button first, then History button (no Dashboard button)
        buttonContainer.appendChild(homeButton);
        buttonContainer.appendChild(historyButton);
      } else {
        // Desktop: History button first, then Dashboard button, then Home button
        buttonContainer.appendChild(historyButton);
        buttonContainer.appendChild(backButton);
        buttonContainer.appendChild(homeButton);
      }
      
      fullscreenHeader.appendChild(buttonContainer);
      
      // Create content area
      const content = document.createElement('div');
      content.className = 'fullscreen-content';
      
      // Check if we need to reset daily
      checkAndResetMedications();
      
      if (showingMedicationsHistory) {
        // Show history view
        renderMedicationsHistory(content);
      } else {
        // Create current medications UI
        const medsContainer = document.createElement('div');
        // Desktop: side-by-side grid (3 columns), Mobile: stacked
        if (isPWA) {
          medsContainer.style.cssText = 'display: flex; flex-direction: column; gap: 2rem; padding: 2rem;';
        } else {
          medsContainer.style.cssText = 'display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 2rem; padding: 2rem;';
        }
        
        // Early Morning medication
        const earlyMorningCard = createMedicationCard('earlyMorning', 'ðŸŒ…', 'Early Morning Medications');
        medsContainer.appendChild(earlyMorningCard);
        
        // Morning medication
        const morningCard = createMedicationCard('morning', 'ðŸŒ„', 'Morning Medications');
        medsContainer.appendChild(morningCard);
        
        // Evening medication
        const eveningCard = createMedicationCard('evening', 'ðŸŒ™', 'Evening Medications');
        medsContainer.appendChild(eveningCard);
        
        content.appendChild(medsContainer);
      }
      
      fullscreenDiv.appendChild(fullscreenHeader);
      fullscreenDiv.appendChild(content);
      document.body.appendChild(fullscreenDiv);
      
      // Start inactivity detection (desktop only)
      if (!isPWA) {
        setupInactivityDetection();
      }
    }

    function createMedicationCard(type, icon, label) {
      // Check if PWA mode
      const isPWA = window.matchMedia && window.matchMedia('(display-mode: standalone)').matches;
      
      const card = document.createElement('div');
      const cardPadding = isPWA ? '2rem' : '2.5rem';
      card.style.cssText = `
        background: white;
        border-radius: 16px;
        padding: ${cardPadding};
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        display: flex;
        align-items: center;
        gap: 1.5rem;
        transition: all 0.3s ease;
        ${isPWA ? 'cursor: pointer;' : ''}
      `;
      
      // Make entire card clickable on PWA
      if (isPWA) {
        card.onclick = () => {
          const checkbox = document.getElementById(`${type}-checkbox`);
          checkbox.checked = !checkbox.checked;
          toggleMedication(type);
        };
      }
      
      const iconSpan = document.createElement('span');
      const iconSize = isPWA ? '3rem' : '4rem';
      iconSpan.style.cssText = `font-size: ${iconSize}; ${isPWA ? 'pointer-events: none;' : ''}`;
      iconSpan.textContent = icon;
      
      const contentDiv = document.createElement('div');
      contentDiv.style.cssText = `flex: 1; ${isPWA ? 'pointer-events: none;' : ''}`;
      
      const labelDiv = document.createElement('div');
      const labelSize = isPWA ? '1.25rem' : '1.5rem';
      const labelColor = isPWA ? '#000000' : 'var(--text-primary)';
      labelDiv.style.cssText = `font-size: ${labelSize}; font-weight: 600; color: ${labelColor}; margin-bottom: 0.5rem;`;
      labelDiv.textContent = label;
      
      const statusDiv = document.createElement('div');
      statusDiv.id = `${type}-status`;
      const statusSize = isPWA ? '0.9rem' : '1rem';
      const statusColor = isPWA ? '#000000' : 'var(--text-secondary)';
      statusDiv.style.cssText = `font-size: ${statusSize}; color: ${statusColor};`;
      
      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.id = `${type}-checkbox`;
      checkbox.checked = medications[type].taken;
      const checkboxSize = isPWA ? '32px' : '40px';
      const checkboxAccent = isPWA ? '#000000' : 'var(--primary-color)';
      checkbox.style.cssText = `
        width: ${checkboxSize};
        height: ${checkboxSize};
        cursor: pointer;
        accent-color: ${checkboxAccent};
        ${isPWA ? 'pointer-events: none;' : ''}
      `;
      
      // Only add onchange for desktop (PWA uses card click)
      if (!isPWA) {
        checkbox.onchange = () => toggleMedication(type);
      }
      
      contentDiv.appendChild(labelDiv);
      contentDiv.appendChild(statusDiv);
      
      card.appendChild(iconSpan);
      card.appendChild(contentDiv);
      card.appendChild(checkbox);
      
      // Update status text
      updateMedicationStatus(type);
      
      return card;
    }

    function checkAndResetMedications() {
      // Ensure earlyMorning exists for backward compatibility
      if (!medications.earlyMorning) {
        medications.earlyMorning = { taken: false, timestamp: null };
      }
      
      const today = new Date().toDateString();
      if (medications.lastReset !== today) {
        // Save previous day to history before resetting (if any medication was taken)
        if (medications.earlyMorning.taken || medications.morning.taken || medications.evening.taken) {
          const historyEntry = {
            date: medications.lastReset,
            earlyMorning: { ...medications.earlyMorning },
            morning: { ...medications.morning },
            evening: { ...medications.evening }
          };
          
          // Check if this date already exists in history (avoid duplicates)
          const existingIndex = medicationsHistory.findIndex(entry => entry.date === medications.lastReset);
          if (existingIndex >= 0) {
            medicationsHistory[existingIndex] = historyEntry;
          } else {
            medicationsHistory.push(historyEntry);
          }
          
          // Sort history by date (newest first)
          medicationsHistory.sort((a, b) => new Date(b.date) - new Date(a.date));
          
          // Save history to localStorage
          localStorage.setItem('medicationsHistory', JSON.stringify(medicationsHistory));
          
          console.log('ðŸ’Š Saved medications to history:', historyEntry);
        }
        
        // Reset for new day
        medications.earlyMorning = { taken: false, timestamp: null };
        medications.morning = { taken: false, timestamp: null };
        medications.evening = { taken: false, timestamp: null };
        medications.lastReset = today;
        saveMedications();
      }
    }

    function toggleMedication(type) {
      const checkbox = document.getElementById(`${type}-checkbox`);
      medications[type].taken = checkbox.checked;
      medications[type].timestamp = checkbox.checked ? new Date().toISOString() : null;
      
      updateMedicationStatus(type);
      saveMedications();
    }

    function updateMedicationStatus(type) {
      const statusDiv = document.getElementById(`${type}-status`);
      if (!statusDiv) return;
      
      if (medications[type].taken && medications[type].timestamp) {
        const time = new Date(medications[type].timestamp).toLocaleTimeString('en-US', {
          hour: 'numeric',
          minute: '2-digit',
          hour12: true
        });
        statusDiv.textContent = `âœ… Taken at ${time}`;
        statusDiv.style.color = 'var(--success-color)';
      } else {
        statusDiv.textContent = 'â³ Not taken yet';
        statusDiv.style.color = 'var(--text-secondary)';
      }
    }

    function saveMedications() {
      localStorage.setItem('medications', JSON.stringify(medications));
      localStorage.setItem('medicationsHistory', JSON.stringify(medicationsHistory));
      saveAllData(); // Sync to cloud
    }

    function loadMedications() {
      const saved = localStorage.getItem('medications');
      if (saved) {
        medications = JSON.parse(saved);
        // Ensure earlyMorning exists for backward compatibility
        if (!medications.earlyMorning) {
          medications.earlyMorning = { taken: false, timestamp: null };
        }
        checkAndResetMedications();
      }
      
      const savedHistory = localStorage.getItem('medicationsHistory');
      if (savedHistory) {
        medicationsHistory = JSON.parse(savedHistory);
      }
    }

    // Dishwasher functions
    function showFullscreenDishwasher() {
      document.getElementById('landing-page').style.display = 'none';
      document.getElementById('dashboard').style.display = 'block';
      openFullscreenDishwasher();
      updateURL('dishwasher');
    }

    function openFullscreenDishwasher() {
      // Check if PWA mode (define early so it can be used throughout)
      const isPWA = window.matchMedia && window.matchMedia('(display-mode: standalone)').matches;
      
      const main = document.querySelector('main');
      const header = document.querySelector('header');
      
      // Hide main dashboard
      main.classList.add('hidden');
      header.classList.add('hidden');
      
      // Create full-screen container
      const fullscreenDiv = document.createElement('div');
      fullscreenDiv.className = 'fullscreen-mode';
      fullscreenDiv.id = 'fullscreen-container';
      
      // Create header with back button
      const fullscreenHeader = document.createElement('div');
      fullscreenHeader.className = 'fullscreen-header';
      
      const title = document.createElement('h1');
      title.className = 'fullscreen-title';
      title.textContent = 'Dishwasher Status';
      
      // Make title clickable on desktop (not PWA)
      if (!isPWA) {
        title.onclick = closeFullscreen;
        title.style.cursor = 'pointer';
      }
      
      const buttonContainer = document.createElement('div');
      buttonContainer.style.display = 'flex';
      buttonContainer.style.gap = '1rem';
      
      const homeButton = document.createElement('button');
      homeButton.className = 'back-button';
      homeButton.onclick = showLandingPage;
      homeButton.innerHTML = 'ðŸ  Home';
      
      const backButton = document.createElement('button');
      backButton.className = 'back-button';
      backButton.onclick = closeFullscreen;
      backButton.innerHTML = '<img src="dashboard_icon.png?v=1126" style="width: 20px; height: 20px; object-fit: cover; border-radius: 0; vertical-align: middle; margin-right: 6px; display: inline-block;">Dashboard';
      
      fullscreenHeader.appendChild(title);
      
      if (isPWA) {
        // PWA: Home button first, then Dashboard button
        buttonContainer.appendChild(homeButton);
        buttonContainer.appendChild(backButton);
      } else {
        // Desktop: Dashboard button first, then Home button
        buttonContainer.appendChild(backButton);
        buttonContainer.appendChild(homeButton);
      }
      
      fullscreenHeader.appendChild(buttonContainer);
      
      // Create content area
      const content = document.createElement('div');
      content.className = 'fullscreen-content';
      
      // Load dishwasher data
      loadDishwasher();
      
      // Create status display
      const statusCard = document.createElement('div');
      const iconSize = isPWA ? '5rem' : '8rem';
      const cardPadding = isPWA ? '3rem 2rem' : '4rem 3rem';
      statusCard.style.cssText = `
        background: ${dishwasher.status === 'clean' ? 'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)' : 'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)'};
        color: white;
        border-radius: 20px;
        padding: ${cardPadding};
        text-align: center;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
        margin-bottom: 2rem;
      `;
      
      const statusIcon = document.createElement('div');
      statusIcon.style.cssText = `margin-bottom: 1rem;`;
      const iconSrc = dishwasher.status === 'clean' ? 'clean_plate.png' : 'dirty_plate.png';
      statusIcon.innerHTML = `<img src="${iconSrc}?v=1126" style="width: ${iconSize}; height: ${iconSize}; object-fit: contain;">`;
      
      const statusText = document.createElement('div');
      const textSize = isPWA ? '2rem' : '3rem';
      statusText.style.cssText = `font-size: ${textSize}; font-weight: 700; margin-bottom: 0.5rem;`;
      statusText.textContent = dishwasher.status === 'clean' ? 'CLEAN' : 'DIRTY';
      
      const timestampText = document.createElement('div');
      timestampText.style.cssText = 'font-size: 0.95rem; opacity: 0.9;';
      const time = new Date(dishwasher.timestamp).toLocaleString('en-US', {
        weekday: 'short',
        month: 'short',
        day: 'numeric',
        hour: 'numeric',
        minute: '2-digit',
        hour12: true
      });
      timestampText.textContent = `Last updated: ${time}`;
      
      statusCard.appendChild(statusIcon);
      statusCard.appendChild(statusText);
      statusCard.appendChild(timestampText);
      
      // Create toggle buttons
      const buttonsContainer = document.createElement('div');
      buttonsContainer.style.cssText = 'display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;';
      
      const cleanButton = document.createElement('button');
      const buttonPadding = isPWA ? '1.5rem' : '2rem';
      const buttonFontSize = isPWA ? '1.1rem' : '1.3rem';
      const buttonIconSize = isPWA ? '2rem' : '3rem';
      cleanButton.style.cssText = `
        padding: ${buttonPadding};
        background: #4facfe;
        color: white;
        border: 2px solid #4facfe;
        border-radius: 12px;
        cursor: pointer;
        font-size: ${buttonFontSize};
        font-weight: 600;
        transition: all 0.3s ease;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.5rem;
        ${dishwasher.status === 'clean' ? 'box-shadow: 0 0 0 3px rgba(79, 172, 254, 0.3);' : 'opacity: 0.8;'}
      `;
      cleanButton.innerHTML = `<div><img src="clean_plate.png?v=1126" style="width: ${buttonIconSize}; height: ${buttonIconSize}; object-fit: contain;"></div><div>Mark Clean</div>`;
      cleanButton.onclick = () => setDishwasherStatus('clean');
      
      const dirtyButton = document.createElement('button');
      dirtyButton.style.cssText = `
        padding: ${buttonPadding};
        background: #f5576c;
        color: white;
        border: 2px solid #f5576c;
        border-radius: 12px;
        cursor: pointer;
        font-size: ${buttonFontSize};
        font-weight: 600;
        transition: all 0.3s ease;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.5rem;
        ${dishwasher.status === 'dirty' ? 'box-shadow: 0 0 0 3px rgba(245, 87, 108, 0.3);' : 'opacity: 0.8;'}
      `;
      dirtyButton.innerHTML = `<div><img src="dirty_plate.png?v=1126" style="width: ${buttonIconSize}; height: ${buttonIconSize}; object-fit: contain;"></div><div>Mark Dirty</div>`;
      dirtyButton.onclick = () => setDishwasherStatus('dirty');
      
      buttonsContainer.appendChild(cleanButton);
      buttonsContainer.appendChild(dirtyButton);
      
      content.appendChild(statusCard);
      content.appendChild(buttonsContainer);
      
      fullscreenDiv.appendChild(fullscreenHeader);
      fullscreenDiv.appendChild(content);
      document.body.appendChild(fullscreenDiv);
      
      // Start inactivity detection (desktop only)
      if (!isPWA) {
        setupInactivityDetection();
      }
    }

    function setDishwasherStatus(status) {
      dishwasher.status = status;
      dishwasher.timestamp = new Date().toISOString();
      dishwasher.lastUpdated = new Date().toISOString();
      saveDishwasher();
      
      // Refresh the view
      const fullscreenContainer = document.getElementById('fullscreen-container');
      if (fullscreenContainer) {
        fullscreenContainer.remove();
      }
      openFullscreenDishwasher();
    }

    function saveDishwasher() {
      localStorage.setItem('dishwasher', JSON.stringify(dishwasher));
      saveAllData(); // Sync to cloud
    }

    function loadDishwasher() {
      const saved = localStorage.getItem('dishwasher');
      if (saved) {
        dishwasher = JSON.parse(saved);
      }
    }

    function toggleMedicationsHistory() {
      showingMedicationsHistory = !showingMedicationsHistory;
      closeFullscreen();
      openFullscreenMedications();
    }

    function renderMedicationsHistory(container) {
      // Calculate statistics
      const stats = calculateMedicationStats();
      
      // Stats section
      const statsContainer = document.createElement('div');
      statsContainer.style.cssText = 'display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; padding: 2rem; padding-bottom: 1rem;';
      
      // Streak card
      const streakCard = document.createElement('div');
      streakCard.style.cssText = `
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border-radius: 12px;
        padding: 1.5rem;
        text-align: center;
      `;
      streakCard.innerHTML = `
        <div style="font-size: 2.5rem; font-weight: bold;">${stats.currentStreak}</div>
        <div style="font-size: 0.9rem; opacity: 0.9;">Day Streak ðŸ”¥</div>
      `;
      
      // Compliance card
      const complianceCard = document.createElement('div');
      complianceCard.style.cssText = `
        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        color: white;
        border-radius: 12px;
        padding: 1.5rem;
        text-align: center;
      `;
      complianceCard.innerHTML = `
        <div style="font-size: 2.5rem; font-weight: bold;">${stats.complianceRate}%</div>
        <div style="font-size: 0.9rem; opacity: 0.9;">Compliance Rate ðŸ“Š</div>
      `;
      
      // Total days card
      const totalCard = document.createElement('div');
      totalCard.style.cssText = `
        background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        color: white;
        border-radius: 12px;
        padding: 1.5rem;
        text-align: center;
      `;
      totalCard.innerHTML = `
        <div style="font-size: 2.5rem; font-weight: bold;">${stats.totalDays}</div>
        <div style="font-size: 0.9rem; opacity: 0.9;">Days Tracked ðŸ“…</div>
      `;
      
      statsContainer.appendChild(streakCard);
      statsContainer.appendChild(complianceCard);
      statsContainer.appendChild(totalCard);
      container.appendChild(statsContainer);
      
      // History list
      const historyContainer = document.createElement('div');
      historyContainer.style.cssText = 'padding: 0 2rem 2rem 2rem;';
      
      if (medicationsHistory.length === 0) {
        const emptyMessage = document.createElement('div');
        emptyMessage.style.cssText = 'text-align: center; padding: 3rem; color: var(--text-secondary);';
        emptyMessage.innerHTML = `
          <div style="margin-bottom: 1rem;"><img src="medication.png?v=1126" style="width: 80px; height: 80px; object-fit: cover;"></div>
          <div style="font-size: 1.2rem; font-weight: 600; margin-bottom: 0.5rem;">No History Yet</div>
          <div>Start tracking your medications to see history here!</div>
        `;
        historyContainer.appendChild(emptyMessage);
      } else {
        medicationsHistory.forEach(entry => {
          const card = createHistoryCard(entry);
          historyContainer.appendChild(card);
        });
      }
      
      container.appendChild(historyContainer);
    }

    function createHistoryCard(entry) {
      const date = new Date(entry.date);
      const isToday = date.toDateString() === new Date().toDateString();
      const yesterday = new Date();
      yesterday.setDate(yesterday.getDate() - 1);
      const isYesterday = date.toDateString() === yesterday.toDateString();
      
      let dateLabel = date.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric', year: 'numeric' });
      if (isToday) dateLabel = `Today (${dateLabel})`;
      if (isYesterday) dateLabel = `Yesterday (${dateLabel})`;
      
      const card = document.createElement('div');
      card.style.cssText = `
        background: white;
        border-radius: 12px;
        padding: 1.5rem;
        margin-bottom: 1rem;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      `;
      
      const dateHeader = document.createElement('div');
      dateHeader.style.cssText = 'font-weight: 600; font-size: 1.1rem; margin-bottom: 1rem; color: var(--text-primary);';
      dateHeader.textContent = dateLabel;
      
      const dosesContainer = document.createElement('div');
      dosesContainer.style.cssText = 'display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1rem;';
      
      // Early Morning dose
      const earlyMorningDiv = document.createElement('div');
      earlyMorningDiv.style.cssText = 'display: flex; align-items: center; gap: 0.5rem;';
      const earlyMorningIcon = entry.earlyMorning?.taken ? 'âœ…' : 'âŒ';
      const earlyMorningTime = entry.earlyMorning?.taken && entry.earlyMorning?.timestamp 
        ? new Date(entry.earlyMorning.timestamp).toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true })
        : 'Not taken';
      earlyMorningDiv.innerHTML = `
        <img src="medication.png?v=1126" style="width: 1.5rem; height: 1.5rem; object-fit: cover; border-radius: 0;">
        <div>
          <div style="font-weight: 500;">Early Morning ${earlyMorningIcon}</div>
          <div style="font-size: 0.85rem; color: var(--text-secondary);">${earlyMorningTime}</div>
        </div>
      `;
      
      // Morning dose
      const morningDiv = document.createElement('div');
      morningDiv.style.cssText = 'display: flex; align-items: center; gap: 0.5rem;';
      const morningIcon = entry.morning.taken ? 'âœ…' : 'âŒ';
      const morningTime = entry.morning.taken && entry.morning.timestamp 
        ? new Date(entry.morning.timestamp).toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true })
        : 'Not taken';
      morningDiv.innerHTML = `
        <img src="medication.png?v=1126" style="width: 1.5rem; height: 1.5rem; object-fit: cover; border-radius: 0;">
        <div>
          <div style="font-weight: 500;">Morning ${morningIcon}</div>
          <div style="font-size: 0.85rem; color: var(--text-secondary);">${morningTime}</div>
        </div>
      `;
      
      // Evening dose
      const eveningDiv = document.createElement('div');
      eveningDiv.style.cssText = 'display: flex; align-items: center; gap: 0.5rem;';
      const eveningIcon = entry.evening.taken ? 'âœ…' : 'âŒ';
      const eveningTime = entry.evening.taken && entry.evening.timestamp 
        ? new Date(entry.evening.timestamp).toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true })
        : 'Not taken';
      eveningDiv.innerHTML = `
        <img src="medication.png?v=1126" style="width: 1.5rem; height: 1.5rem; object-fit: cover; border-radius: 0;">
        <div>
          <div style="font-weight: 500;">Evening ${eveningIcon}</div>
          <div style="font-size: 0.85rem; color: var(--text-secondary);">${eveningTime}</div>
        </div>
      `;
      
      dosesContainer.appendChild(earlyMorningDiv);
      dosesContainer.appendChild(morningDiv);
      dosesContainer.appendChild(eveningDiv);
      
      card.appendChild(dateHeader);
      card.appendChild(dosesContainer);
      
      return card;
    }

    function calculateMedicationStats() {
      if (medicationsHistory.length === 0) {
        return {
          currentStreak: 0,
          complianceRate: 0,
          totalDays: 0
        };
      }
      
      // Calculate current streak (consecutive days with all doses taken)
      let currentStreak = 0;
      const sortedHistory = [...medicationsHistory].sort((a, b) => new Date(b.date) - new Date(a.date));
      
      for (let i = 0; i < sortedHistory.length; i++) {
        const entry = sortedHistory[i];
        const earlyMorningTaken = entry.earlyMorning?.taken ?? false;
        if (earlyMorningTaken && entry.morning.taken && entry.evening.taken) {
          currentStreak++;
        } else {
          break; // Streak broken
        }
      }
      
      // Calculate compliance rate (percentage of doses taken)
      const totalDoses = medicationsHistory.length * 3; // 3 doses per day
      const takenDoses = medicationsHistory.reduce((sum, entry) => {
        const earlyMorningTaken = entry.earlyMorning?.taken ? 1 : 0;
        return sum + earlyMorningTaken + (entry.morning.taken ? 1 : 0) + (entry.evening.taken ? 1 : 0);
      }, 0);
      const complianceRate = Math.round((takenDoses / totalDoses) * 100);
      
      return {
        currentStreak,
        complianceRate,
        totalDays: medicationsHistory.length
      };
    }

    // URL parameter handling
    function handleURLParameters() {
      const urlParams = new URLSearchParams(window.location.search);
      const view = urlParams.get('view');
      const med = urlParams.get('med'); // For NFC tag support
      const dishwasher = urlParams.get('dishwasher'); // For dishwasher NFC tag support
      
      // Handle medication NFC tags
      if (med === 'earlyMorning' || med === 'morning' || med === 'evening') {
        console.log(`ðŸ’Š NFC tag detected: ${med} medication`);
        
        // Auto-check the medication
        checkAndResetMedications();
        medications[med].taken = true;
        medications[med].timestamp = new Date().toISOString();
        saveMedications();
        
        // Show medications view
        document.getElementById('landing-page').style.display = 'none';
        document.getElementById('dashboard').style.display = 'block';
        openFullscreenMedications();
        
        // Show a confirmation message
        setTimeout(() => {
          const statusDiv = document.getElementById(`${med}-status`);
          if (statusDiv) {
            statusDiv.style.animation = 'pulse 0.5s ease-in-out';
          }
        }, 100);
        
        return; // Exit early, don't process view parameter
      }
      
      // Handle dishwasher NFC tags
      if (dishwasher === 'clean' || dishwasher === 'dirty') {
        console.log(`ðŸ½ï¸ NFC tag detected: dishwasher ${dishwasher}`);
        
        // Update dishwasher status
        loadDishwasher();
        setDishwasherStatus(dishwasher);
        
        // Show dishwasher view
        document.getElementById('landing-page').style.display = 'none';
        document.getElementById('dashboard').style.display = 'block';
        openFullscreenDishwasher();
        
        return; // Exit early, don't process view parameter
      }
      
      switch(view) {
        case 'dashboard':
          // Show dashboard without updating URL (already in URL)
          document.getElementById('landing-page').style.display = 'none';
          document.getElementById('dashboard').style.display = 'block';
          break;
        case 'dishwasher':
          // Show dishwasher view without changing status
          document.getElementById('landing-page').style.display = 'none';
          document.getElementById('dashboard').style.display = 'block';
          openFullscreenDishwasher();
          break;
        case 'calendar':
          // Show fullscreen calendar without updating URL
          document.getElementById('landing-page').style.display = 'none';
          document.getElementById('dashboard').style.display = 'block';
          openFullscreen('calendar');
          break;
        case 'todo':
          // Show fullscreen todo without updating URL
          document.getElementById('landing-page').style.display = 'none';
          document.getElementById('dashboard').style.display = 'block';
          openFullscreen('todo');
          break;
        case 'todo-history':
          // Show fullscreen todo history without updating URL
          document.getElementById('landing-page').style.display = 'none';
          document.getElementById('dashboard').style.display = 'block';
          showingTodoHistory = true;
          openFullscreen('todo');
          break;
        case 'todo-calendar':
          // Show fullscreen todo calendar without updating URL
          document.getElementById('landing-page').style.display = 'none';
          document.getElementById('dashboard').style.display = 'block';
          openFullscreen('todo-calendar');
          break;
        case 'grocery':
          // Show fullscreen grocery without updating URL
          document.getElementById('landing-page').style.display = 'none';
          document.getElementById('dashboard').style.display = 'block';
          openFullscreen('grocery');
          break;
        case 'meals':
          // Show fullscreen meals without updating URL
          document.getElementById('landing-page').style.display = 'none';
          document.getElementById('dashboard').style.display = 'block';
          openFullscreen('meals');
          break;
        case 'meals-history':
          // Show fullscreen meals history without updating URL
          document.getElementById('landing-page').style.display = 'none';
          document.getElementById('dashboard').style.display = 'block';
          showingMealHistory = true;
          updateMealsButtonState();
          openFullscreen('meals');
          break;
        case 'medications':
          // Show fullscreen medications without updating URL
          document.getElementById('landing-page').style.display = 'none';
          document.getElementById('dashboard').style.display = 'block';
          openFullscreenMedications();
          break;
        case 'dishwasher':
          // Show fullscreen dishwasher without updating URL
          document.getElementById('landing-page').style.display = 'none';
          document.getElementById('dashboard').style.display = 'block';
          openFullscreenDishwasher();
          break;
        case 'home':
        case null:
        case undefined:
        default:
          // Landing page is already shown by default
          document.getElementById('landing-page').style.display = 'flex';
          document.getElementById('dashboard').style.display = 'none';
          break;
      }
    }

    // URL parameters are now handled in the main DOMContentLoaded event above

    // Handle browser back/forward buttons
    window.addEventListener('popstate', async function(event) {
      // Ensure data is loaded before handling URL parameters
      if (!todoItems || !groceryItems || !mealItems) {
        console.log('ðŸ”„ Data not loaded, loading before handling URL...');
        await loadAllData();
      }
      handleURLParameters();
    });

  </script>

  <!-- PWA Update Notification Function -->
  <script>
    // Force app update manually
    function forceAppUpdate() {
      console.log('ðŸ”„ Force updating PWA (same as console command)...');
      
      if ('serviceWorker' in navigator) {
        navigator.serviceWorker.getRegistrations().then(registrations => {
          console.log('ðŸ“‹ Found', registrations.length, 'service worker registrations to unregister');
          
          // Unregister all service workers
          registrations.forEach(registration => {
            registration.unregister();
            console.log('ðŸ—‘ï¸ Unregistered:', registration.scope);
          });
          
          // Clear all caches
          caches.keys().then(cacheNames => {
            console.log('ðŸ§¹ Clearing caches:', cacheNames);
            return Promise.all(
              cacheNames.map(cacheName => caches.delete(cacheName))
            );
          }).then(() => {
            console.log('âœ… All caches cleared');
            showUpdateNotification();
            
            // Force reload with cache bypass (same as console command)
            setTimeout(() => {
              console.log('ðŸ”„ Reloading with cache bypass...');
              window.location.href = window.location.href + '?force=' + Date.now();
            }, 1000); // Small delay to show notification
          }).catch(error => {
            console.log('âŒ Failed to clear caches:', error);
            // Fallback: just reload
            window.location.reload();
          });
        }).catch(error => {
          console.log('âŒ Failed to get service worker registrations:', error);
          // Fallback: just reload
          window.location.reload();
        });
      } else {
        console.log('ðŸ”„ Service worker not available, doing simple reload');
        window.location.reload();
      }
    }

    // Show debug panel for PWA troubleshooting
    function showDebugPanel() {
      const panel = document.createElement('div');
      panel.id = 'debug-panel';
      panel.style.cssText = `
        position: fixed;
        top: 50px;
        left: 10px;
        right: 10px;
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 15px;
        border-radius: 10px;
        z-index: 10004;
        font-family: monospace;
        font-size: 12px;
        max-height: 70vh;
        overflow-y: auto;
      `;
      
      const logs = [];
      const originalLog = console.log;
      
      // Capture console logs
      console.log = function(...args) {
        logs.push(args.join(' '));
        if (logs.length > 50) logs.shift(); // Keep last 50 logs
        updateDebugPanel();
        originalLog.apply(console, args);
      };
      
      function updateDebugPanel() {
        if (document.getElementById('debug-panel')) {
          panel.innerHTML = `
            <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
              <strong>ðŸ” PWA Debug Console</strong>
              <button onclick="document.body.removeChild(document.getElementById('debug-panel')); console.log = originalLog;" 
                      style="background: #f44336; color: white; border: none; padding: 5px 10px; border-radius: 5px;">Close</button>
            </div>
            <div style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; max-height: 300px; overflow-y: auto;">
              ${logs.map(log => `<div>${log}</div>`).join('')}
            </div>
            <div style="margin-top: 10px;">
              <button onclick="forceAppUpdate()" style="background: #4caf50; color: white; border: none; padding: 10px; border-radius: 5px; margin-right: 10px;">Force Update</button>
              <button onclick="window.location.reload()" style="background: #2196f3; color: white; border: none; padding: 10px; border-radius: 5px;">Reload</button>
            </div>
          `;
        }
      }
      
      document.body.appendChild(panel);
      updateDebugPanel();
      
      // Store original log function globally
      window.originalLog = originalLog;
    }

    // Show update notification for PWA
    function showUpdateNotification() {
      // DISABLED: No longer showing update notifications since auto-sync is disabled
      console.log('â„¹ï¸ Update notification disabled');
      return;
    }
  </script>

  <!-- PWA Service Worker Registration -->
  <script>
    // Register service worker for PWA functionality
    // Check if running in PWA mode before registering service worker
    const isPWAMode = window.matchMedia('(display-mode: standalone)').matches || 
                      window.navigator.standalone === true;
    
    if ('serviceWorker' in navigator && isPWAMode) {
      console.log('ðŸ”§ Service Worker: Registering for PWA mode only');
      window.addEventListener('load', () => {
        navigator.serviceWorker.register(`/smart-dashboard/sw.js?v=${Date.now()}`)
          .then((registration) => {
            console.log('PWA: Service Worker registered successfully:', registration.scope);
            
            // Check for updates immediately and every 10 seconds for PWA
            window.checkForUpdates = () => {
              console.log('ðŸ”„ PWA: Checking for updates...', new Date().toLocaleTimeString());
              console.log('ðŸ” PWA: Update check triggered by interval ID:', window.updateIntervalId);
              
              // Force update by re-registering with cache-busting timestamp
              const swUrl = `/smart-dashboard/sw.js?v=${Date.now()}`;
              console.log('ðŸ”„ PWA: Force-registering SW with cache-busting:', swUrl);
              
              navigator.serviceWorker.register(swUrl).then(newRegistration => {
                console.log('âœ… PWA: Cache-busted registration completed');
                console.log('ðŸ“Š Registration comparison:', {
                  'original': registration.scope,
                  'new': newRegistration.scope,
                  'same': newRegistration === registration
                });
                
                // Check the new registration state
                if (newRegistration.waiting) {
                  console.log('âš ï¸ PWA: New service worker is waiting to activate');
                  // Force activation
                  newRegistration.waiting.postMessage({type: 'SKIP_WAITING'});
                }
                if (newRegistration.installing) {
                  console.log('ðŸ“¦ PWA: New service worker is installing');
                  const installingWorker = newRegistration.installing;
                  // Wait for it to install and then activate
                  installingWorker.addEventListener('statechange', () => {
                    if (installingWorker.state === 'installed') {
                      console.log('ðŸŽ¯ PWA: New service worker installed');
                    }
                  });
                }
                if (newRegistration.active && newRegistration !== registration) {
                  console.log('ðŸ”„ PWA: New service worker activated - RELOAD DISABLED');
                  // window.location.reload(); // DISABLED TO PREVENT LOOP
                }
                
                // DISABLED: Force reload after 2 seconds - CAUSING LOOP
                // setTimeout(() => {
                //   console.log('â° PWA: Force reload after timeout');
                //   window.location.reload();
                // }, 2000);
              }).catch(error => {
                console.log('âŒ PWA: Cache-busted update failed:', error);
                // Fallback to regular update
                registration.update().then(() => {
                  console.log('âœ… PWA: Fallback update check completed');
                }).catch(fallbackError => {
                  console.log('âŒ PWA: Fallback update also failed:', fallbackError);
                });
              });
            };
            
            // DISABLED: Aggressive update checking causing refresh loop
            // window.checkForUpdates();
            
            // DISABLED: Auto-update interval to prevent refresh loop
            // Set up automatic update checking with safeguards
            const isPWA = window.matchMedia('(display-mode: standalone)').matches || 
                         window.navigator.standalone === true;
            const updateInterval = isPWA ? 30000 : 60000; // 30s for PWA, 60s for browser
            
            // Create a function to start auto-updates (can be called manually)
            window.startAutoUpdates = () => {
              console.log('ðŸš€ PWA: Starting auto-update system...');
              console.log('ðŸ“Š PWA Detection:', {
                isPWA: isPWA,
                updateInterval: updateInterval,
                checkForUpdatesExists: typeof window.checkForUpdates
              });
              
              // Clear any existing interval first
              if (window.updateIntervalId) {
                clearInterval(window.updateIntervalId);
                console.log('ðŸ§¹ PWA: Cleared existing interval');
              }
              
              if (typeof window.checkForUpdates === 'function') {
                window.updateIntervalId = setInterval(window.checkForUpdates, updateInterval);
                console.log('âœ… PWA: Auto-update enabled with', updateInterval/1000, 'second interval');
                console.log('ðŸ” PWA: Interval ID:', window.updateIntervalId);
                
                // Test the function immediately
                console.log('ðŸ§ª PWA: Testing checkForUpdates function...');
                window.checkForUpdates();
              } else {
                console.error('âŒ PWA: checkForUpdates function not found!');
              }
            };
            
            // DISABLED: Auto-updates for debugging pull-to-refresh
            // Add safeguard: only start auto-updates after initial load
            // console.log('â° PWA: Setting 5-second timeout for auto-update startup...');
            // setTimeout(() => {
            //   console.log('â° PWA: 5-second timeout triggered, starting auto-updates...');
            //   window.startAutoUpdates();
            // }, 5000); // Wait 5 seconds before starting auto-updates
            console.log('âš ï¸ PWA auto-updates DISABLED for debugging');
            
            // Handle updates
            registration.addEventListener('updatefound', () => {
              const newWorker = registration.installing;
              console.log('PWA: New service worker found, installing...');
              
              newWorker.addEventListener('statechange', () => {
                if (newWorker.state === 'installed') {
                  if (navigator.serviceWorker.controller) {
                    console.log('PWA: New content available, reloading...');
                    
                    // Show update notification for PWA
                    const isPWAForUpdate = window.matchMedia('(display-mode: standalone)').matches || 
                                          window.navigator.standalone === true;
                    if (isPWAForUpdate) {
                      showUpdateNotification();
                      
                      // Clear the update interval to prevent multiple reloads
                      if (window.updateIntervalId) {
                        clearInterval(window.updateIntervalId);
                        console.log('ðŸ›‘ PWA: Cleared update interval before reload');
                      }
                      
                      // DISABLED: Delay reload - CAUSING REFRESH LOOP
                      // setTimeout(() => {
                      //   console.log('ðŸ”„ PWA: Reloading for update...');
                      //   window.location.reload();
                      // }, 2000);
                    } else {
                      // DISABLED: Immediate reload - CAUSING LOOP
                      // window.location.reload();
                    }
                  } else {
                    console.log('PWA: Content cached for offline use');
                  }
                }
              });
            });
            
            // Handle controller change (new service worker activated)
            navigator.serviceWorker.addEventListener('controllerchange', () => {
              console.log('PWA: New service worker activated');
              
              // Clear any existing update intervals to prevent loops
              if (window.updateIntervalId) {
                clearInterval(window.updateIntervalId);
                console.log('ðŸ›‘ PWA: Cleared update interval on controller change');
              }
              
              // Update version indicator
              if (window.updatePWAVersionIndicator) {
                window.updatePWAVersionIndicator();
              }
              
              console.log('ðŸ”„ PWA: New controller activated - RELOAD DISABLED');
              // window.location.reload(); // DISABLED TO PREVENT REFRESH LOOP
            });
          })
          .catch((error) => {
            console.log('PWA: Service Worker registration failed:', error);
          });
      });
    } else if ('serviceWorker' in navigator && !isPWAMode) {
      console.log('ðŸŒ Desktop Browser: Service Worker disabled to prevent refresh loops');
      console.log('ðŸ’¡ Desktop users can manually refresh with Ctrl+R or F5');
    } else {
      console.log('âŒ Service Worker not supported in this browser');
    }

    // PWA Install Prompt
    let deferredPrompt;
    let installButton;

    window.addEventListener('beforeinstallprompt', (e) => {
      console.log('PWA: Install prompt available');
      // Prevent the mini-infobar from appearing on mobile
      e.preventDefault();
      // Stash the event so it can be triggered later
      deferredPrompt = e;
      // Show install button
      showInstallButton();
    });

    window.addEventListener('appinstalled', (evt) => {
      console.log('PWA: App was installed');
      hideInstallButton();
    });

    function showInstallButton() {
      // Create install button if it doesn't exist
      if (!installButton) {
        installButton = document.createElement('button');
        installButton.textContent = 'ðŸ“± Install App';
        installButton.style.cssText = `
          position: fixed;
          bottom: 20px;
          right: 20px;
          background: #1976d2;
          color: white;
          border: none;
          padding: 12px 16px;
          border-radius: 8px;
          font-size: 14px;
          font-weight: 500;
          cursor: pointer;
          box-shadow: 0 4px 8px rgba(0,0,0,0.2);
          z-index: 1000;
          font-family: 'Inter', sans-serif;
          transition: all 0.3s ease;
        `;
        
        installButton.addEventListener('mouseover', () => {
          installButton.style.background = '#1565c0';
          installButton.style.transform = 'translateY(-2px)';
        });
        
        installButton.addEventListener('mouseout', () => {
          installButton.style.background = '#1976d2';
          installButton.style.transform = 'translateY(0)';
        });
        
        installButton.addEventListener('click', async () => {
          if (deferredPrompt) {
            // Show the install prompt
            deferredPrompt.prompt();
            // Wait for the user to respond to the prompt
            const { outcome } = await deferredPrompt.userChoice;
            console.log(`PWA: User response to install prompt: ${outcome}`);
            // Clear the deferredPrompt
            deferredPrompt = null;
            hideInstallButton();
          }
        });
        
        document.body.appendChild(installButton);
      }
      
      installButton.style.display = 'block';
    }

    function hideInstallButton() {
      if (installButton) {
        installButton.style.display = 'none';
      }
    }

    // Hide install button if already installed (standalone mode)
    if (window.matchMedia('(display-mode: standalone)').matches) {
      console.log('PWA: App is running in standalone mode');
      hideInstallButton();
    }

    // PWA Detection and Customization
    function detectPWAMode() {
      const isStandalone = window.matchMedia('(display-mode: standalone)').matches;
      const isIOSStandalone = window.navigator.standalone === true;
      const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      const isTablet = /iPad|Android(?!.*Mobile)/i.test(navigator.userAgent);
      
      return {
        isPWA: isStandalone || isIOSStandalone,
        isStandalone: isStandalone,
        isIOSStandalone: isIOSStandalone,
        isMobile: isMobile,
        isTablet: isTablet,
        isDesktop: !isMobile && !isTablet,
        displayMode: isStandalone ? 'standalone' : 'browser'
      };
    }

    // Apply PWA-specific customizations
    function applyPWACustomizations() {
      const pwaInfo = detectPWAMode();
      console.log('PWA Detection:', pwaInfo);
      
      // Add CSS classes for different modes
      document.body.classList.add(pwaInfo.isPWA ? 'pwa-mode' : 'browser-mode');
      document.body.classList.add(pwaInfo.isMobile ? 'mobile-device' : 'desktop-device');
      document.body.classList.add(`display-${pwaInfo.displayMode}`);
      
      // Store PWA info globally for other functions to use
      window.pwaInfo = pwaInfo;
      
      if (pwaInfo.isPWA) {
        console.log('ðŸš€ Running as PWA - Applying app-specific features');
        enablePWAFeatures();
      } else {
        console.log('ðŸŒ Running in browser - Standard web experience');
        enableBrowserFeatures();
      }
    }

    // PWA-specific features (layout customizations disabled, but keep essential features)
    function enablePWAFeatures() {
      console.log('PWA features: keeping essential features, layout customizations disabled');
      
      // Hide desktop version indicator for PWA
      const desktopVersionIndicator = document.getElementById('desktop-version-indicator');
      if (desktopVersionIndicator) {
        desktopVersionIndicator.style.display = 'none';
      }
      
      // Check if sync is configured and show warning if not
      checkSyncConfiguration();
      
      // Keep essential features that don't break layout
      addHapticFeedback();
      addSwipeGestures(); // This includes pull-to-refresh with visual feedback
      addPWAStatusBarFix(); // Fix for iOS status bar white banner
      addPWAVersionIndicator(); // Add version indicator for debugging and manual updates
      addPWAGroceryIconFix(); // Force correct grocery icon positioning via JavaScript
      addAutoZoomReset(); // Auto zoom out when leaving text inputs
      addPWACalendarOptimizations(); // Optimize calendar for mobile touch interface
      addPWANavigationAlignment(); // Align Calendar title with Dashboard title
      addPWACalendarPositionFix(); // Force Calendar positioning via JavaScript
      // addMobileOptimizations(); // DISABLED - this was breaking layout
      // addAppSpecificUI(); // DISABLED - this was adding unwanted UI elements
      
      // Hide loading screen after all customizations are applied
      setTimeout(() => {
        const loadingScreen = document.getElementById('pwa-loading-screen');
        if (loadingScreen) {
          loadingScreen.classList.add('hidden');
          console.log('âœ… PWA loading screen hidden');
          // Remove from DOM after fade out
          setTimeout(() => {
            loadingScreen.remove();
          }, 300);
        }
      }, 500); // Longer delay to ensure all positioning is complete
    }

    // Check if sync is configured and show warning banner if not
    function checkSyncConfiguration() {
      const hasGistId = !!localStorage.getItem('dashboardGistId');
      const hasToken = !!localStorage.getItem('githubToken');
      
      if (!hasGistId || !hasToken) {
        console.log('âš ï¸ Sync not configured - showing warning banner');
        
        // Create warning banner
        const banner = document.createElement('div');
        banner.id = 'sync-warning-banner';
        banner.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          background: linear-gradient(135deg, #ff6b6b, #ee5a6f);
          color: white;
          padding: 12px 16px;
          text-align: center;
          font-size: 14px;
          font-weight: 600;
          z-index: 10000;
          box-shadow: 0 2px 10px rgba(0,0,0,0.3);
          cursor: pointer;
        `;
        banner.innerHTML = `
          âš ï¸ Sync Not Configured - Tap to Set Up
        `;
        
        // Click to open sync settings
        banner.addEventListener('click', () => {
          showPWASyncSettings();
          banner.remove();
        });
        
        document.body.appendChild(banner);
        
        // Auto-hide after 10 seconds
        setTimeout(() => {
          if (document.body.contains(banner)) {
            banner.style.transition = 'opacity 0.3s ease';
            banner.style.opacity = '0';
            setTimeout(() => banner.remove(), 300);
          }
        }, 10000);
      } else {
        console.log('âœ… Sync is configured');
      }
    }
    
    // Force correct PWA grocery icon positioning via JavaScript
    function addPWAGroceryIconFix() {
      // Wait for DOM to be ready, then apply correct positioning
      setTimeout(() => {
        const apple = document.querySelector('.nav-button:nth-child(6) .nav-icon .emoji-overlay');
        const baguette = document.querySelector('.nav-button:nth-child(6) .nav-icon .emoji-base');
        const basket = document.querySelector('.nav-button:nth-child(6) .nav-icon .emoji-basket');
        const groceryIcon = document.querySelector('.nav-button:nth-child(6) .nav-icon');
        const groceryLabel = document.querySelector('.nav-button:nth-child(6) .nav-label');
        
        if (apple) {
          apple.style.setProperty('left', '13.2px', 'important'); // 12.2px + 1px (move right)
          apple.style.setProperty('top', 'calc(31% + 4px)', 'important'); // 31% + 5px - 1px (unchanged)
          apple.style.setProperty('font-size', '0.663rem', 'important'); // 0.65rem * 1.02 (2% bigger)
          console.log('âœ… PWA: Applied apple positioning - 1px right from previous (0.663rem)');
        }
        
        if (baguette) {
          baguette.style.setProperty('right', '9.2px', 'important'); // 10.2px - 1px (move right)
          baguette.style.setProperty('top', 'calc(27% + 5px)', 'important'); // 27% + 2px + 3px (unchanged)
          baguette.style.setProperty('font-size', '0.91rem', 'important'); // 1.4rem * 0.65 (same scale as apple)
          console.log('âœ… PWA: Applied baguette positioning - 1px right from previous (0.65x scale)');
        }
        
        // Scale basket specifically and move up 4px
        if (basket) {
          basket.style.setProperty('font-size', '2.0rem', 'important'); // 2.5rem * 0.8
          basket.style.setProperty('bottom', '1px', 'important'); // -3px + 4px = 1px
          console.log('âœ… PWA: Scaled basket to 0.8x and moved up 4px via JavaScript');
        }
        
        // Move grocery icon up within the aligned button container
        if (groceryIcon) {
          groceryIcon.style.setProperty('transform', 'translateY(-8px)', 'important'); // -6px + 2px more
          console.log('âœ… PWA: Positioned grocery icon within aligned button via JavaScript');
        }
        
        // Move grocery title up within the aligned button container
        if (groceryLabel) {
          groceryLabel.style.setProperty('transform', 'translateY(-12px)', 'important'); // -8px + 4px more
          console.log('âœ… PWA: Positioned grocery title within aligned button via JavaScript');
        }
      }, 500); // Wait 500ms for elements to be ready
    }

    // PWA Simplified Dashboard Layout
    function applyPWADashboardLayout() {
      const main = document.querySelector('main');
      const header = document.querySelector('header');
      
      if (!main || !header) return;
      
      // Hide the main widget area
      main.style.display = 'none';
      
      // Hide the default header (we'll create our own)
      header.style.display = 'none';
      
      // Create custom header for PWA dashboard (matching fullscreen views)
      let pwaDashboardHeader = document.getElementById('pwa-dashboard-header');
      if (!pwaDashboardHeader) {
        pwaDashboardHeader = document.createElement('div');
        pwaDashboardHeader.id = 'pwa-dashboard-header';
        pwaDashboardHeader.className = 'fullscreen-header';
        pwaDashboardHeader.style.cssText = `
          display: flex;
          justify-content: space-between;
          align-items: center;
          padding: 1.5rem 2rem;
          background: rgba(255, 255, 255, 0.1);
          backdrop-filter: blur(10px);
          border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        `;
        
        const title = document.createElement('h1');
        title.className = 'fullscreen-title';
        title.textContent = 'Bennett Hub';
        title.style.cssText = `
          margin: 0;
          font-size: 1.5rem;
          color: white;
        `;
        
        const homeButton = document.createElement('button');
        homeButton.className = 'back-button';
        homeButton.onclick = showLandingPage;
        homeButton.textContent = 'Home';
        
        pwaDashboardHeader.appendChild(title);
        pwaDashboardHeader.appendChild(homeButton);
        
        document.getElementById('dashboard').insertBefore(pwaDashboardHeader, document.getElementById('dashboard').firstChild);
      }
      
      pwaDashboardHeader.style.display = 'flex';
      
      // Create simplified PWA dashboard content
      let pwaDashboard = document.getElementById('pwa-dashboard');
      if (!pwaDashboard) {
        pwaDashboard = document.createElement('div');
        pwaDashboard.id = 'pwa-dashboard';
        pwaDashboard.style.cssText = `
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          flex: 1;
          padding: 2rem;
          text-align: center;
          gap: 2rem;
        `;
        
        // Create large info display
        pwaDashboard.innerHTML = `
          <div style="
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            padding: 2rem;
            min-width: 300px;
          ">
            <div style="font-size: 1.5rem; font-weight: 600; color: white;">
              <span id="pwa-current-date">Loading...</span>
            </div>
            <div style="font-size: 3rem; font-weight: 300; color: white;">
              <span id="pwa-current-time">Loading...</span>
            </div>
            <div style="display: flex; align-items: center; justify-content: center; gap: 1rem; font-size: 1.25rem;">
              <span id="pwa-weather-icon" style="font-size: 2rem;">ðŸŒ¡ï¸</span>
              <span id="pwa-current-temp" style="color: white; font-weight: 500;">Loading...</span>
            </div>
            <div id="pwa-precipitation-info" style="display: none; font-size: 1rem; color: rgba(255,255,255,0.9);">
              <span id="pwa-precip-icon" style="margin-right: 0.5rem;">ðŸ’§</span>
              <span id="pwa-precip-details">--</span>
            </div>
          </div>
        `;
        
        document.getElementById('dashboard').appendChild(pwaDashboard);
      }
      
      pwaDashboard.style.display = 'flex';
      
      // Update PWA dashboard with current data
      updatePWADashboardData();
      
      console.log('âœ… PWA: Applied simplified dashboard layout with header');
    }
    
    // Show PWA Sync Settings
    function showPWASyncSettings() {
      const hasToken = !!GITHUB_TOKEN;
      const hasGist = !!GIST_ID;
      
      let message = `ðŸ”„ SYNC SETTINGS\n\n`;
      
      if (hasToken && hasGist) {
        message += `âœ… Sync is configured!\n\n`;
        message += `ðŸ™ GitHub Gist ID:\n${GIST_ID}\n\n`;
        message += `ðŸ”‘ Token: ${GITHUB_TOKEN.substring(0, 8)}...\n\n`;
        message += `ðŸ“± Pull down to refresh to sync with desktop.\n\n`;
        message += `What would you like to do?\n\n`;
        message += `â€¢ OK = Close\n`;
        message += `â€¢ Cancel = Reconfigure sync`;
        
        const keepSettings = confirm(message);
        if (!keepSettings) {
          setupGithubAuth();
        }
      } else if (hasToken && !hasGist) {
        message += `âš ï¸ Token found but no Gist ID!\n\n`;
        message += `ðŸ”‘ Token: ${GITHUB_TOKEN.substring(0, 8)}...\n\n`;
        message += `You need to add your Gist ID to sync with your desktop.\n\n`;
        message += `To find your Gist ID on desktop:\n`;
        message += `1. Open browser console (F12)\n`;
        message += `2. Type: localStorage.getItem('dashboardGistId')\n`;
        message += `3. Copy the ID\n\n`;
        message += `Click OK to enter your Gist ID now.`;
        
        if (confirm(message)) {
          const gistId = prompt(`ðŸ™ Enter your GitHub Gist ID:\n\nPaste the Gist ID from your desktop:\n(It should be a long string like: abc123def456...)\n\nGist ID:`);
          
          if (gistId && gistId.trim()) {
            GIST_ID = gistId.trim();
            localStorage.setItem('dashboardGistId', GIST_ID);
            console.log('âœ… Gist ID saved:', GIST_ID);
            
            // Try to load data from the gist
            loadAllData().then(() => {
              renderTodoList();
              renderGroceryList();
              renderMealsList();
              alert(`âœ… Gist ID saved!\n\nðŸ™ ${GIST_ID}\n\nðŸ“± Your PWA is now syncing with your desktop!\n\nData will sync automatically every 30 seconds.`);
              
              // Update button icon
              const syncIcon = document.getElementById('pwa-sync-button-icon');
              if (syncIcon) syncIcon.textContent = 'âœ…';
            });
          } else {
            alert('âŒ No Gist ID provided. Sync will not work until you add it.');
          }
        }
      } else if (hasGist && !hasToken) {
        message += `âš ï¸ Gist ID found but no token!\n\n`;
        message += `ðŸ™ Gist ID: ${GIST_ID}\n\n`;
        message += `You need to add your GitHub token to enable sync.\n\n`;
        message += `Click OK to set up your token now.`;
        
        if (confirm(message)) {
          setupGithubAuth();
        }
      } else {
        message += `âŒ Sync is not configured\n\n`;
        message += `To sync between your PWA and desktop:\n\n`;
        message += `1. Set up GitHub token (one time)\n`;
        message += `2. Your Gist ID will be created automatically\n`;
        message += `3. All devices will sync every 30 seconds\n\n`;
        message += `Click OK to set up sync now.`;
        
        if (confirm(message)) {
          setupGithubAuth();
        }
      }
      
      // Update sync button icon based on status
      const syncIcon = document.getElementById('pwa-sync-button-icon');
      if (syncIcon) {
        if (hasToken && hasGist) {
          syncIcon.textContent = 'âœ…';
        } else {
          syncIcon.textContent = 'âš™ï¸';
        }
      }
    }
    
    // Update PWA dashboard with current header data
    function updatePWADashboardData() {
      // Copy date
      const sourceDate = document.getElementById('current-date');
      const targetDate = document.getElementById('pwa-current-date');
      if (sourceDate && targetDate) {
        targetDate.textContent = sourceDate.textContent;
      }
      
      // Copy time
      const sourceTime = document.getElementById('current-time');
      const targetTime = document.getElementById('pwa-current-time');
      if (sourceTime && targetTime) {
        targetTime.textContent = sourceTime.textContent;
      }
      
      // Copy weather
      const sourceTemp = document.getElementById('current-temp');
      const targetTemp = document.getElementById('pwa-current-temp');
      const sourceWeatherIcon = document.getElementById('weather-icon');
      const targetWeatherIcon = document.getElementById('pwa-weather-icon');
      
      if (sourceTemp && targetTemp) {
        targetTemp.textContent = sourceTemp.textContent;
      }
      if (sourceWeatherIcon && targetWeatherIcon) {
        targetWeatherIcon.textContent = sourceWeatherIcon.textContent;
      }
      
      // Copy precipitation
      const sourcePrecipInfo = document.getElementById('precipitation-info');
      const targetPrecipInfo = document.getElementById('pwa-precipitation-info');
      const sourcePrecipIcon = document.getElementById('precip-icon');
      const targetPrecipIcon = document.getElementById('pwa-precip-icon');
      const sourcePrecipDetails = document.getElementById('precip-details');
      const targetPrecipDetails = document.getElementById('pwa-precip-details');
      
      if (sourcePrecipInfo && targetPrecipInfo) {
        if (sourcePrecipInfo.style.display !== 'none') {
          targetPrecipInfo.style.display = 'block';
          if (sourcePrecipIcon && targetPrecipIcon) {
            targetPrecipIcon.textContent = sourcePrecipIcon.textContent;
          }
          if (sourcePrecipDetails && targetPrecipDetails) {
            targetPrecipDetails.textContent = sourcePrecipDetails.textContent;
          }
        } else {
          targetPrecipInfo.style.display = 'none';
        }
      }
    }

    // PWA Calendar Optimizations for Mobile Touch Interface
    function addPWACalendarOptimizations() {
      const style = document.createElement('style');
      style.id = 'pwa-calendar-optimizations';
      style.textContent = `
        /* PWA Calendar Mobile Optimizations */
        body.pwa-mode .calendar-day {
          min-height: 80px !important; /* Increased from 60px */
          padding: 12px 8px !important; /* Increased from 8px 4px */
          font-size: 14px !important; /* Increased from 12px */
        }
        
        /* Calendar todo items - larger touch targets */
        body.pwa-mode .calendar-day > div[onclick] {
          font-size: 12px !important; /* Increased from 10px */
          padding: 6px 8px !important; /* Increased from 2px 4px */
          margin: 3px 0 !important; /* Increased from 1px 0 */
          min-height: 32px !important; /* Minimum touch target */
          display: flex !important;
          align-items: center !important;
          line-height: 1.2 !important;
        }
        
        /* Calendar navigation buttons - larger for touch */
        body.pwa-mode button[onclick*="navigateCalendar"] {
          padding: 12px 20px !important; /* Increased from 8px 16px */
          font-size: 16px !important; /* Increased from 14px */
          min-height: 48px !important; /* Standard touch target */
        }
        
        /* Calendar avatar filter buttons - larger for touch */
        body.pwa-mode .calendar-avatar-filter {
          width: 36px !important; /* Increased from 28px */
          height: 36px !important; /* Increased from 28px */
          font-size: 14px !important; /* Increased from 12px */
          margin: 0 4px !important; /* Add spacing */
        }
        
        /* Calendar header - better mobile spacing */
        body.pwa-mode .calendar-day:first-child {
          font-size: 16px !important; /* Day headers larger */
          padding: 12px !important;
          font-weight: bold !important;
        }
        
        /* Calendar month title - larger for mobile */
        body.pwa-mode div[style*="font-size: 18px"] {
          font-size: 22px !important;
          padding: 16px !important;
        }
      `;
      document.head.appendChild(style);
      console.log('âœ… PWA: Calendar optimizations applied for mobile touch interface');
    }

    // PWA Navigation Icon Alignment
    function addPWANavigationAlignment() {
      const style = document.createElement('style');
      style.id = 'pwa-navigation-alignment';
      style.textContent = `
        /* PWA: Make calendar icon smaller */
        body.pwa-mode .nav-button:nth-child(2) .nav-icon img {
          width: 1.8125rem !important;
          height: 1.8125rem !important;
        }
        
        /* PWA: Reset calendar icon container position with maximum specificity */
        html body.pwa-mode.mobile-device.display-standalone .nav-button:nth-child(2) .nav-icon {
          transform: none !important;
          margin: 0 !important;
          position: relative !important;
          top: 0 !important;
          bottom: 0 !important;
        }
        
        /* PWA: Reset calendar text position with maximum specificity */
        html body.pwa-mode.mobile-device.display-standalone .nav-button:nth-child(2) .nav-label {
          transform: none !important;
          margin: 0 !important;
          position: relative !important;
          top: 0 !important;
          bottom: 0 !important;
        }
        
        /* PWA: Force calendar button content to center naturally */
        html body.pwa-mode.mobile-device.display-standalone .nav-button:nth-child(2) {
          display: flex !important;
          flex-direction: column !important;
          align-items: center !important;
          justify-content: center !important;
        }
      `;
      document.head.appendChild(style);
      console.log('âœ… PWA: Navigation alignment applied - Calendar title aligned with Dashboard');
    }

    // PWA Calendar Position Fix via JavaScript (similar to grocery icon fix)
    function addPWACalendarPositionFix() {
      // Wait for DOM to be ready, then force correct positioning
      setTimeout(() => {
        const calendarIcon = document.querySelector('.nav-button:nth-child(2) .nav-icon');
        const calendarLabel = document.querySelector('.nav-button:nth-child(2) .nav-label');
        
        if (calendarIcon) {
          calendarIcon.style.setProperty('transform', 'translateY(2px)', 'important');
          calendarIcon.style.setProperty('margin', '0', 'important');
          calendarIcon.style.setProperty('position', 'relative', 'important');
          calendarIcon.style.setProperty('top', '0', 'important');
          calendarIcon.style.setProperty('bottom', '0', 'important');
          console.log('âœ… PWA: Applied correct calendar icon positioning via JavaScript');
        }
        
        if (calendarLabel) {
          calendarLabel.style.setProperty('transform', 'translateY(1px)', 'important');
          calendarLabel.style.setProperty('margin', '0', 'important');
          calendarLabel.style.setProperty('position', 'relative', 'important');
          calendarLabel.style.setProperty('top', '0', 'important');
          calendarLabel.style.setProperty('bottom', '0', 'important');
          console.log('âœ… PWA: Applied correct calendar label positioning via JavaScript');
        }
        
        // Also force the button to use flex centering
        const calendarButton = document.querySelector('.nav-button:nth-child(2)');
        if (calendarButton) {
          calendarButton.style.setProperty('display', 'flex', 'important');
          calendarButton.style.setProperty('flex-direction', 'column', 'important');
          calendarButton.style.setProperty('align-items', 'center', 'important');
          calendarButton.style.setProperty('justify-content', 'normal', 'important');
          console.log('âœ… PWA: Applied correct calendar button layout via JavaScript');
        }
      }, 500); // Wait 500ms for elements to be ready
    }

    // Browser-specific features  
    function enableBrowserFeatures() {
      // Add browser-specific features
      addDesktopOptimizations();
      addKeyboardShortcuts();
      addBrowserSpecificUI();
    }

    // Mobile/PWA optimizations
    function addMobileOptimizations() {
      // Larger touch targets for mobile
      const style = document.createElement('style');
      style.textContent = `
        .pwa-mode button {
          min-height: 44px !important;
          min-width: 44px !important;
          padding: 12px 16px !important;
        }
        
        .pwa-mode .nav-button {
          padding: 20px !important;
          margin: 8px !important;
        }
        
        /* Ensure grocery icon looks identical in PWA mode - MAXIMUM SPECIFICITY */
        body.pwa-mode.mobile-device.display-standalone .nav-button:nth-child(6) .nav-icon {
          position: relative !important;
          display: inline-block !important;
          width: 50px !important;
          height: 50px !important;
          display: flex !important;
          align-items: center !important;
          justify-content: center !important;
          margin: 0 auto !important;
          font-size: 2rem !important;
          background: transparent !important;
        }
        
        body.pwa-mode.mobile-device.display-standalone .nav-button:nth-child(6) .nav-icon .emoji-basket {
          position: absolute !important;
          font-size: 2.5rem !important;
          bottom: -3px !important;
          left: 50% !important;
          transform: translateX(-50%) !important;
          z-index: 0 !important;
        }
        
        /* MAXIMUM SPECIFICITY PWA GROCERY ICON - USER TESTED PERFECT VALUES */
        html body.pwa-mode.mobile-device.display-standalone .nav-button:nth-child(6) .nav-icon .emoji-base {
          position: absolute !important;
          right: 4px !important;
          top: 27% !important;
          transform: translateY(-50%) !important;
          z-index: 1 !important;
          font-size: 1.4rem !important;
        }
        
        html body.pwa-mode.mobile-device.display-standalone .nav-button:nth-child(6) .nav-icon .emoji-overlay {
          position: absolute !important;
          left: 9px !important;
          top: 31% !important;
          transform: translateY(-50%) !important;
          z-index: 2 !important;
          font-size: 1.0rem !important;
          filter: drop-shadow(1px 1px 2px rgba(0, 0, 0, 0.3)) !important;
        }
        
        .pwa-mode input, .pwa-mode textarea, .pwa-mode select {
          font-size: 16px !important; /* Prevents zoom on iOS */
          padding: 12px !important;
        }
        
        .pwa-mode .widget {
          margin: 8px !important;
          border-radius: 12px !important;
        }
        
        /* Hide elements that don't make sense in app mode */
        .pwa-mode .install-prompt {
          display: none !important;
        }
        
        /* App-like header styling */
        .pwa-mode .fullscreen-header {
          background: linear-gradient(135deg, #1976d2, #42a5f5) !important;
          color: white !important;
          padding: 20px !important;
          border-radius: 0 !important;
        }
        
        /* PWA mobile styling removed - keep same layout as desktop */
      `;
      document.head.appendChild(style);
    }

    // Desktop/Browser optimizations
    function addDesktopOptimizations() {
      const style = document.createElement('style');
      style.textContent = `
        .browser-mode .widget {
          transition: transform 0.2s ease, box-shadow 0.2s ease !important;
        }
        
        .browser-mode .widget:hover {
          transform: translateY(-2px) !important;
          box-shadow: 0 8px 25px rgba(0,0,0,0.15) !important;
        }
        
        .browser-mode .nav-button:hover {
          transform: scale(1.05) !important;
        }
        
        /* Show install button in browser mode */
        .browser-mode .install-prompt {
          display: block !important;
        }
      `;
      document.head.appendChild(style);
    }

    // Add PWA version indicator for debugging and manual updates
    function addPWAVersionIndicator() {
      if (!window.pwaInfo?.isPWA) return;
      
      // Add version indicator (only visible when debugging needed)
      const versionIndicator = document.createElement('div');
      versionIndicator.id = 'pwa-version-indicator';
      versionIndicator.textContent = 'PWA v12.83 - Tap to Update';
      versionIndicator.style.cssText = `
        display: inline-block;
        font-size: 11px;
        color: rgba(255, 255, 255, 0.7);
        cursor: pointer;
        padding: 6px 12px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 8px;
        opacity: 0.8;
        transition: all 0.3s ease;
        border: 1px solid rgba(255, 255, 255, 0.2);
        font-weight: 500;
      `;
      
      // Make it more visible on touch for mobile
      versionIndicator.addEventListener('touchstart', () => {
        versionIndicator.style.opacity = '1';
        versionIndicator.style.background = 'rgba(255, 255, 255, 0.9)';
        versionIndicator.style.color = '#333';
      });
      
      versionIndicator.addEventListener('touchend', () => {
        setTimeout(() => {
          versionIndicator.style.opacity = '0.8';
          versionIndicator.style.background = 'rgba(0, 0, 0, 0.3)';
          versionIndicator.style.color = 'rgba(255, 255, 255, 0.7)';
        }, 200);
      });
      
      // Add click handler to show enhanced info popup
      versionIndicator.addEventListener('click', () => {
        showPWAInfoPopup();
      });
      
      // Append to placeholder instead of body
      const placeholder = document.getElementById('pwa-version-placeholder');
      if (placeholder) {
        placeholder.appendChild(versionIndicator);
      } else {
        document.body.appendChild(versionIndicator);
      }
      
      // Update version indicator with sync status
      const updateVersionIndicator = () => {
        const totalItems = todoItems.length + groceryItems.length + mealItems.length;
        const syncStatus = GIST_ID && GITHUB_TOKEN ? 'ðŸ”„' : (JSONBIN_ID ? 'ðŸ“¡' : 'ðŸ“±');
        versionIndicator.textContent = `PWA v12.83 ${syncStatus} (${totalItems})`;
        versionIndicator.title = `Tap for debug info and manual update. ${totalItems} items loaded. ${
          GIST_ID && GITHUB_TOKEN ? 'GitHub sync active' : 
          JSONBIN_ID ? 'JSONBin sync active' : 
          'Local storage only'
        }`;
      };
      
      // Update indicator initially and when data changes
      updateVersionIndicator();
      
      // Store update function globally so other parts can call it
      window.updatePWAVersionIndicator = updateVersionIndicator;
    }
    
    // Show enhanced PWA info popup
    function showPWAInfoPopup() {
      const debugInfo = debugPWADataLoading();
      const totalItems = debugInfo.currentData.todoItems.length + 
                        debugInfo.currentData.groceryItems.length + 
                        debugInfo.currentData.mealItems.length;
      
      const token = localStorage.getItem('githubToken') || 'No';
      const gistId = localStorage.getItem('dashboardGistId') || 'No';
      
      // Create overlay
      const overlay = document.createElement('div');
      overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.7);
        z-index: 10001;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 20px;
      `;
      
      // Create popup
      const popup = document.createElement('div');
      popup.style.cssText = `
        background: white;
        border-radius: 12px;
        max-width: 500px;
        width: 100%;
        max-height: 80vh;
        overflow-y: auto;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        position: relative;
      `;
      
      popup.innerHTML = `
        <div style="position: sticky; top: 0; background: white; padding: 20px 20px 10px 20px; border-bottom: 1px solid #eee; z-index: 1;">
          <button onclick="closeAllPopups()" style="
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.05);
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #666;
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            border-radius: 50%;
            transition: background 0.2s ease;
          " onmouseover="this.style.background='rgba(0, 0, 0, 0.1)'" onmouseout="this.style.background='rgba(0, 0, 0, 0.05)'">âœ•</button>
          
          <h2 style="margin: 0; color: #333; font-size: 20px;">PWA Info</h2>
        </div>
        
        <div style="padding: 20px;">
          
          <div style="display: flex; flex-direction: column; gap: 10px; margin-bottom: 20px;">
            <button onclick="manualVersionUpdate()" style="
              padding: 12px;
              background: #4caf50;
              color: white;
              border: none;
              border-radius: 8px;
              cursor: pointer;
              font-size: 14px;
              font-weight: 500;
            ">Update App Version</button>
            
            <button onclick="showDebugPanel()" style="
              padding: 12px;
              background: #ff9800;
              color: white;
              border: none;
              border-radius: 8px;
              cursor: pointer;
              font-size: 14px;
              font-weight: 500;
            ">Debug Info</button>
          </div>
          
          <div style="display: flex; flex-direction: column; gap: 15px; margin-bottom: 20px;">
            <div style="background: #f5f5f5; padding: 12px; border-radius: 8px;">
              <div style="font-weight: 600; color: #666; font-size: 12px; margin-bottom: 4px;">MODE</div>
              <div style="color: #333; font-size: 14px;">${debugInfo.pwaMode ? 'PWA' : 'Browser'}</div>
            </div>
            
            <div onclick="showEditTokenPopup()" style="background: #f5f5f5; padding: 12px; border-radius: 8px; cursor: pointer; transition: background 0.2s ease;" onmouseover="this.style.background='#e8e8e8'" onmouseout="this.style.background='#f5f5f5'">
              <div style="font-weight: 600; color: #666; font-size: 12px; margin-bottom: 4px;">GITHUB TOKEN (tap to edit)</div>
              <div style="display: flex; align-items: center; gap: 8px;">
                <div style="color: #333; font-size: 14px; flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${token === 'No' ? 'Not set - tap to add' : token.substring(0, 20) + '...'}</div>
                ${token !== 'No' ? `<button onclick="event.stopPropagation(); navigator.clipboard.writeText('${token}'); this.textContent='âœ“'; setTimeout(() => this.textContent='Copy', 1000)" style="padding: 4px 8px; background: #667eea; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px; white-space: nowrap;">Copy</button>` : ''}
              </div>
            </div>
            
            <div onclick="showEditGistPopup()" style="background: #f5f5f5; padding: 12px; border-radius: 8px; cursor: pointer; transition: background 0.2s ease;" onmouseover="this.style.background='#e8e8e8'" onmouseout="this.style.background='#f5f5f5'">
              <div style="font-weight: 600; color: #666; font-size: 12px; margin-bottom: 4px;">GIST ID (tap to edit)</div>
              <div style="display: flex; align-items: center; gap: 8px;">
                <div style="color: #333; font-size: 14px; flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${gistId === 'No' ? 'Not set - tap to add' : gistId}</div>
                ${gistId !== 'No' ? `<button onclick="event.stopPropagation(); navigator.clipboard.writeText('${gistId}'); this.textContent='âœ“'; setTimeout(() => this.textContent='Copy', 1000)" style="padding: 4px 8px; background: #667eea; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px; white-space: nowrap;">Copy</button>` : ''}
              </div>
            </div>
            
            <div style="background: #f5f5f5; padding: 12px; border-radius: 8px;">
              <div style="font-weight: 600; color: #666; font-size: 12px; margin-bottom: 4px;">ONLINE</div>
              <div style="color: #333; font-size: 14px;">${debugInfo.isOnline ? 'Yes' : 'No'}</div>
            </div>
            
            <div style="background: #f5f5f5; padding: 12px; border-radius: 8px;">
              <div style="font-weight: 600; color: #666; font-size: 12px; margin-bottom: 4px;">CURRENT DATA</div>
              <div style="color: #333; font-size: 14px;">${totalItems} items total</div>
            </div>
            
            <div style="background: #f5f5f5; padding: 12px; border-radius: 8px;">
              <div style="font-weight: 600; color: #666; font-size: 12px; margin-bottom: 4px;">TODOS</div>
              <div style="color: #333; font-size: 14px;">${debugInfo.currentData.todoItems.length} items</div>
            </div>
            
            <div style="background: #f5f5f5; padding: 12px; border-radius: 8px;">
              <div style="font-weight: 600; color: #666; font-size: 12px; margin-bottom: 4px;">GROCERY</div>
              <div style="color: #333; font-size: 14px;">${debugInfo.currentData.groceryItems.length} items</div>
            </div>
            
            <div style="background: #f5f5f5; padding: 12px; border-radius: 8px;">
              <div style="font-weight: 600; color: #666; font-size: 12px; margin-bottom: 4px;">MEALS</div>
              <div style="color: #333; font-size: 14px;">${debugInfo.currentData.mealItems.length} items</div>
            </div>
          </div>
        </div>
      `;
      
      overlay.className = 'pwa-info-overlay';
      overlay.appendChild(popup);
      document.body.appendChild(overlay);
      
      // Close on overlay click (but not popup click)
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
          overlay.remove();
        }
      });
    }
    
    // Show edit token popup
    function showEditTokenPopup() {
      // Save scroll position before showing edit popup
      const mainOverlay = document.querySelector('.pwa-info-overlay');
      if (mainOverlay) {
        const popup = mainOverlay.querySelector('div[style*="max-height"]');
        if (popup) {
          window.pwaPopupScrollPosition = popup.scrollTop;
        }
      }
      
      const currentToken = localStorage.getItem('githubToken') || '';
      
      const overlay = document.createElement('div');
      overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.7);
        z-index: 10002;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 20px;
      `;
      
      const popup = document.createElement('div');
      popup.style.cssText = `
        background: white;
        border-radius: 12px;
        max-width: 500px;
        width: 100%;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        padding: 20px;
      `;
      
      popup.innerHTML = `
        <h2 style="margin: 0 0 20px 0; color: #333; font-size: 20px;">Edit GitHub Token</h2>
        
        <input type="text" id="token-input" value="${currentToken}" placeholder="Enter GitHub token..." style="
          width: 100%;
          padding: 12px;
          border: 1px solid #ddd;
          border-radius: 8px;
          font-size: 14px;
          margin-bottom: 20px;
          box-sizing: border-box;
        ">
        
        <div style="display: flex; gap: 10px;">
          <button onclick="backToMainPopup()" style="
            flex: 1;
            padding: 12px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
          ">Back</button>
          
          <button onclick="saveToken()" style="
            flex: 1;
            padding: 12px;
            background: #4caf50;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
          ">Save</button>
        </div>
      `;
      
      overlay.className = 'pwa-edit-overlay';
      overlay.appendChild(popup);
      document.body.appendChild(overlay);
    }
    
    // Show edit gist popup
    function showEditGistPopup() {
      // Save scroll position before showing edit popup
      const mainOverlay = document.querySelector('.pwa-info-overlay');
      if (mainOverlay) {
        const popup = mainOverlay.querySelector('div[style*="max-height"]');
        if (popup) {
          window.pwaPopupScrollPosition = popup.scrollTop;
        }
      }
      
      const currentGist = localStorage.getItem('dashboardGistId') || '';
      
      const overlay = document.createElement('div');
      overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.7);
        z-index: 10002;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 20px;
      `;
      
      const popup = document.createElement('div');
      popup.style.cssText = `
        background: white;
        border-radius: 12px;
        max-width: 500px;
        width: 100%;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        padding: 20px;
      `;
      
      popup.innerHTML = `
        <h2 style="margin: 0 0 20px 0; color: #333; font-size: 20px;">Edit Gist ID</h2>
        
        <input type="text" id="gist-input" value="${currentGist}" placeholder="Enter Gist ID..." style="
          width: 100%;
          padding: 12px;
          border: 1px solid #ddd;
          border-radius: 8px;
          font-size: 14px;
          margin-bottom: 20px;
          box-sizing: border-box;
        ">
        
        <div style="display: flex; gap: 10px;">
          <button onclick="backToMainPopup()" style="
            flex: 1;
            padding: 12px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
          ">Back</button>
          
          <button onclick="saveGist()" style="
            flex: 1;
            padding: 12px;
            background: #4caf50;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
          ">Save</button>
        </div>
      `;
      
      overlay.className = 'pwa-edit-overlay';
      overlay.appendChild(popup);
      document.body.appendChild(overlay);
    }
    
    // Save token
    function saveToken() {
      const input = document.getElementById('token-input');
      const token = input.value.trim();
      
      if (token) {
        localStorage.setItem('githubToken', token);
        GITHUB_TOKEN = token;
        console.log('âœ… GitHub token saved');
      } else {
        localStorage.removeItem('githubToken');
        GITHUB_TOKEN = null;
        console.log('ðŸ—‘ï¸ GitHub token removed');
      }
      
      backToMainPopup();
    }
    
    // Save gist
    function saveGist() {
      const input = document.getElementById('gist-input');
      const gist = input.value.trim();
      
      if (gist) {
        localStorage.setItem('dashboardGistId', gist);
        GIST_ID = gist;
        console.log('âœ… Gist ID saved');
      } else {
        localStorage.removeItem('dashboardGistId');
        GIST_ID = null;
        console.log('ðŸ—‘ï¸ Gist ID removed');
      }
      
      backToMainPopup();
    }
    
    // Back to main popup
    function backToMainPopup() {
      // Just remove the edit overlay - keep main popup in place
      const editOverlay = document.querySelector('.pwa-edit-overlay');
      if (editOverlay) {
        editOverlay.remove();
      }
      
      // Update the main popup content to reflect any changes
      const mainOverlay = document.querySelector('.pwa-info-overlay');
      if (mainOverlay) {
        // Get current scroll position
        const popup = mainOverlay.querySelector('div[style*="max-height"]');
        const scrollPosition = popup ? popup.scrollTop : 0;
        
        // Update the content
        const debugInfo = debugPWADataLoading();
        const totalItems = debugInfo.currentData.todoItems.length + 
                          debugInfo.currentData.groceryItems.length + 
                          debugInfo.currentData.mealItems.length;
        
        const token = localStorage.getItem('githubToken') || 'No';
        const gistId = localStorage.getItem('dashboardGistId') || 'No';
        
        // Update token display
        const tokenContainer = mainOverlay.querySelector('div[style*="GITHUB TOKEN"]')?.parentElement;
        if (tokenContainer) {
          const tokenValueDiv = tokenContainer.querySelector('div[style*="flex: 1"]');
          if (tokenValueDiv) {
            tokenValueDiv.innerHTML = `
              <div style="color: #333; font-size: 14px; flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${token === 'No' ? 'No' : token.substring(0, 20) + '...'}</div>
              ${token !== 'No' ? `<button onclick="navigator.clipboard.writeText('${token}'); this.textContent='âœ“'; setTimeout(() => this.textContent='Copy', 1000)" style="padding: 4px 8px; background: #667eea; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px; white-space: nowrap;">Copy</button>` : ''}
            `;
          }
        }
        
        // Update gist display
        const gistContainer = mainOverlay.querySelector('div[style*="GIST ID"]')?.parentElement;
        if (gistContainer) {
          const gistValueDiv = gistContainer.querySelector('div[style*="flex: 1"]');
          if (gistValueDiv) {
            gistValueDiv.innerHTML = `
              <div style="color: #333; font-size: 14px; flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${gistId}</div>
              ${gistId !== 'No' ? `<button onclick="navigator.clipboard.writeText('${gistId}'); this.textContent='âœ“'; setTimeout(() => this.textContent='Copy', 1000)" style="padding: 4px 8px; background: #667eea; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px; white-space: nowrap;">Copy</button>` : ''}
            `;
          }
        }
        
        // Restore scroll position
        if (popup) {
          popup.scrollTop = scrollPosition;
        }
      }
    }
    
    // Close all popups
    function closeAllPopups() {
      const editOverlay = document.querySelector('.pwa-edit-overlay');
      const mainOverlay = document.querySelector('.pwa-info-overlay');
      const desktopOverlay = document.querySelector('.desktop-info-overlay');
      
      if (editOverlay) editOverlay.remove();
      if (mainOverlay) mainOverlay.remove();
      if (desktopOverlay) desktopOverlay.remove();
    }
    
    // Desktop info popup (similar to PWA)
    function showDesktopInfoPopup() {
      const token = localStorage.getItem('githubToken') || 'No';
      const gistId = localStorage.getItem('dashboardGistId') || 'No';
      
      // Create overlay
      const overlay = document.createElement('div');
      overlay.className = 'desktop-info-overlay';
      overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.7);
        z-index: 10001;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 20px;
      `;
      
      // Create popup
      const popup = document.createElement('div');
      popup.style.cssText = `
        background: white;
        border-radius: 12px;
        max-width: 500px;
        width: 100%;
        max-height: 80vh;
        overflow-y: auto;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        position: relative;
      `;
      
      popup.innerHTML = `
        <div style="position: sticky; top: 0; background: white; padding: 20px 20px 10px 20px; border-bottom: 1px solid #eee; z-index: 1;">
          <button id="desktop-close-btn" onclick="closeAllPopups()" style="
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.08);
            border: none;
            font-size: 28px;
            line-height: 1;
            cursor: pointer;
            color: #333;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            border-radius: 50%;
            transition: all 0.2s ease;
            font-weight: bold;
          " onmouseover="this.style.background='#ff4444'; this.style.color='white'; this.style.transform='scale(1.1)'" onmouseout="this.style.background='rgba(0, 0, 0, 0.08)'; this.style.color='#333'; this.style.transform='scale(1)'">âœ•</button>
          
          <h2 style="margin: 0; color: #333; font-size: 20px;">Desktop Settings</h2>
        </div>
        
        <div style="padding: 20px;">
          
          <div style="display: flex; flex-direction: column; gap: 12px; font-size: 14px;">
            <div style="display: flex; justify-content: space-between; padding: 10px; background: #f5f5f5; border-radius: 6px;">
              <strong>Mode:</strong>
              <span>Desktop</span>
            </div>
            
            <div id="desktop-token-field" style="display: flex; justify-content: space-between; align-items: center; padding: 10px; background: #f5f5f5; border-radius: 6px; cursor: pointer; transition: background 0.2s ease;" onmouseover="this.style.background='#e8e8e8'" onmouseout="this.style.background='#f5f5f5'">
              <strong>GitHub Token: <span style="font-size: 11px; color: #666;">(click to edit)</span></strong>
              <div style="display: flex; align-items: center; gap: 8px;">
                <span style="font-family: monospace; font-size: 12px; max-width: 200px; overflow: hidden; text-overflow: ellipsis;">${token === 'No' ? 'Not set - click to add' : token.substring(0, 20) + '...'}</span>
                ${token !== 'No' ? `<button onclick="event.stopPropagation(); navigator.clipboard.writeText('${token}'); this.textContent='âœ“'; setTimeout(() => this.textContent='ðŸ“‹', 1000)" style="background: #667eea; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px;">ðŸ“‹</button>` : ''}
              </div>
            </div>
            
            <div id="desktop-gist-field" style="display: flex; justify-content: space-between; align-items: center; padding: 10px; background: #f5f5f5; border-radius: 6px; cursor: pointer; transition: background 0.2s ease;" onmouseover="this.style.background='#e8e8e8'" onmouseout="this.style.background='#f5f5f5'">
              <strong>Gist ID: <span style="font-size: 11px; color: #666;">(click to edit)</span></strong>
              <div style="display: flex; align-items: center; gap: 8px;">
                <span style="font-family: monospace; font-size: 12px;">${gistId === 'No' ? 'Not set - click to add' : gistId}</span>
                ${gistId !== 'No' ? `<button onclick="event.stopPropagation(); navigator.clipboard.writeText('${gistId}'); this.textContent='âœ“'; setTimeout(() => this.textContent='ðŸ“‹', 1000)" style="background: #667eea; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px;">ðŸ“‹</button>` : ''}
              </div>
            </div>
            
            <div style="display: flex; justify-content: space-between; padding: 10px; background: #f5f5f5; border-radius: 6px;">
              <strong>Online:</strong>
              <span>${navigator.onLine ? 'âœ… Yes' : 'âŒ No'}</span>
            </div>
            
            <div style="display: flex; justify-content: space-between; padding: 10px; background: #f5f5f5; border-radius: 6px;">
              <strong>Current Data:</strong>
              <div style="text-align: right;">
                <div>Todos: ${todoItems.length}</div>
                <div>Grocery: ${groceryItems.length}</div>
                <div>Meals: ${mealItems.length}</div>
              </div>
            </div>
          </div>
        </div>
      `;
      
      overlay.appendChild(popup);
      document.body.appendChild(overlay);
      
      // Add close button event listener
      const closeBtn = document.getElementById('desktop-close-btn');
      if (closeBtn) {
        closeBtn.addEventListener('click', function(e) {
          e.stopPropagation();
          console.log('Desktop close button clicked');
          closeAllPopups();
        });
      }
      
      // Add click handlers for editable fields
      const tokenField = document.getElementById('desktop-token-field');
      if (tokenField) {
        tokenField.addEventListener('click', showEditTokenPopup);
      }
      
      const gistField = document.getElementById('desktop-gist-field');
      if (gistField) {
        gistField.addEventListener('click', showEditGistPopup);
      }
      
      // Close on overlay click
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) closeAllPopups();
      });
    }
    
    // Manual version update
    function manualVersionUpdate() {
      forceAppUpdate();
      closeAllPopups();
    }

    // Fix iOS status bar white banner in PWA mode
    function addPWAStatusBarFix() {
      if (!window.pwaInfo?.isPWA) return;
      
      const style = document.createElement('style');
      style.textContent = `
        /* PWA Status Bar Fix - Ensure purple gradient extends to top */
        .pwa-mode body {
          background: var(--background) !important;
          background-attachment: fixed !important;
          min-height: 100vh !important;
          min-height: calc(100vh + env(safe-area-inset-top)) !important;
        }
        
        .pwa-mode html {
          background: var(--background) !important;
          background-attachment: fixed !important;
          min-height: 100vh !important;
          min-height: calc(100vh + env(safe-area-inset-top)) !important;
        }
        
        /* Ensure no white space at top - aggressive fix */
        .pwa-mode body::before {
          content: '';
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          height: 100px; /* Cover any possible status bar height */
          background: linear-gradient(135deg, #8c5ec4 0%, #764ba2 100%);
          z-index: -1;
        }
        
        /* Force remove any default iOS styling */
        .pwa-mode html, .pwa-mode body {
          background: linear-gradient(135deg, #8c5ec4 0%, #764ba2 100%) !important;
          margin: 0 !important;
          padding: 0 !important;
        }
        
        /* Override any system styling */
        .pwa-mode * {
          -webkit-appearance: none !important;
        }
      `;
      document.head.appendChild(style);
    }

    // Haptic feedback for PWA
    function addHapticFeedback() {
      if (!window.pwaInfo?.isPWA) return;
      
      // Add haptic feedback to buttons
      document.addEventListener('click', (e) => {
        if (e.target.matches('button, .nav-button, .clickable')) {
          // Haptic feedback (iOS only)
          if (navigator.vibrate) {
            navigator.vibrate(10); // Short vibration
          }
        }
      });
    }

    // App-specific UI elements
    function addAppSpecificUI() {
      // Status bar removed for cleaner home screen appearance
      
      // Refresh button removed - using pull-to-refresh only for cleaner UI
      
      // Add hidden app version indicator (only visible when debugging needed)
      const versionIndicator = document.createElement('div');
      versionIndicator.id = 'pwa-version-indicator';
      versionIndicator.textContent = 'PWA v12.83';
      versionIndicator.style.cssText = `
        position: fixed !important;
        bottom: 10px !important;
        left: 10px !important;
        font-size: 8px;
        color: rgba(255, 255, 255, 0.3);
        z-index: 99999 !important;
        cursor: pointer;
        padding: 2px 4px;
        background: transparent;
        border-radius: 4px;
        opacity: 0.1;
        transition: opacity 0.3s ease;
      `;
      
      // Make it more visible on hover for debugging
      versionIndicator.addEventListener('mouseenter', () => {
        versionIndicator.style.opacity = '0.8';
        versionIndicator.style.background = 'rgba(255, 255, 255, 0.9)';
        versionIndicator.style.color = '#666';
      });
      
      versionIndicator.addEventListener('mouseleave', () => {
        versionIndicator.style.opacity = '0.1';
        versionIndicator.style.background = 'transparent';
        versionIndicator.style.color = 'rgba(255, 255, 255, 0.3)';
      });
      
      // Add click handler for debug info
      versionIndicator.addEventListener('click', () => {
        const debugInfo = debugPWADataLoading();
        const totalItems = debugInfo.currentData.todoItems.length + 
                          debugInfo.currentData.groceryItems.length + 
                          debugInfo.currentData.mealItems.length;
        
        const message = `ðŸ” PWA Debug Info:
        
ðŸ“± Mode: ${debugInfo.pwaMode ? 'PWA' : 'Browser'}
ðŸŒ Online: ${debugInfo.isOnline ? 'Yes' : 'No'}
ðŸ”‘ GitHub Token: ${debugInfo.hasGithubToken ? 'Yes' : 'No'}
ðŸ“ Gist ID: ${debugInfo.hasGistId ? 'Yes' : 'No'}

ðŸ“Š Current Data: ${totalItems} items
ðŸ“ Todos: ${debugInfo.currentData.todoItems.length}
ðŸ›’ Grocery: ${debugInfo.currentData.groceryItems.length}  
ðŸ½ï¸ Meals: ${debugInfo.currentData.mealItems.length}

${totalItems === 0 ? 'âš ï¸ No data loaded! Try refreshing or check sync.' : 'âœ… Data loaded successfully'}`;
        
        alert(message);
      });
      
      document.body.appendChild(versionIndicator);
      
      // Update version indicator with sync status
      const updateVersionIndicator = () => {
        const totalItems = todoItems.length + groceryItems.length + mealItems.length;
        const syncStatus = GIST_ID && GITHUB_TOKEN ? 'ðŸ”„' : (JSONBIN_ID ? 'ðŸ“¡' : 'ðŸ“±');
        versionIndicator.textContent = `PWA v12.83 ${syncStatus} (${totalItems})`;
        versionIndicator.title = `Click for debug info. ${totalItems} items loaded. ${
          GIST_ID && GITHUB_TOKEN ? 'GitHub sync active' : 
          JSONBIN_ID ? 'JSONBin sync active' : 
          'Local storage only'
        }`;
      };
      
      // Update indicator initially and when data changes
      updateVersionIndicator();
      
      // Store update function globally so other parts can call it
      window.updatePWAVersionIndicator = updateVersionIndicator;
    }

    // Refresh app data function
    function refreshAppData() {
      console.log('ðŸ”„ Refreshing app data...');
      
      // Add spinning animation to refresh button
      const refreshButton = document.querySelector('button[title="Refresh app data"]');
      if (refreshButton) {
        refreshButton.style.animation = 'spin 1s linear infinite';
        refreshButton.style.pointerEvents = 'none';
      }
      
      // Add spin animation if not already added
      if (!document.querySelector('#refresh-spin-style')) {
        const style = document.createElement('style');
        style.id = 'refresh-spin-style';
        style.textContent = `
          @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
          }
        `;
        document.head.appendChild(style);
      }
      
      // Reload all data and refresh displays
      Promise.all([
        loadAllData(),
        // Small delay to show the refresh animation
        new Promise(resolve => setTimeout(resolve, 500))
      ]).then(() => {
        console.log('ðŸ”„ Refreshing all displays after data load...');
        console.log('ðŸ“Š Current data counts:', {
          todoItems: todoItems.length,
          todoHistory: todoHistory.length,
          groceryItems: groceryItems.length,
          mealItems: mealItems.length,
          mealHistory: mealHistory.length
        });
        
        // Update all displays (dashboard widgets)
        renderTodoList();
        renderGroceryList();
        renderMealsList();
        
        // ALWAYS refresh all fullscreen views - they check internally if they're visible
        // This ensures PWA views update regardless of detection issues
        console.log('ðŸ”„ Force-refreshing all fullscreen views...');
        renderTodoListFullscreen();
        renderGroceryListFullscreen();
        renderMealsListFullscreen();
        renderTodoCalendarFullscreen();
        
        // Refresh button removed - no reset needed
        
        // Add haptic feedback if available
        if (navigator.vibrate && window.pwaInfo?.isPWA) {
          navigator.vibrate(50);
        }
        
        console.log('âœ… App data refreshed successfully');
        
        // Update PWA version indicator if it exists
        if (window.updatePWAVersionIndicator) {
          window.updatePWAVersionIndicator();
        }
        
      }).catch((error) => {
        console.error('âŒ Error refreshing app data:', error);
        
        // Refresh button removed - no reset needed
      });
    }

    // Browser-specific UI elements
    function addBrowserSpecificUI() {
      // Add browser-specific indicators or features
      console.log('Browser mode - standard web features enabled');
    }

    // Keyboard shortcuts for desktop
    function addKeyboardShortcuts() {
      document.addEventListener('keydown', (e) => {
        if (e.ctrlKey || e.metaKey) {
          switch(e.key) {
            case 't':
              e.preventDefault();
              showFullscreenTodo();
              break;
            case 'g':
              e.preventDefault();
              showFullscreenGrocery();
              break;
            case 'm':
              e.preventDefault();
              showFullscreenMeals();
              break;
            case 'c':
              e.preventDefault();
              showFullscreenTodoCalendar();
              break;
            case 'r':
              e.preventDefault();
              refreshAppData();
              break;
          }
        }
      });
    }

    // Swipe gestures for PWA
    function addAutoZoomReset() {
      console.log('ðŸ” Adding auto zoom reset for text inputs...');
      
      // Listen for blur events on all input and textarea elements
      document.addEventListener('blur', (e) => {
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
          console.log('ðŸ“± Input blurred, resetting zoom...');
          
          // Reset viewport zoom by temporarily changing viewport meta tag
          const viewport = document.querySelector('meta[name=viewport]');
          if (viewport) {
            const originalContent = viewport.getAttribute('content');
            
            // Force zoom reset by setting scale to 1
            viewport.setAttribute('content', 'width=device-width, initial-scale=1.0, maximum-scale=1.0');
            
            // Restore original viewport after a brief moment
            setTimeout(() => {
              viewport.setAttribute('content', originalContent);
            }, 100);
          }
        }
      }, true); // Use capture phase to catch all blur events
      
      console.log('âœ… Auto zoom reset enabled');
    }
    
    function addSwipeGestures() {
      console.log('ðŸŽ¯ addSwipeGestures called - PWA Info:', window.pwaInfo);
      if (!window.pwaInfo?.isPWA) {
        console.log('âŒ Not PWA mode, skipping swipe gestures');
        return;
      }
      console.log('âœ… PWA mode detected, adding swipe gestures and pull-to-refresh');
      
      let startX, startY, endX, endY;
      let pullToRefreshTriggered = false;
      let isPulling = false;
      
      // Initialize content wrapper immediately
      setTimeout(() => {
        // Clean up any old wrapper first
        const oldWrapper = document.getElementById('pull-content-wrapper');
        if (oldWrapper) {
          // Move children back to body before removing
          Array.from(oldWrapper.children).forEach(child => document.body.appendChild(child));
          oldWrapper.remove();
          console.log('ðŸ§¹ Cleaned up old wrapper');
        }
        
        const wrapper = createContentWrapper();
        console.log('âœ… Content wrapper initialized:', wrapper ? 'SUCCESS' : 'FAILED');
        if (wrapper) {
          console.log('ðŸ“¦ Wrapper contains', wrapper.children.length, 'children');
        }
      }, 100);
      
      // Create pull-to-refresh overlay
      const createPullOverlay = () => {
        let overlay = document.getElementById('pull-refresh-overlay');
        if (!overlay) {
          overlay = document.createElement('div');
          overlay.id = 'pull-refresh-overlay';
          overlay.style.cssText = `
            position: fixed;
            top: -100px;
            left: 0;
            right: 0;
            height: 100px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10001;
            transition: none;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
          `;
          
          const content = document.createElement('div');
          content.id = 'pull-refresh-content';
          content.style.cssText = `
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            opacity: 0;
            transition: opacity 0.2s ease;
            padding: 20px;
          `;
          
          const icon = document.createElement('div');
          icon.id = 'pull-refresh-icon';
          icon.innerHTML = 'ðŸ”„';
          icon.style.cssText = `
            font-size: 40px;
            transition: transform 0.1s ease;
          `;
          
          const text = document.createElement('div');
          text.id = 'pull-refresh-text';
          text.textContent = 'Pull to refresh';
          text.style.cssText = `
            color: white;
            font-size: 16px;
            font-weight: 600;
            text-align: center;
          `;
          
          content.appendChild(icon);
          content.appendChild(text);
          overlay.appendChild(content);
          document.body.appendChild(overlay);
        }
        return overlay;
      };
      
      // Create content wrapper for pull effect
      const createContentWrapper = () => {
        let wrapper = document.getElementById('pull-content-wrapper');
        if (!wrapper) {
          wrapper = document.createElement('div');
          wrapper.id = 'pull-content-wrapper';
          wrapper.style.cssText = `
            transition: none;
            transform: translateY(0);
            width: 100%;
            min-height: 100vh;
          `;
          
          // Wrap all body content
          const bodyContent = Array.from(document.body.children).filter(
            child => child.id !== 'pull-refresh-overlay' && child.id !== 'pull-content-wrapper'
          );
          bodyContent.forEach(child => wrapper.appendChild(child));
          document.body.appendChild(wrapper);
          console.log('âœ… Content wrapper created with', bodyContent.length, 'children');
        } else {
          // Re-wrap any new content that was added outside the wrapper
          const bodyContent = Array.from(document.body.children).filter(
            child => child.id !== 'pull-refresh-overlay' && child.id !== 'pull-content-wrapper'
          );
          if (bodyContent.length > 0) {
            bodyContent.forEach(child => wrapper.appendChild(child));
            console.log('âœ… Re-wrapped', bodyContent.length, 'new children');
          }
        }
        return wrapper;
      };
      
      document.addEventListener('touchstart', (e) => {
        startX = e.touches[0].clientX;
        startY = e.touches[0].clientY;
        pullToRefreshTriggered = false;
        isPulling = false;
      });
      
      document.addEventListener('touchmove', (e) => {
        const currentY = e.touches[0].clientY;
        const deltaY = currentY - startY;
        
        // Check if any parent element is scrollable and not at top
        let target = e.target;
        let isScrollableAndNotAtTop = false;
        while (target && target !== document.body) {
          if (target.scrollTop > 0) {
            isScrollableAndNotAtTop = true;
            break;
          }
          target = target.parentElement;
        }
        
        // Only trigger pull-to-refresh if:
        // 1. At top of page (scrollY === 0)
        // 2. Touch started near top of screen (within 100px)
        // 3. Pulling DOWN (deltaY > 0)
        // 4. Not already triggered
        // 5. No scrollable parent is scrolled down
        if (!pullToRefreshTriggered && window.scrollY === 0 && startY < 100 && deltaY > 0 && !isScrollableAndNotAtTop) {
          
          // Start showing pull effect
          if (deltaY > 10 && Math.abs(e.touches[0].clientX - startX) < 50) {
            const wasNotPulling = !isPulling;
            if (wasNotPulling) {
              console.log('ðŸŽ¯ Starting pull effect, deltaY:', deltaY);
            }
            isPulling = true;
            const overlay = createPullOverlay();
            const contentWrapper = createContentWrapper();
            const content = document.getElementById('pull-refresh-content');
            const icon = document.getElementById('pull-refresh-icon');
            const text = document.getElementById('pull-refresh-text');
            
            if (!contentWrapper) {
              console.log('âŒ Content wrapper not found!');
              return; // Exit if wrapper doesn't exist
            }
            
            if (wasNotPulling) {
              console.log('âœ… Content wrapper found, children:', contentWrapper.children.length);
              console.log('ðŸ“ Overlay top:', overlay.style.top);
              console.log('ðŸ“ Content opacity:', content ? content.style.opacity : 'NOT FOUND');
            }
            
            // Calculate pull progress (max 150px for more visibility)
            const pullDistance = Math.min(deltaY, 150);
            const pullProgress = Math.min(pullDistance / 30, 1); // Full opacity at 30px (very fast)
            
            // Remove transitions during pull for immediate response
            overlay.style.transition = 'none';
            contentWrapper.style.transition = 'none';
            
            // Move overlay down from top - heavy amplification for better visibility
            const overlayPosition = Math.min(pullDistance * 5, 150); // 5x amplification!
            overlay.style.top = `${-100 + overlayPosition}px`;
            
            // Move content down
            contentWrapper.style.transform = `translateY(${pullDistance}px)`;
            
            if (wasNotPulling) {
              console.log('ðŸ“ Pull active - transforms applied');
            }
            
            // Update content opacity
            content.style.opacity = pullProgress;
            
            // Rotate icon based on pull distance
            icon.style.transform = `rotate(${pullProgress * 360}deg)`;
            
            if (wasNotPulling) {
              console.log('ðŸ“ Pull distance:', pullDistance, 'Progress:', pullProgress);
              console.log('ðŸ“ Content opacity after update:', content.style.opacity);
            }
            
            // Change text and trigger when pulled far enough (very low threshold)
            if (deltaY > 20) {
              text.textContent = 'Release to refresh';
              text.style.color = '#4caf50';
              pullToRefreshTriggered = true;
            } else {
              text.textContent = 'Pull to refresh';
              text.style.color = 'white';
              pullToRefreshTriggered = false;
            }
          }
        }
      });
      
      document.addEventListener('touchend', (e) => {
        endX = e.changedTouches[0].clientX;
        endY = e.changedTouches[0].clientY;
        
        const deltaX = endX - startX;
        const deltaY = endY - startY;
        
        const overlay = document.getElementById('pull-refresh-overlay');
        const contentWrapper = document.getElementById('pull-content-wrapper');
        const icon = document.getElementById('pull-refresh-icon');
        const text = document.getElementById('pull-refresh-text');
        
        // Trigger refresh if pulled far enough
        if (isPulling && deltaY > 20 && pullToRefreshTriggered) {
          // Show syncing state
          if (text) text.textContent = 'Syncing...';
          if (icon) {
            icon.style.animation = 'spin 1s linear infinite';
            // Add spin animation if not already added
            if (!document.querySelector('#pull-refresh-spin-style')) {
              const style = document.createElement('style');
              style.id = 'pull-refresh-spin-style';
              style.textContent = `
                @keyframes spin {
                  0% { transform: rotate(0deg); }
                  100% { transform: rotate(360deg); }
                }
              `;
              document.head.appendChild(style);
            }
          }
          
          // Keep overlay and content at syncing position
          if (overlay) {
            overlay.style.transition = 'top 0.3s ease';
            overlay.style.top = '0px';
          }
          if (contentWrapper) {
            contentWrapper.style.transition = 'transform 0.3s ease';
            contentWrapper.style.transform = 'translateY(150px)';
          }
          
          // Trigger sync
          console.log('ðŸ”„ Pull-to-refresh: Triggering data refresh...');
          refreshAppData();
          
          // Hide overlay and reset content after sync completes
          setTimeout(() => {
            if (overlay) {
              overlay.style.transition = 'top 0.5s ease-out';
              overlay.style.top = '-100px';
            }
            if (contentWrapper) {
              contentWrapper.style.transition = 'transform 0.5s ease-out';
              contentWrapper.style.transform = 'translateY(0)';
            }
            if (icon) {
              icon.style.animation = '';
            }
            setTimeout(() => {
              if (overlay && document.body.contains(overlay)) {
                document.body.removeChild(overlay);
              }
            }, 500);
          }, 1500);
        } else {
          // Cancel pull - reset everything
          if (overlay) {
            overlay.style.transition = 'top 0.3s ease-out';
            overlay.style.top = '-100px';
          }
          if (contentWrapper) {
            contentWrapper.style.transition = 'transform 0.3s ease-out';
            contentWrapper.style.transform = 'translateY(0)';
          }
          setTimeout(() => {
            if (overlay && document.body.contains(overlay)) {
              document.body.removeChild(overlay);
            }
          }, 300);
        }
        
        isPulling = false;
        pullToRefreshTriggered = false;
        hasVibratedOnThreshold = false;
        
        // Swipe right to go back (if in fullscreen mode)
        if (deltaX > 50 && Math.abs(deltaY) < 100) {
          if (document.getElementById('fullscreen-overlay').style.display === 'flex') {
            closeFullscreen();
          }
        }
      });
    }

    // Initialize PWA customizations when page loads (essential features only)
    document.addEventListener('DOMContentLoaded', () => {
      // Only apply PWA customizations if in PWA mode
      const isPWAModeForCustomizations = window.matchMedia('(display-mode: standalone)').matches || 
                                        window.navigator.standalone === true;
      
      if (isPWAModeForCustomizations) {
        setTimeout(applyPWACustomizations, 100);
        console.log('PWA customizations: essential features only (no layout changes)');
      } else {
        console.log('ðŸŒ Desktop Browser: PWA customizations disabled');
        // Hide loading screen immediately for desktop
        const loadingScreen = document.getElementById('pwa-loading-screen');
        if (loadingScreen) {
          loadingScreen.classList.add('hidden');
          setTimeout(() => loadingScreen.remove(), 300);
        }
      }
    });

    // PWA-specific data loading debug
    function debugPWADataLoading() {
      console.log('ðŸ” PWA Data Loading Debug:');
      console.log('- PWA Mode:', window.pwaInfo?.isPWA);
      console.log('- GIST_ID:', GIST_ID);
      console.log('- GITHUB_TOKEN:', GITHUB_TOKEN ? 'âœ… Present' : 'âŒ Missing');
      console.log('- JSONBIN_ID:', JSONBIN_ID);
      console.log('- Online Status:', isOnline);
      console.log('- Current Data:', {
        todoItems: todoItems.length,
        groceryItems: groceryItems.length,
        mealItems: mealItems.length,
        todoHistory: todoHistory.length,
        mealHistory: mealHistory.length
      });
      
      // Check localStorage
      const localData = {
        todoItems: JSON.parse(localStorage.getItem('todoItems') || '[]').length,
        groceryItems: JSON.parse(localStorage.getItem('groceryItems') || '[]').length,
        mealItems: JSON.parse(localStorage.getItem('mealItems') || '[]').length,
        todoHistory: JSON.parse(localStorage.getItem('todoHistory') || '[]').length,
        mealHistory: JSON.parse(localStorage.getItem('mealHistory') || '[]').length,
        gistId: localStorage.getItem('dashboardGistId'),
        githubToken: localStorage.getItem('githubToken') ? 'âœ… Present' : 'âŒ Missing'
      };
      console.log('- Local Storage:', localData);
      
      return {
        pwaMode: window.pwaInfo?.isPWA,
        hasGistId: !!GIST_ID,
        hasGithubToken: !!GITHUB_TOKEN,
        isOnline,
        currentData: getCurrentData(),
        localData
      };
    }

    // Enhanced refresh function for PWA debugging
    function refreshAppDataWithDebug() {
      console.log('ðŸ”„ PWA Refresh with Debug Info');
      debugPWADataLoading();
      
      // Force reload data
      return refreshAppData();
    }
  </script>

  </div> <!-- Close dashboard div -->
</body>
</html>
